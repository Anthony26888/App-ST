import { existsSync } from 'node:fs';
import { resolve, relative } from 'node:path';
import { confirm, spinner, outro } from '@clack/prompts';
import { createResolver } from 'exsolve';
import { underline, blue } from 'kolorist';
import { isPackageExists, getPackageInfoSync } from 'local-pkg';
import { addDevDependency } from 'nypm';
import { detect } from 'package-manager-detector';
import { FlatCompat } from '@eslint/eslintrc';

const compat = new FlatCompat({});
const DEFAULT_AUTO_IMPORTS_PATH = ".eslintrc-auto-import";
const { resolveModulePath: resolveModulePath$1 } = createResolver({ extensions: [".json"] });
function loadAutoImports(options = true) {
  if (!options) {
    return {};
  }
  if (typeof options === "object" && typeof options.src === "object") {
    return { languageOptions: options.src };
  }
  const autoImportsFile = typeof options === "object" && typeof options.src === "string" ? options.src : DEFAULT_AUTO_IMPORTS_PATH;
  try {
    const autoImportModuleURL = resolveModulePath$1(resolve(".", autoImportsFile), { try: true });
    if (!autoImportModuleURL) {
      return {};
    }
    return compat.extends(autoImportModuleURL)[0] ?? {};
  } catch {
    return {};
  }
}

const hasVuetifyConfig = hasPackage("eslint-config-vuetify");
async function interopDefault(m) {
  const awaited = await m;
  return awaited.default ?? awaited;
}
function isInEditorEnv() {
  if (process.env.CI) {
    return false;
  }
  if (isInGitHooksOrLintStaged()) {
    return false;
  }
  return !!(process.env.VSCODE_PID || process.env.VSCODE_CWD || process.env.JETBRAINS_IDE || process.env.VIM || process.env.NVIM);
}
function isInGitHooksOrLintStaged() {
  return !!(process.env.GIT_PARAMS || process.env.VSCODE_GIT_COMMAND || process.env.npm_lifecycle_script?.startsWith("lint-staged"));
}
function hasPackage(pkg, scope) {
  return isPackageExists(pkg, { paths: scope ? [scope] : [] });
}
function getPackageVersion(pkg) {
  return getPackageInfoSync(pkg, { paths: [currentScope] })?.version;
}
const currentScope = new URL(".", import.meta.url).pathname;
const currentRoot = process.cwd();
async function assertPackage(pkg, setting) {
  if (!hasPackage(pkg, currentScope)) {
    if (process.env.CI || process.stdout.isTTY === false || !hasVuetifyConfig) {
      return;
    }
    const result = await confirm({
      message: `Package ${pkg} is required for this config but not installed. Do you want to install it?`
    });
    if (result === true) {
      const s = spinner();
      s.start(`Installing ${pkg}`);
      await addDevDependency(pkg, { silent: true });
      s.stop(`Installed ${pkg}`);
      outro("Please, rerun the command or reopen your editor to apply the changes");
    } else {
      const { ESLint } = await import('eslint');
      const eslint = new ESLint({});
      const config = await eslint.findConfigFile();
      const configMessage = config ? `${underline(relative(currentRoot, config))}` : "config file";
      if (setting) {
        outro(`Please, install the package or set ${blue(setting)} in your ${configMessage}`);
      } else {
        outro(`Please, install the package or disable the setting in your ${configMessage} file`);
      }
    }
  }
}
function hasFile(file) {
  return existsSync(resolve(process.cwd(), file));
}
async function getPackageManager() {
  return detect({ cwd: process.cwd() });
}
const { resolveModulePath } = createResolver({ extensions: [".js", ".mjs", ".cjs", ".ts", ".mts", ".cts"] });
const configUrl = resolveModulePath("./eslint.config", { try: true });
function isVersionAtLeast(version, targetVersion) {
  const [vMajor, vMinor, vPatch] = version.split(".").map(Number);
  const [major, minor, patch] = targetVersion.split(".").map(Number);
  return vMajor > major || vMajor === major && vMinor > minor || vMajor === major && vMinor === minor && vPatch >= patch;
}

export { hasPackage as a, assertPackage as b, isInEditorEnv as c, getPackageVersion as d, isVersionAtLeast as e, configUrl as f, getPackageManager as g, hasFile as h, interopDefault as i, loadAutoImports as l };
