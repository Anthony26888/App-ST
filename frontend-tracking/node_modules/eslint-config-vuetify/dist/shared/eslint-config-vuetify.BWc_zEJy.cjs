'use strict';

const node_fs = require('node:fs');
const node_path = require('node:path');
const prompts = require('@clack/prompts');
const exsolve = require('exsolve');
const kolorist = require('kolorist');
const localPkg = require('local-pkg');
const nypm = require('nypm');
const packageManagerDetector = require('package-manager-detector');
const eslintrc = require('@eslint/eslintrc');

var _documentCurrentScript = typeof document !== 'undefined' ? document.currentScript : null;
const compat = new eslintrc.FlatCompat({});
const DEFAULT_AUTO_IMPORTS_PATH = ".eslintrc-auto-import";
const { resolveModulePath: resolveModulePath$1 } = exsolve.createResolver({ extensions: [".json"] });
function loadAutoImports(options = true) {
  if (!options) {
    return {};
  }
  if (typeof options === "object" && typeof options.src === "object") {
    return { languageOptions: options.src };
  }
  const autoImportsFile = typeof options === "object" && typeof options.src === "string" ? options.src : DEFAULT_AUTO_IMPORTS_PATH;
  try {
    const autoImportModuleURL = resolveModulePath$1(node_path.resolve(".", autoImportsFile), { try: true });
    if (!autoImportModuleURL) {
      return {};
    }
    return compat.extends(autoImportModuleURL)[0] ?? {};
  } catch {
    return {};
  }
}

const hasVuetifyConfig = hasPackage("eslint-config-vuetify");
async function interopDefault(m) {
  const awaited = await m;
  return awaited.default ?? awaited;
}
function isInEditorEnv() {
  if (process.env.CI) {
    return false;
  }
  if (isInGitHooksOrLintStaged()) {
    return false;
  }
  return !!(process.env.VSCODE_PID || process.env.VSCODE_CWD || process.env.JETBRAINS_IDE || process.env.VIM || process.env.NVIM);
}
function isInGitHooksOrLintStaged() {
  return !!(process.env.GIT_PARAMS || process.env.VSCODE_GIT_COMMAND || process.env.npm_lifecycle_script?.startsWith("lint-staged"));
}
function hasPackage(pkg, scope) {
  return localPkg.isPackageExists(pkg, { paths: scope ? [scope] : [] });
}
function getPackageVersion(pkg) {
  return localPkg.getPackageInfoSync(pkg, { paths: [currentScope] })?.version;
}
const currentScope = new URL(".", (typeof document === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : (_documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === 'SCRIPT' && _documentCurrentScript.src || new URL('shared/eslint-config-vuetify.BWc_zEJy.cjs', document.baseURI).href))).pathname;
const currentRoot = process.cwd();
async function assertPackage(pkg, setting) {
  if (!hasPackage(pkg, currentScope)) {
    if (process.env.CI || process.stdout.isTTY === false || !hasVuetifyConfig) {
      return;
    }
    const result = await prompts.confirm({
      message: `Package ${pkg} is required for this config but not installed. Do you want to install it?`
    });
    if (result === true) {
      const s = prompts.spinner();
      s.start(`Installing ${pkg}`);
      await nypm.addDevDependency(pkg, { silent: true });
      s.stop(`Installed ${pkg}`);
      prompts.outro("Please, rerun the command or reopen your editor to apply the changes");
    } else {
      const { ESLint } = await import('eslint');
      const eslint = new ESLint({});
      const config = await eslint.findConfigFile();
      const configMessage = config ? `${kolorist.underline(node_path.relative(currentRoot, config))}` : "config file";
      if (setting) {
        prompts.outro(`Please, install the package or set ${kolorist.blue(setting)} in your ${configMessage}`);
      } else {
        prompts.outro(`Please, install the package or disable the setting in your ${configMessage} file`);
      }
    }
  }
}
function hasFile(file) {
  return node_fs.existsSync(node_path.resolve(process.cwd(), file));
}
async function getPackageManager() {
  return packageManagerDetector.detect({ cwd: process.cwd() });
}
const { resolveModulePath } = exsolve.createResolver({ extensions: [".js", ".mjs", ".cjs", ".ts", ".mts", ".cts"] });
const configUrl = resolveModulePath("./eslint.config", { try: true });
function isVersionAtLeast(version, targetVersion) {
  const [vMajor, vMinor, vPatch] = version.split(".").map(Number);
  const [major, minor, patch] = targetVersion.split(".").map(Number);
  return vMajor > major || vMajor === major && vMinor > minor || vMajor === major && vMinor === minor && vPatch >= patch;
}

exports.assertPackage = assertPackage;
exports.configUrl = configUrl;
exports.getPackageManager = getPackageManager;
exports.getPackageVersion = getPackageVersion;
exports.hasFile = hasFile;
exports.hasPackage = hasPackage;
exports.interopDefault = interopDefault;
exports.isInEditorEnv = isInEditorEnv;
exports.isVersionAtLeast = isVersionAtLeast;
exports.loadAutoImports = loadAutoImports;
