import { writeFile, readFile } from 'node:fs/promises';
import { resolve, relative } from 'node:path';
import { intro, log, confirm, spinner, outro } from '@clack/prompts';
import { link, ansi256, underline } from 'kolorist';
import { addDevDependency } from 'nypm';
import { resolveCommand } from 'package-manager-detector/commands';
import { x } from 'tinyexec';
import { existsSync } from 'node:fs';
import { createResolver } from 'exsolve';
import { isPackageExists, getPackageInfoSync } from 'local-pkg';
import { detect } from 'package-manager-detector';
import { FlatCompat } from '@eslint/eslintrc';

const ESLINT = "eslint";
const ESLINT_CONFIG = "eslint-config-vuetify";
const VUETIFY = "vuetify";
const LINKS = {
  [ESLINT]: link(ESLINT, "https://npmjs.org/package/eslint"),
  [ESLINT_CONFIG]: link(ESLINT_CONFIG, "https://npmjs.org/package/eslint-config-vuetify"),
  [VUETIFY]: link("Vuetify", "https://vuetifyjs.com/")
};

const configData = `import vuetify from 'eslint-config-vuetify'

export default vuetify()
`;

new FlatCompat({});
const { resolveModulePath: resolveModulePath$1 } = createResolver({ extensions: [".json"] });

hasPackage("eslint-config-vuetify");
function hasPackage(pkg, scope) {
  return isPackageExists(pkg, { paths: [] });
}
function getPackageVersion(pkg) {
  return getPackageInfoSync(pkg, { paths: [currentScope] })?.version;
}
const currentScope = new URL(".", import.meta.url).pathname;
process.cwd();
function hasFile(file) {
  return existsSync(resolve(process.cwd(), file));
}
async function getPackageManager() {
  return detect({ cwd: process.cwd() });
}
const { resolveModulePath } = createResolver({ extensions: [".js", ".mjs", ".cjs", ".ts", ".mts", ".cts"] });
const configUrl = resolveModulePath("./eslint.config", { try: true });
function isVersionAtLeast(version, targetVersion) {
  const [vMajor, vMinor, vPatch] = version.split(".").map(Number);
  const [major, minor, patch] = targetVersion.split(".").map(Number);
  return vMajor > major || vMajor === major && vMinor > minor || vMajor === major && vMinor === minor && vPatch >= patch;
}

const blue = ansi256(33);
const description = `Welcome to ${blue(ESLINT_CONFIG)} \u2014 an opinionated ESLint config by the ${blue(LINKS[VUETIFY])} team.`;
const eslintVersion = getPackageVersion(ESLINT) ?? "0.0.0";
const configVersion = getPackageVersion(ESLINT_CONFIG) ?? "0.0.0";
const hasEslint = hasPackage(ESLINT);
const hasEslintConfig = hasPackage(ESLINT_CONFIG);
const isEslintVersionValid = isVersionAtLeast(eslintVersion, "9.5.0");
const isConfigVersionValid = isVersionAtLeast(configVersion, "4.0.0");
const packagesToInstall = [
  ...hasEslint ? [] : [ESLINT],
  ...hasEslintConfig ? [] : [ESLINT_CONFIG]
];
const packagesToUpgrade = [
  ...isEslintVersionValid ? [] : [ESLINT],
  ...isConfigVersionValid ? [] : [ESLINT_CONFIG]
];
function getActionMessage() {
  const actions = [];
  if (packagesToInstall.length > 0) {
    actions.push(`install ${packagesToInstall.map((pkg) => LINKS[pkg]).join(", ")}`);
  }
  if (packagesToUpgrade.length > 0) {
    const upgradeAction = `upgrade ${packagesToUpgrade.map((pkg) => LINKS[pkg]).join(", ")}`;
    if (packagesToInstall.length > 0) {
      actions.push(`and ${upgradeAction}`);
    } else {
      actions.push(upgradeAction);
    }
  }
  if (hasEslint || hasEslintConfig) {
    actions.push("(Currently:");
    if (hasEslint) {
      actions.push(`  ${ESLINT}: ${eslintVersion}`);
    }
    if (hasEslintConfig) {
      actions.push(`  ${ESLINT_CONFIG}: ${configVersion}`);
    }
    actions.push(")");
  }
  return `We need to ${actions.join(" ")}.`;
}
async function main() {
  intro(description);
  if (packagesToInstall.length > 0 || packagesToUpgrade.length > 0) {
    log.info(getActionMessage());
    const shouldInstall = await confirm({
      message: "Do you want to proceed?"
    });
    if (shouldInstall === true) {
      const s = spinner();
      s.start("Installing dependencies...");
      if (packagesToInstall.length > 0) {
        await addDevDependency(packagesToInstall, { silent: true });
      }
      if (packagesToUpgrade.length > 0) {
        const packageManager = await getPackageManager();
        const upgradeCommand = resolveCommand(packageManager.agent, "upgrade", packagesToUpgrade);
        await x(upgradeCommand.command, upgradeCommand.args.concat(["--silent"]));
      }
      s.stop("Dependencies installed!");
    }
  } else {
    log.info("All required dependencies are already installed.");
  }
  let overwriteConfig = false;
  overwriteConfig = await (configUrl ? confirm({
    message: `Found ${underline(relative(process.cwd(), configUrl))}. Do you want to overwrite it?`
  }) : confirm({
    message: "No ESLint config found. Do you want to create one?"
  }));
  if (overwriteConfig === true) {
    const s = spinner();
    s.start("Setting up ESLint config...");
    await writeFile(configUrl ?? "eslint.config.mjs", configData);
    s.stop("ESLint config setup complete!");
  }
  if (hasFile("package.json")) {
    const packageJson = JSON.parse(await readFile("package.json", "utf8"));
    if (!packageJson.scripts) {
      packageJson.scripts = {};
    }
    const hasLintAndFixScripts = packageJson.scripts.lint && packageJson.scripts["lint:fix"];
    const shouldAddScripts = hasLintAndFixScripts ? false : await confirm({
      message: "Do you want to add lint scripts to package.json?"
    });
    if (shouldAddScripts === true) {
      if (!packageJson.scripts.lint) {
        packageJson.scripts.lint = "eslint";
      }
      if (!packageJson.scripts["lint:fix"]) {
        packageJson.scripts["lint:fix"] = "eslint --fix";
      }
      await writeFile("package.json", JSON.stringify(packageJson, null, 2));
    }
  }
  outro("All done! Happy hacking!");
}

export { main };
