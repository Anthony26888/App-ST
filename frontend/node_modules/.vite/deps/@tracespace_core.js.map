{
  "version": 3,
  "sources": ["../../node_modules/.pnpm/moo@0.5.2/node_modules/moo/moo.js", "../../@tracespace/parser/src/lexer/tokens.ts", "../../@tracespace/parser/src/lexer/rules.ts", "../../@tracespace/parser/src/lexer/index.ts", "../../@tracespace/parser/src/constants.ts", "../../@tracespace/parser/src/syntax/rules.ts", "../../@tracespace/parser/src/tree.ts", "../../@tracespace/parser/src/syntax/map-tokens.ts", "../../@tracespace/parser/src/syntax/drill.ts", "../../@tracespace/parser/src/syntax/macro.ts", "../../@tracespace/parser/src/syntax/gerber.ts", "../../@tracespace/parser/src/syntax/index.ts", "../../@tracespace/parser/src/index.ts", "../../@tracespace/plotter/src/tree.ts", "../../@tracespace/plotter/src/coordinate-math.ts", "../../@tracespace/plotter/src/bounding-box.ts", "../../@tracespace/plotter/src/options.ts", "../../@tracespace/plotter/src/tool-store.ts", "../../@tracespace/plotter/src/location-store.ts", "../../@tracespace/plotter/src/graphic-plotter/shapes.ts", "../../@tracespace/plotter/src/graphic-plotter/plot-shape.ts", "../../@tracespace/plotter/src/graphic-plotter/plot-rect-path.ts", "../../@tracespace/plotter/src/graphic-plotter/plot-path.ts", "../../@tracespace/plotter/src/graphic-plotter/plot-macro.ts", "../../@tracespace/plotter/src/graphic-plotter/index.ts", "../../@tracespace/plotter/src/index.ts", "../../@tracespace/xml-id/src/index.ts", "../../node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/util/schema.js", "../../node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/util/merge.js", "../../node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/normalize.js", "../../node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/util/info.js", "../../node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/util/types.js", "../../node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/util/defined-info.js", "../../node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/util/create.js", "../../node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/xlink.js", "../../node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/xml.js", "../../node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/util/case-sensitive-transform.js", "../../node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/util/case-insensitive-transform.js", "../../node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/xmlns.js", "../../node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/aria.js", "../../node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/html.js", "../../node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/svg.js", "../../node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/find.js", "../../node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/index.js", "../../node_modules/.pnpm/hast-util-parse-selector@3.1.1/node_modules/hast-util-parse-selector/lib/index.js", "../../node_modules/.pnpm/space-separated-tokens@2.0.2/node_modules/space-separated-tokens/index.js", "../../node_modules/.pnpm/comma-separated-tokens@2.0.3/node_modules/comma-separated-tokens/index.js", "../../node_modules/.pnpm/hastscript@7.2.0/node_modules/hastscript/lib/core.js", "../../node_modules/.pnpm/hastscript@7.2.0/node_modules/hastscript/lib/svg-case-sensitive-tag-names.js", "../../node_modules/.pnpm/hastscript@7.2.0/node_modules/hastscript/lib/svg.js", "../../@tracespace/renderer/src/render.ts", "../../@tracespace/renderer/src/index.ts", "../../@tracespace/identify-layers/src/get-common-cad.ts", "../../@tracespace/identify-layers/src/constants.ts", "../../@tracespace/identify-layers/src/layer-types.ts", "../../@tracespace/identify-layers/src/matchers.ts", "../../@tracespace/identify-layers/src/get-matches.ts", "../../@tracespace/identify-layers/src/index.ts", "../../node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/util/schema.js", "../../node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/util/merge.js", "../../node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/normalize.js", "../../node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/util/info.js", "../../node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/util/types.js", "../../node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/util/defined-info.js", "../../node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/util/create.js", "../../node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/xlink.js", "../../node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/xml.js", "../../node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/util/case-sensitive-transform.js", "../../node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/util/case-insensitive-transform.js", "../../node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/xmlns.js", "../../node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/aria.js", "../../node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/html.js", "../../node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/svg.js", "../../node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/lib/find.js", "../../node_modules/.pnpm/property-information@6.2.0/node_modules/property-information/index.js", "../../node_modules/.pnpm/hast-util-parse-selector@3.1.1/node_modules/hast-util-parse-selector/lib/index.js", "../../node_modules/.pnpm/space-separated-tokens@2.0.2/node_modules/space-separated-tokens/index.js", "../../node_modules/.pnpm/comma-separated-tokens@2.0.3/node_modules/comma-separated-tokens/index.js", "../../node_modules/.pnpm/hastscript@7.2.0/node_modules/hastscript/lib/core.js", "../../node_modules/.pnpm/hastscript@7.2.0/node_modules/hastscript/lib/svg-case-sensitive-tag-names.js", "../../node_modules/.pnpm/hastscript@7.2.0/node_modules/hastscript/lib/svg.js", "../../@tracespace/core/src/read-file.ts", "../../@tracespace/core/src/determine-layer-types.ts", "../../@tracespace/core/src/sort-layers.ts", "../../@tracespace/core/src/board-shape/walk-paths.ts", "../../@tracespace/core/src/board-shape/fill-gaps.ts", "../../@tracespace/core/src/board-shape/index.ts", "../../node_modules/.pnpm/html-void-elements@2.0.1/node_modules/html-void-elements/index.js", "../../node_modules/.pnpm/zwitch@2.0.4/node_modules/zwitch/index.js", "../../node_modules/.pnpm/stringify-entities@4.0.3/node_modules/stringify-entities/lib/core.js", "../../node_modules/.pnpm/stringify-entities@4.0.3/node_modules/stringify-entities/lib/util/to-hexadecimal.js", "../../node_modules/.pnpm/stringify-entities@4.0.3/node_modules/stringify-entities/lib/util/to-decimal.js", "../../node_modules/.pnpm/character-entities-legacy@3.0.0/node_modules/character-entities-legacy/index.js", "../../node_modules/.pnpm/character-entities-html4@2.1.0/node_modules/character-entities-html4/index.js", "../../node_modules/.pnpm/stringify-entities@4.0.3/node_modules/stringify-entities/lib/constant/dangerous.js", "../../node_modules/.pnpm/stringify-entities@4.0.3/node_modules/stringify-entities/lib/util/to-named.js", "../../node_modules/.pnpm/stringify-entities@4.0.3/node_modules/stringify-entities/lib/util/format-smart.js", "../../node_modules/.pnpm/stringify-entities@4.0.3/node_modules/stringify-entities/lib/index.js", "../../node_modules/.pnpm/hast-util-to-html@8.0.4/node_modules/hast-util-to-html/lib/handle/comment.js", "../../node_modules/.pnpm/hast-util-to-html@8.0.4/node_modules/hast-util-to-html/lib/handle/doctype.js", "../../node_modules/.pnpm/ccount@2.0.1/node_modules/ccount/index.js", "../../node_modules/.pnpm/hast-util-whitespace@2.0.1/node_modules/hast-util-whitespace/index.js", "../../node_modules/.pnpm/hast-util-to-html@8.0.4/node_modules/hast-util-to-html/lib/omission/util/siblings.js", "../../node_modules/.pnpm/hast-util-to-html@8.0.4/node_modules/hast-util-to-html/lib/omission/omission.js", "../../node_modules/.pnpm/hast-util-to-html@8.0.4/node_modules/hast-util-to-html/lib/omission/closing.js", "../../node_modules/.pnpm/hast-util-to-html@8.0.4/node_modules/hast-util-to-html/lib/omission/opening.js", "../../node_modules/.pnpm/hast-util-to-html@8.0.4/node_modules/hast-util-to-html/lib/handle/element.js", "../../node_modules/.pnpm/hast-util-to-html@8.0.4/node_modules/hast-util-to-html/lib/handle/text.js", "../../node_modules/.pnpm/hast-util-to-html@8.0.4/node_modules/hast-util-to-html/lib/handle/raw.js", "../../node_modules/.pnpm/hast-util-to-html@8.0.4/node_modules/hast-util-to-html/lib/handle/root.js", "../../node_modules/.pnpm/hast-util-to-html@8.0.4/node_modules/hast-util-to-html/lib/handle/index.js", "../../node_modules/.pnpm/hast-util-to-html@8.0.4/node_modules/hast-util-to-html/lib/index.js", "../../@tracespace/core/src/stringify-svg.ts", "../../@tracespace/core/src/index.ts"],
  "sourcesContent": ["(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], factory) /* global define */\n  } else if (typeof module === 'object' && module.exports) {\n    module.exports = factory()\n  } else {\n    root.moo = factory()\n  }\n}(this, function() {\n  'use strict';\n\n  var hasOwnProperty = Object.prototype.hasOwnProperty\n  var toString = Object.prototype.toString\n  var hasSticky = typeof new RegExp().sticky === 'boolean'\n\n  /***************************************************************************/\n\n  function isRegExp(o) { return o && toString.call(o) === '[object RegExp]' }\n  function isObject(o) { return o && typeof o === 'object' && !isRegExp(o) && !Array.isArray(o) }\n\n  function reEscape(s) {\n    return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\n  }\n  function reGroups(s) {\n    var re = new RegExp('|' + s)\n    return re.exec('').length - 1\n  }\n  function reCapture(s) {\n    return '(' + s + ')'\n  }\n  function reUnion(regexps) {\n    if (!regexps.length) return '(?!)'\n    var source =  regexps.map(function(s) {\n      return \"(?:\" + s + \")\"\n    }).join('|')\n    return \"(?:\" + source + \")\"\n  }\n\n  function regexpOrLiteral(obj) {\n    if (typeof obj === 'string') {\n      return '(?:' + reEscape(obj) + ')'\n\n    } else if (isRegExp(obj)) {\n      // TODO: consider /u support\n      if (obj.ignoreCase) throw new Error('RegExp /i flag not allowed')\n      if (obj.global) throw new Error('RegExp /g flag is implied')\n      if (obj.sticky) throw new Error('RegExp /y flag is implied')\n      if (obj.multiline) throw new Error('RegExp /m flag is implied')\n      return obj.source\n\n    } else {\n      throw new Error('Not a pattern: ' + obj)\n    }\n  }\n\n  function pad(s, length) {\n    if (s.length > length) {\n      return s\n    }\n    return Array(length - s.length + 1).join(\" \") + s\n  }\n\n  function lastNLines(string, numLines) {\n    var position = string.length\n    var lineBreaks = 0;\n    while (true) {\n      var idx = string.lastIndexOf(\"\\n\", position - 1)\n      if (idx === -1) {\n        break;\n      } else {\n        lineBreaks++\n      }\n      position = idx\n      if (lineBreaks === numLines) {\n        break;\n      }\n      if (position === 0) {\n        break;\n      }\n    }\n    var startPosition = \n      lineBreaks < numLines ?\n      0 : \n      position + 1\n    return string.substring(startPosition).split(\"\\n\")\n  }\n\n  function objectToRules(object) {\n    var keys = Object.getOwnPropertyNames(object)\n    var result = []\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      var thing = object[key]\n      var rules = [].concat(thing)\n      if (key === 'include') {\n        for (var j = 0; j < rules.length; j++) {\n          result.push({include: rules[j]})\n        }\n        continue\n      }\n      var match = []\n      rules.forEach(function(rule) {\n        if (isObject(rule)) {\n          if (match.length) result.push(ruleOptions(key, match))\n          result.push(ruleOptions(key, rule))\n          match = []\n        } else {\n          match.push(rule)\n        }\n      })\n      if (match.length) result.push(ruleOptions(key, match))\n    }\n    return result\n  }\n\n  function arrayToRules(array) {\n    var result = []\n    for (var i = 0; i < array.length; i++) {\n      var obj = array[i]\n      if (obj.include) {\n        var include = [].concat(obj.include)\n        for (var j = 0; j < include.length; j++) {\n          result.push({include: include[j]})\n        }\n        continue\n      }\n      if (!obj.type) {\n        throw new Error('Rule has no type: ' + JSON.stringify(obj))\n      }\n      result.push(ruleOptions(obj.type, obj))\n    }\n    return result\n  }\n\n  function ruleOptions(type, obj) {\n    if (!isObject(obj)) {\n      obj = { match: obj }\n    }\n    if (obj.include) {\n      throw new Error('Matching rules cannot also include states')\n    }\n\n    // nb. error and fallback imply lineBreaks\n    var options = {\n      defaultType: type,\n      lineBreaks: !!obj.error || !!obj.fallback,\n      pop: false,\n      next: null,\n      push: null,\n      error: false,\n      fallback: false,\n      value: null,\n      type: null,\n      shouldThrow: false,\n    }\n\n    // Avoid Object.assign(), so we support IE9+\n    for (var key in obj) {\n      if (hasOwnProperty.call(obj, key)) {\n        options[key] = obj[key]\n      }\n    }\n\n    // type transform cannot be a string\n    if (typeof options.type === 'string' && type !== options.type) {\n      throw new Error(\"Type transform cannot be a string (type '\" + options.type + \"' for token '\" + type + \"')\")\n    }\n\n    // convert to array\n    var match = options.match\n    options.match = Array.isArray(match) ? match : match ? [match] : []\n    options.match.sort(function(a, b) {\n      return isRegExp(a) && isRegExp(b) ? 0\n           : isRegExp(b) ? -1 : isRegExp(a) ? +1 : b.length - a.length\n    })\n    return options\n  }\n\n  function toRules(spec) {\n    return Array.isArray(spec) ? arrayToRules(spec) : objectToRules(spec)\n  }\n\n  var defaultErrorRule = ruleOptions('error', {lineBreaks: true, shouldThrow: true})\n  function compileRules(rules, hasStates) {\n    var errorRule = null\n    var fast = Object.create(null)\n    var fastAllowed = true\n    var unicodeFlag = null\n    var groups = []\n    var parts = []\n\n    // If there is a fallback rule, then disable fast matching\n    for (var i = 0; i < rules.length; i++) {\n      if (rules[i].fallback) {\n        fastAllowed = false\n      }\n    }\n\n    for (var i = 0; i < rules.length; i++) {\n      var options = rules[i]\n\n      if (options.include) {\n        // all valid inclusions are removed by states() preprocessor\n        throw new Error('Inheritance is not allowed in stateless lexers')\n      }\n\n      if (options.error || options.fallback) {\n        // errorRule can only be set once\n        if (errorRule) {\n          if (!options.fallback === !errorRule.fallback) {\n            throw new Error(\"Multiple \" + (options.fallback ? \"fallback\" : \"error\") + \" rules not allowed (for token '\" + options.defaultType + \"')\")\n          } else {\n            throw new Error(\"fallback and error are mutually exclusive (for token '\" + options.defaultType + \"')\")\n          }\n        }\n        errorRule = options\n      }\n\n      var match = options.match.slice()\n      if (fastAllowed) {\n        while (match.length && typeof match[0] === 'string' && match[0].length === 1) {\n          var word = match.shift()\n          fast[word.charCodeAt(0)] = options\n        }\n      }\n\n      // Warn about inappropriate state-switching options\n      if (options.pop || options.push || options.next) {\n        if (!hasStates) {\n          throw new Error(\"State-switching options are not allowed in stateless lexers (for token '\" + options.defaultType + \"')\")\n        }\n        if (options.fallback) {\n          throw new Error(\"State-switching options are not allowed on fallback tokens (for token '\" + options.defaultType + \"')\")\n        }\n      }\n\n      // Only rules with a .match are included in the RegExp\n      if (match.length === 0) {\n        continue\n      }\n      fastAllowed = false\n\n      groups.push(options)\n\n      // Check unicode flag is used everywhere or nowhere\n      for (var j = 0; j < match.length; j++) {\n        var obj = match[j]\n        if (!isRegExp(obj)) {\n          continue\n        }\n\n        if (unicodeFlag === null) {\n          unicodeFlag = obj.unicode\n        } else if (unicodeFlag !== obj.unicode && options.fallback === false) {\n          throw new Error('If one rule is /u then all must be')\n        }\n      }\n\n      // convert to RegExp\n      var pat = reUnion(match.map(regexpOrLiteral))\n\n      // validate\n      var regexp = new RegExp(pat)\n      if (regexp.test(\"\")) {\n        throw new Error(\"RegExp matches empty string: \" + regexp)\n      }\n      var groupCount = reGroups(pat)\n      if (groupCount > 0) {\n        throw new Error(\"RegExp has capture groups: \" + regexp + \"\\nUse (?: … ) instead\")\n      }\n\n      // try and detect rules matching newlines\n      if (!options.lineBreaks && regexp.test('\\n')) {\n        throw new Error('Rule should declare lineBreaks: ' + regexp)\n      }\n\n      // store regex\n      parts.push(reCapture(pat))\n    }\n\n\n    // If there's no fallback rule, use the sticky flag so we only look for\n    // matches at the current index.\n    //\n    // If we don't support the sticky flag, then fake it using an irrefutable\n    // match (i.e. an empty pattern).\n    var fallbackRule = errorRule && errorRule.fallback\n    var flags = hasSticky && !fallbackRule ? 'ym' : 'gm'\n    var suffix = hasSticky || fallbackRule ? '' : '|'\n\n    if (unicodeFlag === true) flags += \"u\"\n    var combined = new RegExp(reUnion(parts) + suffix, flags)\n    return {regexp: combined, groups: groups, fast: fast, error: errorRule || defaultErrorRule}\n  }\n\n  function compile(rules) {\n    var result = compileRules(toRules(rules))\n    return new Lexer({start: result}, 'start')\n  }\n\n  function checkStateGroup(g, name, map) {\n    var state = g && (g.push || g.next)\n    if (state && !map[state]) {\n      throw new Error(\"Missing state '\" + state + \"' (in token '\" + g.defaultType + \"' of state '\" + name + \"')\")\n    }\n    if (g && g.pop && +g.pop !== 1) {\n      throw new Error(\"pop must be 1 (in token '\" + g.defaultType + \"' of state '\" + name + \"')\")\n    }\n  }\n  function compileStates(states, start) {\n    var all = states.$all ? toRules(states.$all) : []\n    delete states.$all\n\n    var keys = Object.getOwnPropertyNames(states)\n    if (!start) start = keys[0]\n\n    var ruleMap = Object.create(null)\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      ruleMap[key] = toRules(states[key]).concat(all)\n    }\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      var rules = ruleMap[key]\n      var included = Object.create(null)\n      for (var j = 0; j < rules.length; j++) {\n        var rule = rules[j]\n        if (!rule.include) continue\n        var splice = [j, 1]\n        if (rule.include !== key && !included[rule.include]) {\n          included[rule.include] = true\n          var newRules = ruleMap[rule.include]\n          if (!newRules) {\n            throw new Error(\"Cannot include nonexistent state '\" + rule.include + \"' (in state '\" + key + \"')\")\n          }\n          for (var k = 0; k < newRules.length; k++) {\n            var newRule = newRules[k]\n            if (rules.indexOf(newRule) !== -1) continue\n            splice.push(newRule)\n          }\n        }\n        rules.splice.apply(rules, splice)\n        j--\n      }\n    }\n\n    var map = Object.create(null)\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      map[key] = compileRules(ruleMap[key], true)\n    }\n\n    for (var i = 0; i < keys.length; i++) {\n      var name = keys[i]\n      var state = map[name]\n      var groups = state.groups\n      for (var j = 0; j < groups.length; j++) {\n        checkStateGroup(groups[j], name, map)\n      }\n      var fastKeys = Object.getOwnPropertyNames(state.fast)\n      for (var j = 0; j < fastKeys.length; j++) {\n        checkStateGroup(state.fast[fastKeys[j]], name, map)\n      }\n    }\n\n    return new Lexer(map, start)\n  }\n\n  function keywordTransform(map) {\n\n    // Use a JavaScript Map to map keywords to their corresponding token type\n    // unless Map is unsupported, then fall back to using an Object:\n    var isMap = typeof Map !== 'undefined'\n    var reverseMap = isMap ? new Map : Object.create(null)\n\n    var types = Object.getOwnPropertyNames(map)\n    for (var i = 0; i < types.length; i++) {\n      var tokenType = types[i]\n      var item = map[tokenType]\n      var keywordList = Array.isArray(item) ? item : [item]\n      keywordList.forEach(function(keyword) {\n        if (typeof keyword !== 'string') {\n          throw new Error(\"keyword must be string (in keyword '\" + tokenType + \"')\")\n        }\n        if (isMap) {\n          reverseMap.set(keyword, tokenType)\n        } else {\n          reverseMap[keyword] = tokenType\n        }\n      })\n    }\n    return function(k) {\n      return isMap ? reverseMap.get(k) : reverseMap[k]\n    }\n  }\n\n  /***************************************************************************/\n\n  var Lexer = function(states, state) {\n    this.startState = state\n    this.states = states\n    this.buffer = ''\n    this.stack = []\n    this.reset()\n  }\n\n  Lexer.prototype.reset = function(data, info) {\n    this.buffer = data || ''\n    this.index = 0\n    this.line = info ? info.line : 1\n    this.col = info ? info.col : 1\n    this.queuedToken = info ? info.queuedToken : null\n    this.queuedText = info ? info.queuedText: \"\";\n    this.queuedThrow = info ? info.queuedThrow : null\n    this.setState(info ? info.state : this.startState)\n    this.stack = info && info.stack ? info.stack.slice() : []\n    return this\n  }\n\n  Lexer.prototype.save = function() {\n    return {\n      line: this.line,\n      col: this.col,\n      state: this.state,\n      stack: this.stack.slice(),\n      queuedToken: this.queuedToken,\n      queuedText: this.queuedText,\n      queuedThrow: this.queuedThrow,\n    }\n  }\n\n  Lexer.prototype.setState = function(state) {\n    if (!state || this.state === state) return\n    this.state = state\n    var info = this.states[state]\n    this.groups = info.groups\n    this.error = info.error\n    this.re = info.regexp\n    this.fast = info.fast\n  }\n\n  Lexer.prototype.popState = function() {\n    this.setState(this.stack.pop())\n  }\n\n  Lexer.prototype.pushState = function(state) {\n    this.stack.push(this.state)\n    this.setState(state)\n  }\n\n  var eat = hasSticky ? function(re, buffer) { // assume re is /y\n    return re.exec(buffer)\n  } : function(re, buffer) { // assume re is /g\n    var match = re.exec(buffer)\n    // will always match, since we used the |(?:) trick\n    if (match[0].length === 0) {\n      return null\n    }\n    return match\n  }\n\n  Lexer.prototype._getGroup = function(match) {\n    var groupCount = this.groups.length\n    for (var i = 0; i < groupCount; i++) {\n      if (match[i + 1] !== undefined) {\n        return this.groups[i]\n      }\n    }\n    throw new Error('Cannot find token type for matched text')\n  }\n\n  function tokenToString() {\n    return this.value\n  }\n\n  Lexer.prototype.next = function() {\n    var index = this.index\n\n    // If a fallback token matched, we don't need to re-run the RegExp\n    if (this.queuedGroup) {\n      var token = this._token(this.queuedGroup, this.queuedText, index)\n      this.queuedGroup = null\n      this.queuedText = \"\"\n      return token\n    }\n\n    var buffer = this.buffer\n    if (index === buffer.length) {\n      return // EOF\n    }\n\n    // Fast matching for single characters\n    var group = this.fast[buffer.charCodeAt(index)]\n    if (group) {\n      return this._token(group, buffer.charAt(index), index)\n    }\n\n    // Execute RegExp\n    var re = this.re\n    re.lastIndex = index\n    var match = eat(re, buffer)\n\n    // Error tokens match the remaining buffer\n    var error = this.error\n    if (match == null) {\n      return this._token(error, buffer.slice(index, buffer.length), index)\n    }\n\n    var group = this._getGroup(match)\n    var text = match[0]\n\n    if (error.fallback && match.index !== index) {\n      this.queuedGroup = group\n      this.queuedText = text\n\n      // Fallback tokens contain the unmatched portion of the buffer\n      return this._token(error, buffer.slice(index, match.index), index)\n    }\n\n    return this._token(group, text, index)\n  }\n\n  Lexer.prototype._token = function(group, text, offset) {\n    // count line breaks\n    var lineBreaks = 0\n    if (group.lineBreaks) {\n      var matchNL = /\\n/g\n      var nl = 1\n      if (text === '\\n') {\n        lineBreaks = 1\n      } else {\n        while (matchNL.exec(text)) { lineBreaks++; nl = matchNL.lastIndex }\n      }\n    }\n\n    var token = {\n      type: (typeof group.type === 'function' && group.type(text)) || group.defaultType,\n      value: typeof group.value === 'function' ? group.value(text) : text,\n      text: text,\n      toString: tokenToString,\n      offset: offset,\n      lineBreaks: lineBreaks,\n      line: this.line,\n      col: this.col,\n    }\n    // nb. adding more props to token object will make V8 sad!\n\n    var size = text.length\n    this.index += size\n    this.line += lineBreaks\n    if (lineBreaks !== 0) {\n      this.col = size - nl + 1\n    } else {\n      this.col += size\n    }\n\n    // throw, if no rule with {error: true}\n    if (group.shouldThrow) {\n      var err = new Error(this.formatError(token, \"invalid syntax\"))\n      throw err;\n    }\n\n    if (group.pop) this.popState()\n    else if (group.push) this.pushState(group.push)\n    else if (group.next) this.setState(group.next)\n\n    return token\n  }\n\n  if (typeof Symbol !== 'undefined' && Symbol.iterator) {\n    var LexerIterator = function(lexer) {\n      this.lexer = lexer\n    }\n\n    LexerIterator.prototype.next = function() {\n      var token = this.lexer.next()\n      return {value: token, done: !token}\n    }\n\n    LexerIterator.prototype[Symbol.iterator] = function() {\n      return this\n    }\n\n    Lexer.prototype[Symbol.iterator] = function() {\n      return new LexerIterator(this)\n    }\n  }\n\n  Lexer.prototype.formatError = function(token, message) {\n    if (token == null) {\n      // An undefined token indicates EOF\n      var text = this.buffer.slice(this.index)\n      var token = {\n        text: text,\n        offset: this.index,\n        lineBreaks: text.indexOf('\\n') === -1 ? 0 : 1,\n        line: this.line,\n        col: this.col,\n      }\n    }\n    \n    var numLinesAround = 2\n    var firstDisplayedLine = Math.max(token.line - numLinesAround, 1)\n    var lastDisplayedLine = token.line + numLinesAround\n    var lastLineDigits = String(lastDisplayedLine).length\n    var displayedLines = lastNLines(\n        this.buffer, \n        (this.line - token.line) + numLinesAround + 1\n      )\n      .slice(0, 5)\n    var errorLines = []\n    errorLines.push(message + \" at line \" + token.line + \" col \" + token.col + \":\")\n    errorLines.push(\"\")\n    for (var i = 0; i < displayedLines.length; i++) {\n      var line = displayedLines[i]\n      var lineNo = firstDisplayedLine + i\n      errorLines.push(pad(String(lineNo), lastLineDigits) + \"  \" + line);\n      if (lineNo === token.line) {\n        errorLines.push(pad(\"\", lastLineDigits + token.col + 1) + \"^\")\n      }\n    }\n    return errorLines.join(\"\\n\")\n  }\n\n  Lexer.prototype.clone = function() {\n    return new Lexer(this.states, this.state)\n  }\n\n  Lexer.prototype.has = function(tokenType) {\n    return true\n  }\n\n\n  return {\n    compile: compile,\n    states: compileStates,\n    error: Object.freeze({error: true}),\n    fallback: Object.freeze({fallback: true}),\n    keywords: keywordTransform,\n  }\n\n}));\n", "import type {Token as MooToken} from 'moo'\n\n/**\n * T-code token type\n *\n * @category Lexer\n */\nexport const T_CODE = 'T_CODE'\n\n/**\n * G-code token type\n *\n * @category Lexer\n */\nexport const G_CODE = 'G_CODE'\n\n/**\n * M-code token type\n *\n * @category Lexer\n */\nexport const M_CODE = 'M_CODE'\n\n/**\n * D-code token type\n *\n * @category Lexer\n */\nexport const D_CODE = 'D_CODE'\n\n/**\n * Asterisk token type\n *\n * @category Lexer\n */\nexport const ASTERISK = 'ASTERISK'\n\n/**\n * Percent sign token type\n *\n * @category Lexer\n */\nexport const PERCENT = 'PERCENT'\n\n/**\n * Equals sign token type\n *\n * @category Lexer\n */\nexport const EQUALS = 'EQUALS'\n\n/**\n * Comma token type\n *\n * @category Lexer\n */\nexport const COMMA = 'COMMA'\n\n/**\n * Arithmatic operator token type\n *\n * @category Lexer\n */\nexport const OPERATOR = 'OPERATOR'\n\n/**\n * Gerber format specification token type\n *\n * @category Lexer\n */\nexport const GERBER_FORMAT = 'GERBER_FORMAT'\n\n/**\n * Gerber units specification token type\n *\n * @category Lexer\n */\nexport const GERBER_UNITS = 'GERBER_UNITS'\n\n/**\n * Gerber tool macro token type\n *\n * @category Lexer\n */\nexport const GERBER_TOOL_MACRO = 'GERBER_TOOL_MACRO'\n\n/**\n * Gerber tool definition token type\n *\n * @category Lexer\n */\nexport const GERBER_TOOL_DEF = 'GERBER_TOOL_DEF'\n\n/**\n * Gerber load polarity token type\n *\n * @category Lexer\n */\nexport const GERBER_LOAD_POLARITY = 'GERBER_LOAD_POLARITY'\n\n/**\n * Gerber step repear token type\n *\n * @category Lexer\n */\nexport const GERBER_STEP_REPEAT = 'GERBER_STEP_REPEAT'\n\n/**\n * Gerber macro variable token type\n *\n * @category Lexer\n */\nexport const GERBER_MACRO_VARIABLE = 'GERBER_MACRO_VARIABLE'\n\n/**\n * Semicolor token type\n *\n * @category Lexer\n */\nexport const SEMICOLON = 'SEMICOLON'\n\n/**\n * Drill file units token type\n *\n * @category Lexer\n */\nexport const DRILL_UNITS = 'DRILL_UNITS'\n\n/**\n * Drill zero-inclusion token type\n *\n * @category Lexer\n */\nexport const DRILL_ZERO_INCLUSION = 'DRILL_ZERO_INCLUSION'\n\n/**\n * Coordinate axis character token type\n *\n * @category Lexer\n */\nexport const COORD_CHAR = 'COORD_CHAR'\n\n/**\n * Number token type\n *\n * @category Lexer\n */\nexport const NUMBER = 'NUMBER'\n\n/**\n * Word token type\n *\n * @category Lexer\n */\nexport const WORD = 'WORD'\n\n/**\n * Whitespace token type\n *\n * @category Lexer\n */\nexport const WHITESPACE = 'WHITESPACE'\n\n/**\n * Newline token type\n *\n * @category Lexer\n */\nexport const NEWLINE = 'NEWLINE'\n\n/**\n * Catchall token type\n *\n * @category Lexer\n */\nexport const CATCHALL = 'CATCHALL'\n\n/**\n * Error token type\n *\n * @category Lexer\n */\nexport const ERROR = 'ERROR'\n\n/**\n * Union of all available token types\n *\n * @category Lexer\n */\nexport type TokenType =\n  | typeof T_CODE\n  | typeof G_CODE\n  | typeof M_CODE\n  | typeof D_CODE\n  | typeof ASTERISK\n  | typeof PERCENT\n  | typeof EQUALS\n  | typeof COMMA\n  | typeof OPERATOR\n  | typeof GERBER_FORMAT\n  | typeof GERBER_UNITS\n  | typeof GERBER_TOOL_MACRO\n  | typeof GERBER_TOOL_DEF\n  | typeof GERBER_LOAD_POLARITY\n  | typeof GERBER_STEP_REPEAT\n  | typeof GERBER_MACRO_VARIABLE\n  | typeof SEMICOLON\n  | typeof DRILL_UNITS\n  | typeof DRILL_ZERO_INCLUSION\n  | typeof COORD_CHAR\n  | typeof NUMBER\n  | typeof WORD\n  | typeof WHITESPACE\n  | typeof NEWLINE\n  | typeof CATCHALL\n  | typeof ERROR\n\n/**\n * {@linkcode Lexer} token\n *\n * @category Lexer\n */\nexport interface Token extends MooToken {\n  /** Token identifier */\n  type: TokenType\n}\n", "import Moo from 'moo'\nimport * as Tokens from './tokens'\n\nexport type Rules = {\n  [t in Tokens.TokenType]: RegExp | string | string[] | Moo.Rule | Moo.Rule[]\n}\n\nconst RE_STRIP_LEADING_ZEROS = /^0*/\n\nconst stripLeadingZeros = (text: string): string => {\n  return text.replace(RE_STRIP_LEADING_ZEROS, '')\n}\n\nconst getCodeValue = (text: string): string => {\n  return stripLeadingZeros(text.slice(1)) || '0'\n}\n\nexport const rules: Rules = {\n  [Tokens.T_CODE]: {\n    match: /T\\d+/,\n    value: getCodeValue,\n  },\n  [Tokens.G_CODE]: {\n    match: /G\\d+/,\n    value: getCodeValue,\n  },\n  [Tokens.M_CODE]: {\n    match: /M\\d+/,\n    value: getCodeValue,\n  },\n  [Tokens.D_CODE]: {\n    match: /D\\d+/,\n    value: getCodeValue,\n  },\n  [Tokens.ASTERISK]: '*',\n  [Tokens.PERCENT]: '%',\n  [Tokens.EQUALS]: '=',\n  [Tokens.GERBER_FORMAT]: {\n    match: /FS[LTDAI]+/,\n    value: (text: string): string => text.slice(2),\n  },\n  [Tokens.GERBER_UNITS]: {\n    match: /MO(?:IN|MM)/,\n    value: (text: string): string => text.slice(2),\n  },\n  [Tokens.GERBER_TOOL_MACRO]: {\n    // \"-\" in a tool name is illegal, but some gerber writers misbehave\n    // https://github.com/mcous/gerber-parser/pull/13\n    match: /AM[a-zA-Z_.$][\\w.-]*/,\n    value: (text: string): string => text.slice(2),\n  },\n  [Tokens.GERBER_TOOL_DEF]: {\n    match: /ADD\\d+[a-zA-Z_.$][\\w.-]*/,\n    value: (text: string): string => stripLeadingZeros(text.slice(3)),\n  },\n  [Tokens.GERBER_LOAD_POLARITY]: {\n    match: /LP[DC]/,\n    value: (text: string): string => text.slice(2),\n  },\n  [Tokens.GERBER_STEP_REPEAT]: 'SR',\n  [Tokens.GERBER_MACRO_VARIABLE]: /\\$\\d+/,\n  [Tokens.SEMICOLON]: ';',\n  [Tokens.DRILL_UNITS]: /^(?:METRIC|INCH)/,\n  [Tokens.DRILL_ZERO_INCLUSION]: {\n    match: /,(?:TZ|LZ)/,\n    value: (text: string): string => text.slice(1),\n  },\n  [Tokens.COORD_CHAR]: /[XYIJACFSBHZN]/,\n  [Tokens.NUMBER]: /[+-]?[\\d.]+/,\n  [Tokens.OPERATOR]: ['x', '/', '+', '-', '(', ')'],\n  [Tokens.COMMA]: ',',\n  [Tokens.WORD]: /[a-zA-Z]+/,\n  [Tokens.WHITESPACE]: /[ \\t]+/,\n  [Tokens.NEWLINE]: {\n    match: /\\r?\\n/,\n    lineBreaks: true,\n  },\n  [Tokens.CATCHALL]: /\\S/,\n  [Tokens.ERROR]: Moo.error,\n}\n", "// Gerber and drill file lexer + tokenizer\nimport Moo from 'moo'\nimport type {Token} from './tokens'\nimport {rules} from './rules'\n\nexport * from './tokens'\n\nexport interface LexerState extends Moo.LexerState {\n  offset: number\n}\n\nexport interface LexerIterable extends Iterable<[Token, LexerState]> {}\n\n/**\n * The lexing module of the parser.\n *\n * @category Lexer\n */\nexport interface Lexer {\n  feed(chunk: string, state?: LexerState | null): LexerIterable\n}\n\n/**\n * {@linkcode Lexer} factory\n *\n * @example\n * ```ts\n * import {createLexer} from '@tracespace/parser'\n *\n * const lexer = createLexer()\n * const tokens = lexer.feed('G04 gerber string*\\nM02*\\n')\n *\n * for (const token of tokens) {\n *   console.log(`${token.type}: ${token.value}`)\n * }\n * ```\n *\n * @category Lexer\n */\nexport function createLexer(): Lexer {\n  const mooLexer = Moo.compile(rules)\n\n  return {feed}\n\n  function feed(chunk: string, state: LexerState | null = null): LexerIterable {\n    mooLexer.reset(chunk, state ?? undefined)\n    return tokenIterator(state?.offset ?? 0)\n  }\n\n  function tokenIterator(\n    offset: number\n  ): LexerIterable & Iterator<[Token, LexerState]> {\n    return {\n      [Symbol.iterator]() {\n        return this\n      },\n\n      next() {\n        const token = mooLexer.next() as Token | undefined\n\n        if (token) {\n          const nextToken = {...token, offset: offset + token.offset}\n          const nextState = {\n            ...mooLexer.save(),\n            offset: offset + (mooLexer.index ?? 0),\n          }\n\n          return {value: [nextToken, nextState]}\n        }\n\n        return {value: undefined, done: true}\n      },\n    }\n  }\n}\n\ndeclare module 'moo' {\n  export interface Lexer {\n    index?: number\n  }\n}\n", "// Common constants\n\n// filetype constants\nexport const GERBER = 'gerber'\nexport const DRILL = 'drill'\n\n// Units constants\nexport const MM = 'mm'\nexport const IN = 'in'\n\n// Format constants\nexport const LEADING = 'leading'\nexport const TRAILING = 'trailing'\nexport const ABSOLUTE = 'absolute'\nexport const INCREMENTAL = 'incremental'\n\n// Tool constants\nexport const CIRCLE = 'circle'\nexport const RECTANGLE = 'rectangle'\nexport const OBROUND = 'obround'\nexport const POLYGON = 'polygon'\nexport const MACRO_SHAPE = 'macroShape'\n\n// Macro primitive codes\nexport const MACRO_CIRCLE = '1'\nexport const MACRO_VECTOR_LINE_DEPRECATED = '2'\nexport const MACRO_VECTOR_LINE = '20'\nexport const MACRO_CENTER_LINE = '21'\nexport const MACRO_LOWER_LEFT_LINE_DEPRECATED = '22'\nexport const MACRO_OUTLINE = '4'\nexport const MACRO_POLYGON = '5'\nexport const MACRO_MOIRE_DEPRECATED = '6'\nexport const MACRO_THERMAL = '7'\n\n// Drawing constants\nexport const SHAPE = 'shape'\nexport const MOVE = 'move'\nexport const SEGMENT = 'segment'\nexport const SLOT = 'slot'\n\n// Interpolation / routing constants\nexport const LINE = 'line'\nexport const CW_ARC = 'cwArc'\nexport const CCW_ARC = 'ccwArc'\n\n// Quadrant mode\nexport const SINGLE = 'single'\nexport const MULTI = 'multi'\n\n// Load polarity\nexport const DARK = 'dark'\nexport const CLEAR = 'clear'\n", "import type {Token} from '../lexer'\nimport type {Filetype} from '../types'\nimport type {GerberNode} from '../tree'\n\nexport const SINGLE_TOKEN = 'TOKEN'\nexport const MIN_TO_MAX = 'MIN_TO_MAX'\n\nexport interface SyntaxRule<Node = GerberNode> {\n  name: string\n  rules: TokenRule[]\n  createNodes: (tokens: Token[]) => Node[]\n  filetype?: Filetype\n}\n\nexport type TokenRule = SingleTokenRule | MinToMaxRule\n\nexport interface SingleTokenRule {\n  rule: typeof SINGLE_TOKEN\n  type: Token['type']\n  value: Token['value'] | RegExp | null | undefined\n  negate?: boolean\n}\n\nexport interface MinToMaxRule {\n  rule: typeof MIN_TO_MAX\n  min: number\n  max: number\n  match: SingleTokenRule[]\n}\n\nexport function token(\n  type: Token['type'],\n  value?: Token['value'] | RegExp\n): SingleTokenRule {\n  return {rule: SINGLE_TOKEN, type, value}\n}\n\nexport function notToken(\n  type: Token['type'],\n  value?: Token['value']\n): SingleTokenRule {\n  return {rule: SINGLE_TOKEN, type, value, negate: true}\n}\n\nexport function one(match: SingleTokenRule[]): MinToMaxRule {\n  return {rule: MIN_TO_MAX, min: 1, max: 1, match}\n}\n\nexport function zeroOrOne(match: SingleTokenRule[]): MinToMaxRule {\n  return {rule: MIN_TO_MAX, min: 0, max: 1, match}\n}\n\nexport function zeroOrMore(match: SingleTokenRule[]): MinToMaxRule {\n  return {rule: MIN_TO_MAX, min: 0, max: Number.POSITIVE_INFINITY, match}\n}\n\nexport function oneOrMore(match: SingleTokenRule[]): MinToMaxRule {\n  return {rule: MIN_TO_MAX, min: 1, max: Number.POSITIVE_INFINITY, match}\n}\n\nexport function minToMax(\n  min: number,\n  max: number,\n  match: SingleTokenRule[]\n): MinToMaxRule {\n  return {rule: MIN_TO_MAX, min, max, match}\n}\n\nexport interface MatchSearchResult<Node> {\n  filetype?: Filetype\n  nodes?: Node[]\n  tokens?: Token[]\n  candidates?: Array<SyntaxRule<Node>>\n}\n\nexport function findSyntaxMatch<Node>(\n  tokens: Token[],\n  candidates: Array<SyntaxRule<Node>>\n): MatchSearchResult<Node> {\n  const remainingCandidates: Array<SyntaxRule<Node>> = []\n\n  for (const candidate of candidates) {\n    const matchType = tokenListMatches(tokens, candidate.rules)\n\n    if (matchType === PARTIAL_MATCH) {\n      remainingCandidates.push(candidate)\n    } else if (matchType === FULL_MATCH) {\n      return {\n        filetype: candidate.filetype,\n        nodes: candidate.createNodes(tokens),\n      }\n    }\n  }\n\n  return remainingCandidates.length > 0\n    ? {candidates: remainingCandidates, tokens}\n    : {}\n}\n\nconst FULL_MATCH = 'FULL_MATCH'\nconst PARTIAL_MATCH = 'PARTIAL_MATCH'\nconst NO_MATCH = 'NO_MATCH'\n\ntype TokenMatchType = typeof FULL_MATCH | typeof PARTIAL_MATCH | typeof NO_MATCH\n\nfunction tokenListMatches(tokens: Token[], rules: TokenRule[]): TokenMatchType {\n  let i = 0\n  let j = 0\n  let multiMatchCount = 0\n\n  while (i < rules.length && j < tokens.length) {\n    const rule = rules[i]\n    const token = tokens[j]\n    const match = tokenMatches(rule, token)\n\n    if (match) {\n      if (\n        rule.rule === SINGLE_TOKEN ||\n        (rule.rule === MIN_TO_MAX && multiMatchCount >= rule.max - 1)\n      ) {\n        i++\n        j++\n        multiMatchCount = 0\n      } else if (rule.rule === MIN_TO_MAX) {\n        j++\n        multiMatchCount++\n      }\n    } else if (rule.rule === MIN_TO_MAX && multiMatchCount >= rule.min) {\n      multiMatchCount = 0\n      i++\n    } else {\n      return NO_MATCH\n    }\n  }\n\n  if (i < rules.length) return PARTIAL_MATCH\n  return FULL_MATCH\n}\n\nfunction tokenMatches(rule: TokenRule, token: Token): boolean {\n  if (rule.rule === SINGLE_TOKEN) {\n    const typeResult = rule.type === token.type\n    const valueResult =\n      rule.value === null ||\n      typeof rule.value === 'undefined' ||\n      (typeof rule.value === 'string' && rule.value === token.value) ||\n      (rule.value instanceof RegExp && rule.value.test(token.value))\n\n    const result = typeResult && valueResult\n\n    return rule.negate ? !result : result\n  }\n\n  if (Array.isArray(rule.match)) {\n    return rule.match.some(match => tokenMatches(match, token))\n  }\n\n  return false\n}\n", "import type {Position} from 'unist'\n\nimport type * as Types from './types'\n\n/**\n * {@linkcode Root} node type\n *\n * @category Node\n */\nexport const ROOT = 'root'\n\n/**\n * {@linkcode Comment} node type\n *\n * @category Node\n */\nexport const COMMENT = 'comment'\n\n/**\n * {@linkcode DrillHeader} node type\n *\n * @category Node\n */\nexport const DRILL_HEADER = 'drillHeader'\n\n/**\n * {@linkcode Done} node type\n *\n * @category Node\n */\nexport const DONE = 'done'\n\n/**\n * {@linkcode Units} node type\n *\n * @category Node\n */\nexport const UNITS = 'units'\n\n/**\n * {@linkcode CoordinateFormat} node type\n *\n * @category Node\n */\nexport const COORDINATE_FORMAT = 'coordinateFormat'\n\n/**\n * {@linkcode ToolDefinition} node type\n *\n * @category Node\n */\nexport const TOOL_DEFINITION = 'toolDefinition'\n\n/**\n * {@linkcode ToolMacro} node type\n *\n * @category Node\n */\nexport const TOOL_MACRO = 'toolMacro'\n\n/**\n * {@linkcode ToolChange} node type\n *\n * @category Node\n */\nexport const TOOL_CHANGE = 'toolChange'\n\n/**\n * {@linkcode LoadPolarity} node type\n *\n * @category Node\n */\nexport const LOAD_POLARITY = 'loadPolarity'\n\n/**\n * {@linkcode StepRepeat} node type\n *\n * @category Node\n */\nexport const STEP_REPEAT = 'stepRepeat'\n\n/**\n * {@linkcode Graphic} node type\n *\n * @category Node\n */\nexport const GRAPHIC = 'graphic'\n\n/**\n * {@linkcode InterpolateMode} node type\n *\n * @category Node\n */\nexport const INTERPOLATE_MODE = 'interpolateMode'\n\n/**\n * {@linkcode RegionMode} node type\n *\n * @category Node\n */\nexport const REGION_MODE = 'regionMode'\n\n/**\n * {@linkcode QuadrantMode} node type\n *\n * @category Node\n */\nexport const QUADRANT_MODE = 'quadrantMode'\n\n/**\n * {@linkcode Unimplemented} node type\n *\n * @category Node\n */\nexport const UNIMPLEMENTED = 'unimplemented'\n\n/**\n * {@linkcode MacroComment} node type\n *\n * @category Macro\n */\nexport const MACRO_COMMENT = 'macroComment'\n\n/**\n * {@linkcode MacroVariable} node type\n *\n * @category Macro\n */\nexport const MACRO_VARIABLE = 'macroVariable'\n\n/**\n * {@linkcode MacroPrimitive} node type\n *\n * @category Macro\n */\nexport const MACRO_PRIMITIVE = 'macroPrimitive'\n\ninterface BaseNode {\n  type: string\n  /** Location in the source file the node was parsed from */\n  position?: Position\n}\n\ninterface BaseParent extends BaseNode {\n  children: BaseNode[]\n}\n\n/**\n * Syntax tree node\n *\n * @category Node\n */\nexport type Node = Root | ChildNode\n\n/**\n * Child of the tree's {@linkcode Root} node\n *\n * @category Node\n */\nexport type ChildNode =\n  | Comment\n  | DrillHeader\n  | Done\n  | Units\n  | CoordinateFormat\n  | ToolDefinition\n  | ToolMacro\n  | ToolChange\n  | InterpolateMode\n  | RegionMode\n  | QuadrantMode\n  | LoadPolarity\n  | StepRepeat\n  | Graphic\n  | Unimplemented\n\n/**\n * Child of a {@linkcode ToolMacro} node\n *\n * @category Macro\n */\nexport type MacroBlock = MacroComment | MacroVariable | MacroPrimitive\n\n/**\n * Root node of the syntax tree, identifying the filetype and whether or not\n * the entire file seems to have been read. Filetype, if known, will be\n * either {@linkcode GERBER | gerber} or {@linkcode DRILL | drill}.\n *\n * If `filetype` is `null` or `done` is `false`, this may be a sign that\n *\n * 1. the parser has not finished parsing the file or\n * 2. the file is invalid and/or not a Gerber or drill file.\n *\n * @category Node\n */\nexport interface Root extends BaseParent {\n  /** Node type */\n  type: typeof ROOT\n  /** The parsed file's type (Gerber or NC drill), if known */\n  filetype: Types.Filetype\n\n  /** Parse results */\n  children: ChildNode[]\n}\n\n/**\n * Node representing a comment in the file. Usually, comment nodes can be\n * ignored, but in NC drill files, they may contain important format\n * specifications that are not able to be expressed in the file itself.\n *\n *  @category Node\n */\nexport interface Comment extends BaseNode {\n  /** Node type */\n  type: typeof COMMENT\n  /** Contents of the comment as a string */\n  comment: string\n}\n\n/**\n * Node representing drill file's header start or end.\n *\n *  @category Node\n */\nexport interface DrillHeader extends BaseNode {\n  /** Node type */\n  type: typeof DRILL_HEADER\n}\n\n/**\n * Node representing a done command. This represents an `M02` or `M00` command\n * in a Gerber file or an `M00` or `M30` in an NC drill file. Its presence in a\n * tree means the full source file was parsed.\n *\n * @category Node\n */\nexport interface Done extends BaseNode {\n  /** Node type */\n  type: typeof DONE\n}\n\n/**\n * A `Units` node specifies the units used for the file. Units may be\n * {@linkcode IN | in} or {@linkcode MM | mm}.\n *\n * @category Node\n */\nexport interface Units extends BaseNode {\n  /** Node type */\n  type: typeof UNITS\n  /** Inches or millimeters */\n  units: Types.UnitsType\n}\n\n/**\n * A `CoordinateFormat` node specifies the format of coordinate value strings.\n *\n * In Gerber and drill files, coordinates are (almost always) specified as\n * strings of digits without decimal points. `format` is a tuple where the\n * first element is the number of integer places in the string and the second\n * is the number of decimal places. Leading or trailing zeros may also be\n * omitted from the coordinate strings.\n *\n * For example, with `format` set to `[2, 4]`, some (intermediate) coordinate\n * strings could be:\n *\n * - `0.012` > `000120`\n * - `3.45` > `034500`\n * - `67` > `670000`\n *\n * With those same numbers, either {@linkcode LEADING | leading} or\n * {@linkcode TRAILING | trailing} zeros may be omitted depending on the\n * `zeroSuppression` setting:\n *\n * - `0.012` > `000120` > leading omitted: `120`, trailing omitted: `00012`\n * - `3.45` > `024500` > leading omitted: `24500`, trailing omitted: `0245`\n * - `67` > `670000` > leading omitted: `670000`, trailing omitted: `67`\n *\n * Some important things to keep in mind when processing coordinate strings\n * according to the `CoordinateFormat` node:\n *\n * - `format`, `zeroSuppression`, and/or `mode` could be left unspecified\n *     - In this case, `format` and `zeroSuppression` should be assumed or\n *       inferred, if possible\n *     - It's very safe to assume `mode` is always {@linkcode ABSOLUTE | absolute};\n *       {@linkcode INCREMENTAL | incremental} mode is deprecated and very rare\n * - Just because `zeroSuppression` is set doesn't mean zeros are dropped\n *     - It's common to see Gerber writers keep all zeros to ensure there is no\n *       ambiguity, but `zeroSuppression` still needs to be set to _something_\n * - A Gerber or NC drill file may choose to include decimal points! This is\n *   not necessarily \"in spec\", but it is unambiguous and easy to parse\n *\n * @category Node\n */\nexport interface CoordinateFormat extends BaseNode {\n  /** Node type */\n  type: typeof COORDINATE_FORMAT\n  /** Integer/decimal format setting, if known */\n  format: Types.Format | null\n  /** Zero suppression setting, if known */\n  zeroSuppression: Types.ZeroSuppression | null\n  /** Absolute or incremental coordinate system, if known */\n  mode: Types.Mode | null\n}\n\n/**\n * A `ToolDefinition` node defines a \"tool\" that may be used to either create a\n * shape (\"pad\" or \"drill hit\") or a stroke (\"trace\" or \"route\") in a later\n * graphic command.\n *\n * A tool shape may be one of:\n *\n * - {@linkcode Types.Circle} - A circle defined by a diameter\n * - {@linkcode Types.Rectangle} - A rectangle defined by sizes in the x and y axis\n * - {@linkcode Types.Obround} - A \"pill\" rectangle, with a border-radius equal to half of its shorter side\n * - {@linkcode Types.Polygon} - A regular polygon defined by its diameter, number of vertices, and rotation\n * - {@linkcode Types.MacroShape} - A shape defined by a previous {@linkcode ToolMacro}\n *\n * A tool may have a hole in its center; the `hole`, if not `null`, may be a:\n *\n * - {@linkcode Types.Circle}\n * - {@linkcode Types.Rectangle} (deprecated by the Gerber specification)\n *\n * Only `Circle` or `Rectangle` tools without a `hole` may create strokes.\n * `MacroShape` tools may not have a `hole` defined.\n *\n * @category Node\n */\nexport interface ToolDefinition extends BaseNode {\n  /** Node type */\n  type: typeof TOOL_DEFINITION\n  /** Unique tool identifier */\n  code: string\n  /** Tool shape */\n  shape: Types.ToolShape\n  /** Hole shape, if applicable */\n  hole: Types.HoleShape | null\n}\n\n/**\n * A `ToolMacro` node describes a complex shape in a Gerber file that can use a\n * variety of \"primitives\", simple arithmetic, and differing polarities to lay\n * out an image that will later be repeated.\n *\n * See the {@link https://www.ucamco.com/gerber | Gerber file specification}\n * for an in-depth description of how macros function.\n *\n * @category Node\n */\nexport interface ToolMacro extends BaseNode {\n  /** Node type */\n  type: typeof TOOL_MACRO\n  /** Unique macro identifier */\n  name: string\n  /** Macro definition blocks */\n  children: MacroBlock[]\n}\n\n/**\n * A `MacroComment` represents a comment in a macro and can be safely ignored\n *\n * @category Macro\n */\nexport interface MacroComment extends BaseNode {\n  /** Node type */\n  type: typeof MACRO_COMMENT\n  /** Comment string */\n  comment: string\n}\n\n/**\n * A `MacroVariable` node assigns a value to the `name` variable in a macro,\n * where that value may be a number or an arithmetic expression.\n *\n * @category Macro\n */\nexport interface MacroVariable extends BaseNode {\n  /** Node type */\n  type: typeof MACRO_VARIABLE\n  /** Variable name */\n  name: string\n  /** Concrete value or expression to assign to variable */\n  value: Types.MacroValue\n}\n\n/**\n * A `MacroPrimitive` node describes a shape to add to the overall macro shape.\n *\n * @category Macro\n */\nexport interface MacroPrimitive extends BaseNode {\n  /** Node type */\n  type: typeof MACRO_PRIMITIVE\n  /** Primitive shape type */\n  code: Types.MacroPrimitiveCode\n  /** Shape parameter values or expressions */\n  parameters: Types.MacroValue[]\n}\n\n/**\n * A `ToolChange` node sets the current active \"tool\". At a given point in the\n * file, the active tool determines the image that graphical operations produce.\n *\n * @category Node\n */\nexport interface ToolChange extends BaseNode {\n  /** Node type */\n  type: typeof TOOL_CHANGE\n  /** Tool identifier */\n  code: string\n}\n\n/**\n * A `LoadPolarity` node sets the current polarity to {@linkcode DARK | dark}\n * or {@linkcode CLEAR | clear}. Subsequent {@linkcode Graphic} operations\n * add to the overall image if the polarity is \"dark\", or remove from the image\n * if the polarity is \"clear\".\n *\n * @category Node\n */\nexport interface LoadPolarity extends BaseNode {\n  /** Node type */\n  type: typeof LOAD_POLARITY\n  /** Polarity */\n  polarity: Types.Polarity\n}\n\n/**\n * A `StepRepeat` node starts or ends a step repeat block.\n *\n * See the {@link https://www.ucamco.com/gerber | Gerber file specification}\n * for an in-depth description of step repeat blocks.\n *\n * @category Node\n */\nexport interface StepRepeat extends BaseNode {\n  /** Node type */\n  type: typeof STEP_REPEAT\n  /** Step repeat parameters */\n  stepRepeat: Types.StepRepeatParameters\n}\n\n/**\n * A `Graphic` node that represents an image being draw to the active layer.\n * The type of image \"drawn\" is dependent on the value of `graphic`:\n *\n * - {@linkcode SHAPE | shape} - the shape of the current tool is added to the\n *   image at `coordinates`\n * - {@linkcode MOVE | move} - the plotter is \"moved\" to `coordinates` **without\n *   drawing anything to the image**\n * - {@linkcode SEGMENT | segment} - the tool is \"stroked\" from the plotter's\n *   current location to `coordinates`\n *     - The path the tool takes is determined by the current {@linkcode InterpolateMode}\n *     - The segment may be a standalone path, or it may be a part of a region\n *       fill set by a {@linkcode RegionMode}\n *     - Only {@linkcode Circle} or {@linkcode Rectangle} tools may create\n *       standalone paths\n * - {@linkcode SLOT | slot} - a drill-file-specific graphic that creates a\n *   slot from `(coordinates.x1, coordinates.y1)` to `(coordinates.x2, coordinates.y2)`\n * - `null` - The graphic type was not explicitly specified in the source file\n *     - This is deprecated syntax in Gerber files, but if present the last\n *       used graphic type should be repeated\n *     - In a drill file, this means `shape` if in `drill` mode (default),\n *       `move` if in `move` mode, or `segment` if in a routing mode\n *\n * @category Node\n */\nexport interface Graphic extends BaseNode {\n  /** Node type */\n  type: typeof GRAPHIC\n  /** Graphical operation */\n  graphic: Types.GraphicType\n  /** Coordinates where the graphic will be applied */\n  coordinates: Types.Coordinates\n}\n\n/**\n * An `InterpolateMode` node is a command to define how subsequent `segment`\n * (or `null`, if you're processing a drill file) graphic nodes are rendered.\n * The `mode` may be one of:\n *\n * - {@linkcode LINE | line} - Draw a straight line segment\n * - {@linkcode CW_ARC | cwArc} - Draw a clockwise arc segment\n * - {@linkcode CCW_ARC | ccwArc} - Draw a counterclockwise arc segment\n * - {@linkcode MOVE | move } - (Drill file only) Move the current coordinate without drawing\n * - {@linkcode DRILL | drill} - (Drill file only) Draw a shape with the current tool\n *\n * @category Node\n */\nexport interface InterpolateMode extends BaseNode {\n  type: typeof INTERPOLATE_MODE\n  mode: Types.InterpolateModeType\n}\n\n/**\n * A `RegionMode` node is a command to treat subsequent graphics as part of a\n * region definition. Regions are typically used to describe things like\n * copper fills, and only occur in Gerber files. In region mode:\n *\n * - `segment` graphics define the edges of the region\n * - `move` graphics end the current region and start a new one\n * - Other graphics are disallowed\n *\n * @category Node\n */\nexport interface RegionMode extends BaseNode {\n  type: typeof REGION_MODE\n  region: boolean\n}\n\n/**\n * A `QuadrantMode` node determines how subsequent arc segments are drawn.\n *\n * See the {@link https://www.ucamco.com/gerber | Gerber file specification}\n * for an in-depth description of arc plotting.\n *\n * @category Node\n */\nexport interface QuadrantMode extends BaseNode {\n  type: typeof QUADRANT_MODE\n  quadrant: Types.QuadrantModeType\n}\n\n/**\n * An `Unimplemented` node is a chunk that the parser recognizes as part of a\n * Gerber file, but that it doesn't know how to process. These Nodes may be\n * implemented in a future minor release of the parser and should be used with\n * caution.\n *\n * Most unimplemented nodes will either be deprecated commands or valid\n * commands in the {@link https://www.ucamco.com/gerber | Gerber specification}\n * that we don't yet support.\n *\n * @category Node\n */\nexport interface Unimplemented extends BaseNode {\n  /** Node type */\n  type: typeof UNIMPLEMENTED\n  /** String value of chunk */\n  value: string\n}\n\nexport type GerberTree = Root\n\nexport type GerberNode = ChildNode\n", "import type {Position} from 'unist'\nimport type {Token} from '../lexer'\nimport {NUMBER, COORD_CHAR, G_CODE, D_CODE} from '../lexer'\nimport type {Coordinates, InterpolateModeType, GraphicType} from '../types'\nimport {SEGMENT, MOVE, SHAPE, LINE, CW_ARC, CCW_ARC, DRILL} from '../constants'\n\nexport function tokensToCoordinates(tokens: Token[]): Coordinates {\n  return Object.fromEntries(\n    tokens\n      .map((token, i) => [token, tokens[i - 1]])\n      .filter(([token, previousToken]) => {\n        return token.type === NUMBER && previousToken?.type === COORD_CHAR\n      })\n      .map(([token, previousToken]) => {\n        return [previousToken.value.toLowerCase(), token.value]\n      })\n  )\n}\n\nexport function tokensToMode(tokens: Token[]): InterpolateModeType {\n  const maybeMode = tokens\n    .filter(t => t.type === G_CODE)\n    .map(t => {\n      if (t.value === '0') return MOVE\n      if (t.value === '1') return LINE\n      if (t.value === '2') return CW_ARC\n      if (t.value === '3') return CCW_ARC\n      if (t.value === '5') return DRILL\n      return null\n    })\n\n  return maybeMode[0] ?? null\n}\n\nexport function tokensToGraphic(tokens: Token[]): GraphicType {\n  const maybeGraphic = tokens\n    .filter(t => t.type === D_CODE)\n    .map(t => {\n      if (t.value === '1') return SEGMENT\n      if (t.value === '2') return MOVE\n      if (t.value === '3') return SHAPE\n      return null\n    })\n\n  return maybeGraphic[0] ?? null\n}\n\nexport function tokensToString(tokens: Token[]): string {\n  return tokens\n    .map(t => t.value)\n    .join('')\n    .trim()\n}\n\nexport function tokensToPosition(\n  tokens: Token[],\n  options: Partial<{head: Token; length: number}> = {}\n): Position {\n  const {head = tokens[0], length = 0} = options\n  const tail =\n    length > 0\n      ? tokens[tokens.indexOf(head) + length - 1]\n      : tokens[tokens.length - 1]\n\n  return {\n    start: {line: head.line, column: head.col, offset: head.offset},\n    end: {line: tail.line, column: tail.col, offset: tail.offset},\n  }\n}\n", "// Drill file grammar\nimport * as Lexer from '../lexer'\nimport * as Tree from '../tree'\nimport * as Constants from '../constants'\nimport type * as Types from '../types'\nimport type {SyntaxRule} from './rules'\nimport {token, notToken, one, zeroOrOne, zeroOrMore, minToMax} from './rules'\n\nimport {\n  tokensToCoordinates,\n  tokensToMode,\n  tokensToString,\n  tokensToPosition,\n} from './map-tokens'\n\nconst units: SyntaxRule = {\n  name: 'units',\n  rules: [\n    one([\n      token(Lexer.DRILL_UNITS),\n      token(Lexer.M_CODE, '71'),\n      token(Lexer.M_CODE, '72'),\n    ]),\n    zeroOrMore([\n      token(Lexer.COMMA),\n      token(Lexer.DRILL_ZERO_INCLUSION),\n      token(Lexer.NUMBER, /^0{1,8}\\.0{1,8}$/),\n    ]),\n    token(Lexer.NEWLINE),\n  ],\n  createNodes(tokens) {\n    const units =\n      tokens[0].value === 'INCH' || tokens[0].value === '72'\n        ? Constants.IN\n        : Constants.MM\n\n    const zeroSuppression = tokens\n      .filter(t => t.type === Lexer.DRILL_ZERO_INCLUSION)\n      .map(t => {\n        if (t.value === 'LZ') return Constants.TRAILING\n        if (t.value === 'TZ') return Constants.LEADING\n        return null\n      })\n\n    const format = tokens\n      .filter(t => t.type === Lexer.NUMBER)\n      .map<Types.Format>(t => {\n        const [integer = '', decimal = ''] = t.value.split('.')\n        return [integer.length, decimal.length]\n      })\n\n    const nodes: Tree.ChildNode[] = [\n      {type: Tree.UNITS, position: tokensToPosition(tokens.slice(0, 2)), units},\n    ]\n\n    if (zeroSuppression.length > 0 || format.length > 0) {\n      nodes.push({\n        type: Tree.COORDINATE_FORMAT,\n        position: tokensToPosition(tokens.slice(1)),\n        mode: null,\n        format: format[0] ?? null,\n        zeroSuppression: zeroSuppression[0] ?? null,\n      })\n    }\n\n    return nodes\n  },\n}\n\nconst tool: SyntaxRule = {\n  name: 'tool',\n  rules: [\n    token(Lexer.T_CODE),\n    minToMax(0, 12, [\n      token(Lexer.COORD_CHAR, 'C'),\n      token(Lexer.COORD_CHAR, 'F'),\n      token(Lexer.COORD_CHAR, 'S'),\n      token(Lexer.COORD_CHAR, 'B'),\n      token(Lexer.COORD_CHAR, 'H'),\n      token(Lexer.COORD_CHAR, 'Z'),\n      token(Lexer.NUMBER),\n    ]),\n    token(Lexer.NEWLINE),\n  ],\n  createNodes(tokens) {\n    const code = tokens[0].value\n    const position = tokensToPosition(tokens)\n    const {c = null} = tokensToCoordinates(tokens.slice(1, -1))\n    const shape: Types.ToolShape | null =\n      c === null ? null : {type: Constants.CIRCLE, diameter: Number(c)}\n\n    return shape\n      ? [{type: Tree.TOOL_DEFINITION, hole: null, position, shape, code}]\n      : [{type: Tree.TOOL_CHANGE, position, code}]\n  },\n}\n\nconst mode: SyntaxRule = {\n  name: 'operationMode',\n  rules: [\n    one([\n      token(Lexer.G_CODE, '0'),\n      token(Lexer.G_CODE, '1'),\n      token(Lexer.G_CODE, '2'),\n      token(Lexer.G_CODE, '3'),\n      token(Lexer.G_CODE, '5'),\n    ]),\n    token(Lexer.NEWLINE),\n  ],\n  createNodes: tokens => [\n    {\n      type: Tree.INTERPOLATE_MODE,\n      position: tokensToPosition(tokens),\n      mode: tokensToMode(tokens),\n    },\n  ],\n}\n\nconst operation: SyntaxRule = {\n  name: 'operation',\n  rules: [\n    minToMax(0, 2, [\n      token(Lexer.T_CODE),\n      token(Lexer.G_CODE, '0'),\n      token(Lexer.G_CODE, '1'),\n      token(Lexer.G_CODE, '2'),\n      token(Lexer.G_CODE, '3'),\n      token(Lexer.G_CODE, '5'),\n    ]),\n    minToMax(2, 8, [token(Lexer.COORD_CHAR), token(Lexer.NUMBER)]),\n    zeroOrOne([token(Lexer.T_CODE)]),\n    token(Lexer.NEWLINE),\n  ],\n  createNodes(tokens) {\n    const graphicTokens = tokens.filter(\n      t => t.type === Lexer.COORD_CHAR || t.type === Lexer.NUMBER\n    )\n    const modeToken = tokens.find(t => t.type === Lexer.G_CODE)\n    const toolToken = tokens.find(t => t.type === Lexer.T_CODE)\n    const coordinates = tokensToCoordinates(graphicTokens)\n    const code = toolToken ? toolToken.value : null\n    const mode = tokensToMode(tokens)\n\n    const graphicPosition = tokensToPosition(tokens, {\n      head: graphicTokens[0],\n      length: graphicTokens.length + 1,\n    })\n    const modePosition = tokensToPosition(tokens, {head: modeToken, length: 2})\n    const toolPosition = tokensToPosition(tokens, {head: toolToken, length: 2})\n\n    const nodes: Tree.ChildNode[] = [\n      {\n        type: Tree.GRAPHIC,\n        position: graphicPosition,\n        graphic: null,\n        coordinates,\n      },\n    ]\n\n    if (mode) {\n      nodes.unshift({type: Tree.INTERPOLATE_MODE, position: modePosition, mode})\n    }\n\n    if (code) {\n      nodes.unshift({type: Tree.TOOL_CHANGE, position: toolPosition, code})\n    }\n\n    return nodes\n  },\n}\n\nconst slot: SyntaxRule = {\n  name: 'slot',\n  rules: [\n    minToMax(2, 4, [token(Lexer.COORD_CHAR), token(Lexer.NUMBER)]),\n    token(Lexer.G_CODE, '85'),\n    minToMax(2, 4, [token(Lexer.COORD_CHAR), token(Lexer.NUMBER)]),\n    token(Lexer.NEWLINE),\n  ],\n  createNodes(tokens) {\n    const gCode = tokens.find(t => t.type === Lexer.G_CODE)\n    const splitIdx = gCode ? tokens.indexOf(gCode) : -1\n    const start = Object.fromEntries(\n      Object.entries(tokensToCoordinates(tokens.slice(0, splitIdx))).map(\n        ([axis, value]) => [`${axis}0`, value]\n      )\n    )\n    const end = tokensToCoordinates(tokens.slice(splitIdx))\n\n    return [\n      {\n        type: Tree.GRAPHIC,\n        position: tokensToPosition(tokens),\n        graphic: Constants.SLOT,\n        coordinates: {...start, ...end},\n      },\n    ]\n  },\n}\n\nconst done: SyntaxRule = {\n  name: 'done',\n  rules: [\n    one([token(Lexer.M_CODE, '30'), token(Lexer.M_CODE, '0')]),\n    token(Lexer.NEWLINE),\n  ],\n  createNodes: tokens => [\n    {type: Tree.DONE, position: tokensToPosition(tokens)},\n  ],\n}\n\nconst header: SyntaxRule = {\n  name: 'header',\n  rules: [\n    one([token(Lexer.M_CODE, '48'), token(Lexer.PERCENT)]),\n    token(Lexer.NEWLINE),\n  ],\n  createNodes: tokens => [\n    {type: Tree.DRILL_HEADER, position: tokensToPosition(tokens)},\n  ],\n}\n\nconst comment: SyntaxRule = {\n  name: 'comment',\n  rules: [\n    token(Lexer.SEMICOLON),\n    zeroOrMore([notToken(Lexer.NEWLINE)]),\n    token(Lexer.NEWLINE),\n  ],\n  createNodes: tokens => [\n    {\n      type: Tree.COMMENT,\n      comment: tokensToString(tokens.slice(1, -1)),\n      position: tokensToPosition(tokens),\n    },\n  ],\n}\n\nexport const drillGrammar: SyntaxRule[] = [\n  tool,\n  mode,\n  operation,\n  slot,\n  comment,\n  units,\n  done,\n  header,\n].map(r => ({...r, filetype: Constants.DRILL}))\n", "// Gerber aperture macro syntax\nimport * as Lexer from '../lexer'\nimport * as Tree from '../tree'\nimport type {MacroValue, MacroPrimitiveCode} from '../types'\n\nimport {tokensToPosition} from './map-tokens'\nimport type {SyntaxRule} from './rules'\nimport {token, notToken, zeroOrMore, oneOrMore, findSyntaxMatch} from './rules'\n\nconst macroComment: SyntaxRule<Tree.MacroBlock> = {\n  name: 'macroComment',\n  rules: [\n    token(Lexer.NUMBER, '0'),\n    zeroOrMore([notToken(Lexer.ASTERISK)]),\n    token(Lexer.ASTERISK),\n  ],\n  createNodes: createMacroComment,\n}\n\nconst macroVariable: SyntaxRule<Tree.MacroBlock> = {\n  name: 'macroVariable',\n  rules: [\n    token(Lexer.GERBER_MACRO_VARIABLE),\n    token(Lexer.EQUALS),\n    oneOrMore([\n      token(Lexer.NUMBER),\n      token(Lexer.OPERATOR),\n      token(Lexer.GERBER_MACRO_VARIABLE),\n      token(Lexer.COORD_CHAR, 'X'),\n    ]),\n    token(Lexer.ASTERISK),\n  ],\n  createNodes: createMacroVariable,\n}\n\nconst macroPrimitive: SyntaxRule<Tree.MacroBlock> = {\n  name: 'macroPrimitive',\n  rules: [\n    token(Lexer.NUMBER),\n    token(Lexer.COMMA),\n    oneOrMore([\n      token(Lexer.COMMA),\n      token(Lexer.NUMBER),\n      token(Lexer.OPERATOR),\n      token(Lexer.GERBER_MACRO_VARIABLE),\n      token(Lexer.COORD_CHAR, 'X'),\n    ]),\n    token(Lexer.ASTERISK),\n  ],\n  createNodes: createMacroPrimitive,\n}\n\nfunction createMacroComment(tokens: Lexer.Token[]): Tree.MacroComment[] {\n  const comment = tokens\n    .slice(1, -1)\n    .map(t => t.text)\n    .join('')\n    .trim()\n\n  return [\n    {type: Tree.MACRO_COMMENT, position: tokensToPosition(tokens), comment},\n  ]\n}\n\nfunction createMacroPrimitive(tokens: Lexer.Token[]): Tree.MacroPrimitive[] {\n  const code = tokens[0].value as MacroPrimitiveCode\n  const commaDelimitedTokens: Lexer.Token[][] = [[]]\n  let currentGroup = commaDelimitedTokens[0]\n\n  for (const token of tokens.slice(2, -1)) {\n    if (token.type === Lexer.COMMA) {\n      currentGroup = []\n      commaDelimitedTokens.push(currentGroup)\n    } else {\n      currentGroup.push(token)\n    }\n  }\n\n  const parameters = commaDelimitedTokens.map(tokens =>\n    parseMacroExpression(tokens)\n  )\n\n  return [\n    {\n      type: Tree.MACRO_PRIMITIVE,\n      position: tokensToPosition(tokens),\n      code,\n      parameters,\n    },\n  ]\n}\n\nfunction createMacroVariable(tokens: Lexer.Token[]): Tree.MacroVariable[] {\n  const name = tokens[0].value\n  const value = parseMacroExpression(tokens.slice(2, -1))\n\n  return [\n    {\n      type: Tree.MACRO_VARIABLE,\n      position: tokensToPosition(tokens),\n      name,\n      value,\n    },\n  ]\n}\n\nfunction parseMacroExpression(tokens: Lexer.Token[]): MacroValue {\n  const toParse = tokens.map<Lexer.Token>(token => {\n    return token.type === Lexer.COORD_CHAR\n      ? {...token, type: Lexer.OPERATOR, value: 'x'}\n      : token\n  })\n\n  return parseAddition()\n\n  function peekNextToken(): Lexer.Token | null {\n    return toParse[0] ?? null\n  }\n\n  // Parse numbers, variables, and parenthesis\n  function parsePrimary(): MacroValue {\n    const token = toParse.shift()!\n\n    if (token.type === Lexer.NUMBER) return Number(token.value)\n    if (token.type === Lexer.GERBER_MACRO_VARIABLE) return token.value\n\n    // Else, we've got a parentheses group, so parse it and consume the \")\"\n    const expression = parseAddition()\n    toParse.shift()\n    return expression\n  }\n\n  // Parse multiplication and division operations\n  function parseMultiplication(): MacroValue {\n    let expression = parsePrimary()\n    let nextToken = peekNextToken()\n\n    while (\n      nextToken?.type === Lexer.OPERATOR &&\n      (nextToken.value === 'x' || nextToken.value === '/')\n    ) {\n      toParse.shift()\n      expression = {\n        left: expression,\n        right: parsePrimary(),\n        operator: nextToken.value,\n      }\n      nextToken = peekNextToken()\n    }\n\n    return expression\n  }\n\n  function parseAddition(): MacroValue {\n    let expression = parseMultiplication()\n    let nextToken = peekNextToken()\n\n    while (\n      (nextToken?.type === Lexer.OPERATOR &&\n        (nextToken.value === '+' || nextToken.value === '-')) ||\n      nextToken?.type === Lexer.NUMBER\n    ) {\n      let operator: '+' | '-' = '+'\n      if (nextToken.type === Lexer.OPERATOR) {\n        toParse.shift()\n        operator = nextToken.value as '+' | '-'\n      }\n\n      const right = parseMultiplication()\n      expression = {left: expression, right, operator}\n      nextToken = peekNextToken()\n    }\n\n    return expression\n  }\n}\n\nconst MACRO_GRAMMAR = [macroPrimitive, macroVariable, macroComment]\n\nexport function parseMacroBlocks(tokens: Lexer.Token[]): Tree.MacroBlock[] {\n  let matchedCandidates = MACRO_GRAMMAR\n  let matchedTokens: Lexer.Token[] = []\n  const blocks: Tree.MacroBlock[] = []\n\n  for (const token of tokens) {\n    const result = findSyntaxMatch([...matchedTokens, token], matchedCandidates)\n\n    if (result.nodes) blocks.push(...result.nodes)\n    matchedTokens = result.tokens ?? []\n    matchedCandidates = result.candidates ?? MACRO_GRAMMAR\n  }\n\n  return blocks\n}\n", "// Gerber file syntax\nimport * as Lexer from '../lexer'\nimport * as Constants from '../constants'\nimport type * as Types from '../types'\nimport * as Tree from '../tree'\nimport {parseMacroBlocks} from './macro'\nimport type {SyntaxRule} from './rules'\nimport {token, notToken, one, zeroOrMore, zeroOrOne, minToMax} from './rules'\n\nimport {\n  tokensToCoordinates,\n  tokensToMode,\n  tokensToGraphic,\n  tokensToString,\n  tokensToPosition,\n} from './map-tokens'\n\nconst holeShape = (parameters: number[]): Types.HoleShape | null => {\n  if (parameters.length === 1) {\n    const [diameter] = parameters\n    return {type: Constants.CIRCLE, diameter}\n  }\n\n  if (parameters.length === 2) {\n    const [xSize, ySize] = parameters\n    return {type: Constants.RECTANGLE, xSize, ySize}\n  }\n\n  return null\n}\n\nconst done: SyntaxRule = {\n  name: 'done',\n  rules: [\n    one([token(Lexer.M_CODE, '0'), token(Lexer.M_CODE, '2')]),\n    token(Lexer.ASTERISK),\n  ],\n  createNodes: tokens => [\n    {type: Tree.DONE, position: tokensToPosition(tokens)},\n  ],\n}\n\nconst comment: SyntaxRule = {\n  name: 'comment',\n  rules: [\n    token(Lexer.G_CODE, '4'),\n    zeroOrMore([notToken(Lexer.ASTERISK)]),\n    token(Lexer.ASTERISK),\n  ],\n  createNodes: tokens => [\n    {\n      type: Tree.COMMENT,\n      position: tokensToPosition(tokens),\n      comment: tokensToString(tokens.slice(1, -1)),\n    },\n  ],\n}\n\nconst format: SyntaxRule = {\n  name: 'format',\n  rules: [\n    token(Lexer.PERCENT),\n    token(Lexer.GERBER_FORMAT),\n    zeroOrMore([notToken(Lexer.COORD_CHAR, 'X')]),\n    token(Lexer.COORD_CHAR, 'X'),\n    token(Lexer.NUMBER),\n    token(Lexer.COORD_CHAR, 'Y'),\n    token(Lexer.NUMBER),\n    zeroOrMore([notToken(Lexer.ASTERISK)]),\n    token(Lexer.ASTERISK),\n    // Including units here is invalid syntax, but Cadence Allegro does it\n    // https://github.com/tracespace/tracespace/issues/234\n    minToMax(0, 2, [token(Lexer.GERBER_UNITS), token(Lexer.ASTERISK)]),\n    token(Lexer.PERCENT),\n  ],\n  createNodes(tokens) {\n    let format: Types.Format | null = null\n    let zeroSuppression: Types.ZeroSuppression | null = null\n    let mode: Types.Mode | null = null\n    const coords = tokensToCoordinates(tokens)\n    const formatEndIdx = tokens.findIndex(t => t.type === Lexer.ASTERISK)\n    const unitsToken = tokens.find(t => t.type === Lexer.GERBER_UNITS)\n\n    for (const t of tokens.filter(t => t.type === Lexer.GERBER_FORMAT)) {\n      if (t.value.includes('T')) zeroSuppression = Constants.TRAILING\n      if (t.value.includes('L')) zeroSuppression = Constants.LEADING\n      if (t.value.includes('I')) mode = Constants.INCREMENTAL\n      if (t.value.includes('A')) mode = Constants.ABSOLUTE\n    }\n\n    if (coords.x === coords.y && coords.x?.length === 2) {\n      const integers = Number(coords.x[0])\n      const decimals = Number(coords.x[1])\n      if (integers && decimals) format = [integers, decimals]\n    }\n\n    const nodes: Tree.ChildNode[] = [\n      {\n        type: Tree.COORDINATE_FORMAT,\n        position: tokensToPosition(tokens.slice(1, formatEndIdx + 1)),\n        zeroSuppression,\n        format,\n        mode,\n      },\n    ]\n\n    if (unitsToken) {\n      nodes.push({\n        type: Tree.UNITS,\n        position: tokensToPosition(tokens.slice(1, -1), {head: unitsToken}),\n        units: unitsToken.value === 'MM' ? Constants.MM : Constants.IN,\n      })\n    }\n\n    return nodes\n  },\n}\n\nconst units: SyntaxRule = {\n  name: 'units',\n  rules: [\n    token(Lexer.PERCENT),\n    token(Lexer.GERBER_UNITS),\n    token(Lexer.ASTERISK),\n    token(Lexer.PERCENT),\n  ],\n  createNodes: tokens => [\n    {\n      type: Tree.UNITS,\n      position: tokensToPosition(tokens.slice(1, -1)),\n      units: tokens[1].value === 'MM' ? Constants.MM : Constants.IN,\n    },\n  ],\n}\n\nconst toolMacro: SyntaxRule = {\n  name: 'toolMacro',\n  rules: [\n    token(Lexer.PERCENT),\n    token(Lexer.GERBER_TOOL_MACRO),\n    token(Lexer.ASTERISK),\n    zeroOrMore([notToken(Lexer.PERCENT)]),\n    token(Lexer.PERCENT),\n  ],\n  createNodes(tokens) {\n    const name = tokens[1].value\n    const position = tokensToPosition(tokens.slice(1, -1))\n    const blockTokens = tokens.slice(3, -1)\n\n    return [\n      {\n        type: Tree.TOOL_MACRO,\n        position,\n        children: parseMacroBlocks(blockTokens),\n        name,\n      },\n    ]\n  },\n}\n\nconst toolDefinition: SyntaxRule = {\n  name: 'toolDefinition',\n  rules: [\n    token(Lexer.PERCENT),\n    token(Lexer.GERBER_TOOL_DEF),\n    zeroOrMore([\n      token(Lexer.COMMA),\n      token(Lexer.NUMBER),\n      token(Lexer.COORD_CHAR, 'X'),\n    ]),\n    token(Lexer.ASTERISK),\n    token(Lexer.PERCENT),\n  ],\n  createNodes(tokens) {\n    let shape: Types.ToolShape\n    let hole: Types.HoleShape | null = null\n\n    const toolProps = /(\\d+)(.+)/.exec(tokens[1].value)\n    const [, code = '', name = ''] = toolProps ?? []\n    const parameters: number[] = tokens\n      .slice(3, -2)\n      .filter(t => t.type === Lexer.NUMBER)\n      .map(t => Number(t.value))\n\n    switch (name) {\n      case 'C': {\n        const [diameter, ...holeParameters] = parameters\n        shape = {type: Constants.CIRCLE, diameter}\n        hole = holeShape(holeParameters)\n        break\n      }\n\n      case 'R':\n      case 'O': {\n        const [xSize, ySize, ...holeParameters] = parameters\n        const type = name === 'R' ? Constants.RECTANGLE : Constants.OBROUND\n        shape = {type, xSize, ySize}\n        hole = holeShape(holeParameters)\n        break\n      }\n\n      case 'P': {\n        const [diameter, vertices, rotation = null, ...holeParameters] =\n          parameters\n        shape = {type: Constants.POLYGON, diameter, vertices, rotation}\n        hole = holeShape(holeParameters)\n        break\n      }\n\n      default: {\n        shape = {type: Constants.MACRO_SHAPE, name, variableValues: parameters}\n      }\n    }\n\n    return [\n      {\n        type: Tree.TOOL_DEFINITION,\n        position: tokensToPosition(tokens.slice(1, -1)),\n        code,\n        shape,\n        hole,\n      },\n    ]\n  },\n}\n\nconst toolChange: SyntaxRule = {\n  name: 'toolChange',\n  rules: [\n    zeroOrOne([token(Lexer.G_CODE, '54')]),\n    token(Lexer.D_CODE),\n    token(Lexer.ASTERISK),\n  ],\n  createNodes: tokens => [\n    {\n      type: Tree.TOOL_CHANGE,\n      position: tokensToPosition(tokens),\n      code: tokens.find(t => t.type === Lexer.D_CODE)!.value,\n    },\n  ],\n}\n\nconst createOperationNodes = (tokens: Lexer.Token[]): Tree.ChildNode[] => {\n  const graphic = tokensToGraphic(tokens)\n  const coordinates = tokensToCoordinates(tokens)\n  const mode = tokensToMode(tokens)\n  const position = tokensToPosition(tokens, {\n    head: mode ? tokens[1] : tokens[0],\n  })\n  const nodes: Tree.ChildNode[] = [\n    {type: Tree.GRAPHIC, position, graphic, coordinates},\n  ]\n  if (mode) {\n    const modePosition = tokensToPosition(tokens, {head: tokens[0], length: 2})\n    nodes.unshift({type: Tree.INTERPOLATE_MODE, position: modePosition, mode})\n  }\n\n  return nodes\n}\n\nconst operation: SyntaxRule = {\n  name: 'operation',\n  rules: [\n    zeroOrOne([\n      token(Lexer.G_CODE, '1'),\n      token(Lexer.G_CODE, '2'),\n      token(Lexer.G_CODE, '3'),\n    ]),\n    minToMax(2, 8, [token(Lexer.COORD_CHAR), token(Lexer.NUMBER)]),\n    zeroOrOne([\n      token(Lexer.D_CODE, '1'),\n      token(Lexer.D_CODE, '2'),\n      token(Lexer.D_CODE, '3'),\n    ]),\n    token(Lexer.ASTERISK),\n  ],\n  createNodes: createOperationNodes,\n}\n\nconst operationWithoutCoords: SyntaxRule = {\n  name: 'operationWithoutCoords',\n  rules: [\n    zeroOrOne([\n      token(Lexer.G_CODE, '1'),\n      token(Lexer.G_CODE, '2'),\n      token(Lexer.G_CODE, '3'),\n    ]),\n    one([\n      token(Lexer.D_CODE, '1'),\n      token(Lexer.D_CODE, '2'),\n      token(Lexer.D_CODE, '3'),\n    ]),\n    token(Lexer.ASTERISK),\n  ],\n  createNodes: createOperationNodes,\n}\n\nconst interpolationMode: SyntaxRule = {\n  name: 'interpolationMode',\n  rules: [\n    one([\n      token(Lexer.G_CODE, '1'),\n      token(Lexer.G_CODE, '2'),\n      token(Lexer.G_CODE, '3'),\n    ]),\n    token(Lexer.ASTERISK),\n  ],\n  createNodes: tokens => [\n    {\n      type: Tree.INTERPOLATE_MODE,\n      position: tokensToPosition(tokens),\n      mode: tokensToMode(tokens),\n    },\n  ],\n}\n\nconst regionMode: SyntaxRule = {\n  name: 'regionMode',\n  rules: [\n    one([token(Lexer.G_CODE, '36'), token(Lexer.G_CODE, '37')]),\n    token(Lexer.ASTERISK),\n  ],\n  createNodes: tokens => [\n    {\n      type: Tree.REGION_MODE,\n      position: tokensToPosition(tokens),\n      region: tokens[0].value === '36',\n    },\n  ],\n}\n\nconst quadrantMode: SyntaxRule = {\n  name: 'quadrantMode',\n  rules: [\n    one([token(Lexer.G_CODE, '74'), token(Lexer.G_CODE, '75')]),\n    token(Lexer.ASTERISK),\n  ],\n  createNodes: tokens => [\n    {\n      type: Tree.QUADRANT_MODE,\n      position: tokensToPosition(tokens),\n      quadrant: tokens[0].value === '74' ? Constants.SINGLE : Constants.MULTI,\n    },\n  ],\n}\n\nconst loadPolarity: SyntaxRule = {\n  name: 'loadPolarity',\n  rules: [\n    token(Lexer.PERCENT),\n    token(Lexer.GERBER_LOAD_POLARITY),\n    token(Lexer.ASTERISK),\n    token(Lexer.PERCENT),\n  ],\n  createNodes: tokens => [\n    {\n      type: Tree.LOAD_POLARITY,\n      position: tokensToPosition(tokens.slice(1, -1)),\n      polarity: tokens[1].value === 'D' ? Constants.DARK : Constants.CLEAR,\n    },\n  ],\n}\n\nconst stepRepeat: SyntaxRule = {\n  name: 'stepRepeat',\n  rules: [\n    token(Lexer.PERCENT),\n    token(Lexer.GERBER_STEP_REPEAT),\n    zeroOrMore([token(Lexer.COORD_CHAR), token(Lexer.NUMBER)]),\n    token(Lexer.ASTERISK),\n    token(Lexer.PERCENT),\n  ],\n  createNodes(tokens) {\n    const coordinates = tokensToCoordinates(tokens)\n    const parameters = Object.fromEntries(\n      Object.entries(coordinates).map(([axis, coordinateString]) => [\n        axis,\n        Number(coordinateString),\n      ])\n    )\n\n    return [\n      {\n        type: Tree.STEP_REPEAT,\n        position: tokensToPosition(tokens.slice(1, -1)),\n        stepRepeat: parameters,\n      },\n    ]\n  },\n}\n\nconst unimplementedExtendedCommand: SyntaxRule = {\n  name: 'unimplementedExtendedCommand',\n  rules: [\n    token(Lexer.PERCENT),\n    zeroOrMore([notToken(Lexer.ASTERISK)]),\n    token(Lexer.ASTERISK),\n    token(Lexer.PERCENT),\n  ],\n  createNodes: tokens => [\n    {\n      type: Tree.UNIMPLEMENTED,\n      position: tokensToPosition(tokens.slice(1, -1)),\n      value: tokensToString(tokens),\n    },\n  ],\n}\n\nexport const gerberGrammar: SyntaxRule[] = [\n  operation,\n  operationWithoutCoords,\n  interpolationMode,\n  toolChange,\n  toolDefinition,\n  toolMacro,\n  comment,\n  regionMode,\n  quadrantMode,\n  loadPolarity,\n  stepRepeat,\n  format,\n  units,\n  done,\n  unimplementedExtendedCommand,\n].map(r => ({...r, filetype: Constants.GERBER}))\n", "import type {Filetype} from '../types'\nimport type {GerberNode} from '../tree'\nimport type {Token, LexerIterable, LexerState} from '../lexer'\nimport {GERBER, DRILL} from '../constants'\nimport type {SyntaxRule} from './rules'\nimport {findSyntaxMatch} from './rules'\nimport {drillGrammar} from './drill'\nimport {gerberGrammar} from './gerber'\n\nconst grammar: SyntaxRule[] = [...gerberGrammar, ...drillGrammar]\n\nexport interface MatchResult {\n  filetype: Filetype | null\n  nodes: GerberNode[]\n  unmatched: string\n  lexerState: LexerState | null\n}\n\nexport function matchSyntax(\n  tokens: LexerIterable,\n  filetype: Filetype | null = null\n): MatchResult {\n  const nodes: GerberNode[] = []\n  let matchedCandidates = getGrammar()\n  let matchedTokens: Token[] = []\n  let nextLexerState: LexerState | null = null\n  let unmatched = ''\n\n  for (const [token, lexerState] of tokens) {\n    const result = findSyntaxMatch([...matchedTokens, token], matchedCandidates)\n\n    if (result.nodes) {\n      nodes.push(...result.nodes)\n      nextLexerState = lexerState\n      unmatched = ''\n    } else {\n      unmatched += token.text\n    }\n\n    filetype = filetype ?? result.filetype ?? null\n    matchedTokens = result.tokens ?? []\n    matchedCandidates = result.candidates ?? getGrammar()\n  }\n\n  return {\n    filetype,\n    unmatched,\n    nodes,\n    lexerState: nextLexerState,\n  }\n\n  function getGrammar() {\n    if (filetype === GERBER) return gerberGrammar\n    if (filetype === DRILL) return drillGrammar\n    return grammar\n  }\n}\n", "import type {Lexer, LexerState} from './lexer'\nimport {createLexer} from './lexer'\nimport {matchSyntax} from './syntax'\nimport type {GerberTree, GerberNode} from './tree'\nimport {ROOT} from './tree'\nimport type {Filetype} from './types'\n\nexport * from './constants'\nexport * from './lexer'\nexport * from './tree'\nexport * from './types'\n\n/**\n * Gerber and NC drill file parser.\n *\n * @category Parser\n */\nexport interface Parser {\n  /** Parser's {@linkcode Lexer} instance */\n  lexer: Lexer\n  /** Feed the parser with all or part of the source file */\n  feed(chunk: string): this\n  /** Get the resulting AST when you are done feeding the parser */\n  result(): GerberTree\n}\n\n/**\n * {@linkcode Parser} factory and the primary export of the library.\n *\n * @example\n * ```ts\n * import {createParser} from '@tracespace/parser'\n *\n * // create a parser to parse a single file\n * const parser = createParser()\n *\n * // feed the parser the source file contents\n * parser.feed('G04 gerber file contents*\\nM02*\\n')\n *\n * // get the resulting AST\n * const tree = parser.results()\n * ```\n *\n * @category Parser\n */\nexport function createParser(): Parser {\n  const lexer = createLexer()\n  const children: GerberNode[] = []\n  let filetype: Filetype | null = null\n  let lexerState: LexerState | null = null\n  let unmatched = ''\n\n  const parser = {lexer, feed, result}\n  return parser\n\n  function feed(chunk: string): Parser {\n    const tokens = lexer.feed(`${unmatched}${chunk}`, lexerState)\n    const result = matchSyntax(tokens, filetype)\n\n    filetype = filetype ?? result.filetype\n    unmatched = result.unmatched\n    lexerState = result.lexerState ?? lexerState\n    children.push(...result.nodes)\n\n    return parser\n  }\n\n  function result(): GerberTree {\n    if (filetype === null) {\n      throw new Error('File type not recognized')\n    }\n\n    return {type: ROOT, filetype, children}\n  }\n}\n\nexport function parse(contents: string): GerberTree {\n  return createParser().feed(contents).result()\n}\n", "import type {Node, Parent} from 'unist'\n\nimport type {UnitsType} from '@tracespace/parser'\n\nexport const IMAGE = 'image'\nexport const IMAGE_SHAPE = 'imageShape'\nexport const IMAGE_PATH = 'imagePath'\nexport const IMAGE_REGION = 'imageRegion'\n\nexport const LINE = 'line'\nexport const ARC = 'arc'\n\nexport const CIRCLE = 'circle'\nexport const RECTANGLE = 'rectangle'\nexport const POLYGON = 'polygon'\nexport const OUTLINE = 'outline'\nexport const LAYERED_SHAPE = 'layeredShape'\n\nexport type Position = [x: number, y: number]\n\nexport type ArcPosition = [x: number, y: number, theta: number]\n\nexport type SizeEnvelope = [x1: number, y1: number, x2: number, y2: number] | []\n\nexport type ImageNode = ImageTree | ImageShape | ImagePath | ImageRegion\n\nexport interface CircleShape {\n  type: typeof CIRCLE\n  cx: number\n  cy: number\n  r: number\n}\n\nexport interface RectangleShape {\n  type: typeof RECTANGLE\n  x: number\n  y: number\n  xSize: number\n  ySize: number\n  r?: number\n}\n\nexport interface PolygonShape {\n  type: typeof POLYGON\n  points: Position[]\n}\n\nexport interface OutlineShape {\n  type: typeof OUTLINE\n  segments: PathSegment[]\n}\n\nexport interface LayeredShape {\n  type: typeof LAYERED_SHAPE\n  shapes: ErasableShape[]\n}\n\nexport type HoleShape = CircleShape | RectangleShape\n\nexport type SimpleShape =\n  | CircleShape\n  | RectangleShape\n  | PolygonShape\n  | OutlineShape\n\nexport type Shape = SimpleShape | LayeredShape\n\nexport type ErasableShape = SimpleShape & {erase?: boolean}\n\nexport type ImageGraphic = ImageShape | ImagePath | ImageRegion\n\nexport interface ImageTree extends Parent {\n  type: typeof IMAGE\n  units: UnitsType\n  size: SizeEnvelope\n  children: ImageGraphic[]\n}\n\nexport interface ImageShape extends Node {\n  type: typeof IMAGE_SHAPE\n  shape: Shape\n}\n\nexport interface ImagePath extends Node {\n  type: typeof IMAGE_PATH\n  width: number\n  segments: PathSegment[]\n}\n\nexport interface ImageRegion extends Node {\n  type: typeof IMAGE_REGION\n  segments: PathSegment[]\n}\n\nexport type PathSegment = PathLineSegment | PathArcSegment\n\nexport interface PathLineSegment {\n  type: typeof LINE\n  start: Position\n  end: Position\n}\n\nexport interface PathArcSegment {\n  type: typeof ARC\n  start: ArcPosition\n  end: ArcPosition\n  center: Position\n  radius: number\n}\n", "// Mathematical procedures\nimport type {Position} from './tree'\n\nexport const {PI} = Math\nexport const HALF_PI = PI / 2\nexport const THREE_HALF_PI = 3 * HALF_PI\nexport const TWO_PI = 2 * PI\n\nexport function limitAngle(theta: number): number {\n  if (theta >= 0 && theta <= TWO_PI) return theta\n  if (theta < 0) return theta + TWO_PI\n  if (theta > TWO_PI) return theta - TWO_PI\n  return limitAngle(theta)\n}\n\nexport function rotateQuadrant(theta: number): number {\n  return theta >= HALF_PI ? theta - HALF_PI : theta + THREE_HALF_PI\n}\n\nexport function degreesToRadians(degrees: number): number {\n  return (degrees * Math.PI) / 180\n}\n\nexport function rotateAndShift(\n  point: Position,\n  shift: Position,\n  degrees = 0\n): Position {\n  const rotation = degreesToRadians(degrees)\n  const [sin, cos] = [Math.sin(rotation), Math.cos(rotation)]\n  const [x, y] = point\n  const nextX = x * cos - y * sin + shift[0]\n  const nextY = x * sin + y * cos + shift[1]\n\n  return [nextX, nextY]\n}\n\nexport function positionsEqual(a: number[], b: number[]): boolean {\n  return a[0] === b[0] && a[1] === b[1]\n}\n", "import * as Tree from './tree'\nimport {TWO_PI, limitAngle, rotateQuadrant} from './coordinate-math'\nimport type {SizeEnvelope as Box, Position, ArcPosition} from './tree'\n\nexport type {SizeEnvelope as Box} from './tree'\n\nexport function isEmpty(box: Box): box is [] {\n  return box.length === 0\n}\n\nexport function empty(): Box {\n  return []\n}\n\nexport function add(a: Box, b: Box): Box {\n  if (isEmpty(a)) return b\n  if (isEmpty(b)) return a\n\n  return [\n    Math.min(a[0], b[0]),\n    Math.min(a[1], b[1]),\n    Math.max(a[2], b[2]),\n    Math.max(a[3], b[3]),\n  ]\n}\n\nexport function sum(boxes: Box[]): Box {\n  return boxes.reduce(add, empty())\n}\n\nexport function fromGraphics(graphics: Tree.ImageGraphic[]): Box {\n  return sum(graphics.map(fromGraphic))\n}\n\nexport function fromGraphic(graphic: Tree.ImageGraphic): Box {\n  return graphic.type === Tree.IMAGE_SHAPE\n    ? fromShape(graphic.shape)\n    : fromPath(\n        graphic.segments,\n        graphic.type === Tree.IMAGE_PATH ? graphic.width : undefined\n      )\n}\n\nexport function fromShape(shape: Tree.Shape): Box {\n  switch (shape.type) {\n    case Tree.CIRCLE: {\n      const {cx, cy, r} = shape\n      return fromPosition([cx, cy], r)\n    }\n\n    case Tree.RECTANGLE: {\n      const {x, y, xSize, ySize} = shape\n      return [x, y, x + xSize, y + ySize]\n    }\n\n    case Tree.POLYGON: {\n      return sum(shape.points.map(p => fromPosition(p)))\n    }\n\n    case Tree.OUTLINE: {\n      return fromPath(shape.segments)\n    }\n\n    case Tree.LAYERED_SHAPE: {\n      return sum(shape.shapes.filter(({erase}) => !erase).map(fromShape))\n    }\n  }\n}\n\nexport function fromPath(segments: Tree.PathSegment[], width = 0): Box {\n  const rTool = width / 2\n  const keyPoints: Array<Tree.Position | Tree.ArcPosition> = []\n\n  for (const segment of segments) {\n    keyPoints.push(segment.start, segment.end)\n\n    if (segment.type === Tree.ARC) {\n      const {start, end, center, radius} = segment\n      const sweep = Math.abs(end[2] - start[2])\n\n      // Normalize direction to counter-clockwise\n      let [thetaStart, thetaEnd] =\n        end[2] > start[2] ? [start[2], end[2]] : [end[2], start[2]]\n\n      thetaStart = limitAngle(thetaStart)\n      thetaEnd = limitAngle(thetaEnd)\n\n      const axisPoints: Tree.Position[] = [\n        [center[0] + radius, center[1]],\n        [center[0], center[1] + radius],\n        [center[0] - radius, center[1]],\n        [center[0], center[1] - radius],\n      ]\n\n      for (const p of axisPoints) {\n        if (thetaStart > thetaEnd || sweep === TWO_PI) {\n          keyPoints.push(p)\n        }\n\n        // Rotate to check for next axis key point\n        thetaStart = rotateQuadrant(thetaStart)\n        thetaEnd = rotateQuadrant(thetaEnd)\n      }\n    }\n  }\n\n  return sum(keyPoints.map(p => fromPosition(p, rTool)))\n}\n\nfunction fromPosition(position: Position | ArcPosition, radius = 0): Box {\n  return [\n    position[0] - radius,\n    position[1] - radius,\n    position[0] + radius,\n    position[1] + radius,\n  ]\n}\n", "import type {\n  GerberTree,\n  UnitsType,\n  Format,\n  ZeroSuppression,\n} from '@tracespace/parser'\nimport {\n  UNITS,\n  COORDINATE_FORMAT,\n  GRAPHIC,\n  COMMENT,\n  LEADING,\n  TRAILING,\n  IN,\n} from '@tracespace/parser'\n\nexport interface PlotOptions {\n  units: UnitsType\n  coordinateFormat: Format\n  zeroSuppression: ZeroSuppression\n}\n\nconst FORMAT_COMMENT_RE = /FORMAT={?(\\d):(\\d)/\n\nexport function getPlotOptions(tree: GerberTree): PlotOptions {\n  const {children: treeNodes} = tree\n  let units: UnitsType | null = null\n  let coordinateFormat: Format | null = null\n  let zeroSuppression: ZeroSuppression | null = null\n  let index = 0\n\n  while (\n    index < treeNodes.length &&\n    (units === null || coordinateFormat === null || zeroSuppression === null)\n  ) {\n    const node = treeNodes[index]\n\n    switch (node.type) {\n      case UNITS: {\n        units = node.units\n        break\n      }\n\n      case COORDINATE_FORMAT: {\n        coordinateFormat = node.format\n        zeroSuppression = node.zeroSuppression\n        break\n      }\n\n      case GRAPHIC: {\n        const {coordinates} = node\n\n        for (const coordinate of Object.values(coordinates)) {\n          if (zeroSuppression !== null) break\n\n          if (coordinate!.endsWith('0') || coordinate!.includes('.')) {\n            zeroSuppression = LEADING\n          } else if (coordinate!.startsWith('0')) {\n            zeroSuppression = TRAILING\n          }\n        }\n\n        break\n      }\n\n      case COMMENT: {\n        const {comment} = node\n        const formatMatch = FORMAT_COMMENT_RE.exec(comment)\n\n        if (/suppress trailing/i.test(comment)) {\n          zeroSuppression = TRAILING\n        } else if (/(suppress leading|keep zeros)/i.test(comment)) {\n          zeroSuppression = LEADING\n        }\n\n        if (formatMatch) {\n          coordinateFormat = [Number(formatMatch[1]), Number(formatMatch[2])]\n        }\n\n        break\n      }\n\n      default:\n    }\n\n    index += 1\n  }\n\n  return {\n    units: units ?? IN,\n    coordinateFormat: coordinateFormat ?? [2, 4],\n    zeroSuppression: zeroSuppression ?? LEADING,\n  }\n}\n", "// Tool store\n// Keeps track of the defined tools, defined macros, and the current tool\nimport type {\n  GerberNode,\n  SimpleShape,\n  HoleShape,\n  MacroBlock,\n} from '@tracespace/parser'\nimport {\n  MACRO_SHAPE,\n  TOOL_CHANGE,\n  TOOL_DEFINITION,\n  TOOL_MACRO,\n} from '@tracespace/parser'\n\nexport const SIMPLE_TOOL = 'simpleTool'\n\nexport const MACRO_TOOL = 'macroTool'\n\nexport interface SimpleTool {\n  type: typeof SIMPLE_TOOL\n  shape: SimpleShape\n  hole?: HoleShape\n}\n\nexport interface MacroTool {\n  type: typeof MACRO_TOOL\n  macro: MacroBlock[]\n  variableValues: number[]\n}\n\nexport type Tool = SimpleTool | MacroTool\n\nexport interface ToolStore {\n  use(node: GerberNode): Tool | undefined\n}\n\nexport function createToolStore(): ToolStore {\n  return Object.create(ToolStorePrototype)\n}\n\ninterface ToolStoreState {\n  _currentToolCode: string | undefined\n  _toolsByCode: Partial<Record<string, Tool>>\n  _macrosByName: Partial<Record<string, MacroBlock[]>>\n}\n\nconst ToolStorePrototype: ToolStore & ToolStoreState = {\n  _currentToolCode: undefined,\n  _toolsByCode: {},\n  _macrosByName: {},\n\n  use(node: GerberNode): Tool | undefined {\n    if (node.type === TOOL_MACRO) {\n      this._macrosByName[node.name] = node.children\n    }\n\n    if (node.type === TOOL_DEFINITION) {\n      const {shape, hole} = node\n      const tool: Tool =\n        shape.type === MACRO_SHAPE\n          ? {\n              type: MACRO_TOOL,\n              macro: this._macrosByName[shape.name] ?? [],\n              variableValues: shape.variableValues,\n            }\n          : {type: SIMPLE_TOOL, shape, ...(hole && {hole})}\n\n      this._toolsByCode[node.code] = tool\n    }\n\n    if (node.type === TOOL_DEFINITION || node.type === TOOL_CHANGE) {\n      this._currentToolCode = node.code\n    }\n\n    return typeof this._currentToolCode === 'string'\n      ? this._toolsByCode[this._currentToolCode]\n      : undefined\n  },\n}\n", "// Track the location of the plotter and parse coordinate strings\nimport type {GerberNode} from '@tracespace/parser'\nimport {GRAPHIC, TRAILING} from '@tracespace/parser'\n\nimport type {PlotOptions} from './options'\n\nexport interface Point {\n  x: number\n  y: number\n}\n\nexport interface ArcOffsets {\n  i: number\n  j: number\n  a: number\n}\n\nexport interface Location {\n  startPoint: Point\n  endPoint: Point\n  arcOffsets: ArcOffsets\n}\n\nexport interface LocationStore {\n  use(node: GerberNode, options: PlotOptions): Location\n}\n\nexport function createLocationStore(): LocationStore {\n  return Object.create(LocationStorePrototype)\n}\n\ninterface LocationStoreState {\n  _DEFAULT_ARC_OFFSETS: ArcOffsets\n  _previousPoint: Point\n}\n\nconst LocationStorePrototype: LocationStore & LocationStoreState = {\n  _DEFAULT_ARC_OFFSETS: {i: 0, j: 0, a: 0},\n  _previousPoint: {x: 0, y: 0},\n\n  use(node: GerberNode, options: PlotOptions): Location {\n    let arcOffsets = this._DEFAULT_ARC_OFFSETS\n    let startPoint = this._previousPoint\n    let endPoint = startPoint\n\n    if (node.type === GRAPHIC) {\n      const {coordinates} = node\n      const x0 = parseCoordinate(coordinates.x0, startPoint.x, options)\n      const y0 = parseCoordinate(coordinates.y0, startPoint.y, options)\n      const x = parseCoordinate(coordinates.x, x0, options)\n      const y = parseCoordinate(coordinates.y, y0, options)\n      const i = parseCoordinate(coordinates.i, 0, options)\n      const j = parseCoordinate(coordinates.j, 0, options)\n      const a = parseCoordinate(coordinates.a, 0, options)\n\n      if (startPoint.x !== x0 || startPoint.y !== y0) {\n        startPoint = {x: x0, y: y0}\n      }\n\n      if (endPoint.x !== x || endPoint.y !== y) {\n        endPoint = {x, y}\n      }\n\n      if (i !== 0 || j !== 0 || a !== 0) {\n        arcOffsets = {i, j, a}\n      }\n    }\n\n    this._previousPoint = endPoint\n    return {startPoint, endPoint, arcOffsets}\n  },\n}\n\nfunction parseCoordinate(\n  coordinate: string | undefined,\n  defaultValue: number,\n  options: PlotOptions\n): number {\n  if (typeof coordinate !== 'string') {\n    return defaultValue\n  }\n\n  if (coordinate.includes('.') || coordinate === '0') {\n    return Number(coordinate)\n  }\n\n  const {coordinateFormat, zeroSuppression} = options\n  const [integerPlaces, decimalPlaces] = coordinateFormat\n\n  const [sign, signlessCoordinate] =\n    coordinate.startsWith('+') || coordinate.startsWith('-')\n      ? [coordinate[0], coordinate.slice(1)]\n      : ['+', coordinate]\n\n  const digits = integerPlaces + decimalPlaces\n  const paddedCoordinate =\n    zeroSuppression === TRAILING\n      ? signlessCoordinate.padEnd(digits, '0')\n      : signlessCoordinate.padStart(digits, '0')\n\n  const leading = paddedCoordinate.slice(0, integerPlaces)\n  const trailing = paddedCoordinate.slice(integerPlaces)\n\n  return Number(`${sign}${leading}.${trailing}`)\n}\n", "import type {SimpleShape} from '@tracespace/parser'\nimport {CIRCLE, RECTANGLE, OBROUND, POLYGON} from '@tracespace/parser'\n\nimport {\n  HALF_PI,\n  PI,\n  THREE_HALF_PI,\n  TWO_PI,\n  degreesToRadians,\n} from '../coordinate-math'\n\nimport * as Tree from '../tree'\nimport type {Point} from '../location-store'\n\nexport function createShape(\n  shape: SimpleShape,\n  point: Point\n): Tree.SimpleShape {\n  const {x, y} = point\n\n  switch (shape.type) {\n    case CIRCLE: {\n      const {diameter} = shape\n      return {type: Tree.CIRCLE, cx: x, cy: y, r: diameter / 2}\n    }\n\n    case RECTANGLE:\n    case OBROUND: {\n      const {xSize, ySize} = shape\n      const xHalf = xSize / 2\n      const yHalf = ySize / 2\n      const rectangle: Tree.RectangleShape = {\n        type: Tree.RECTANGLE,\n        x: x - xHalf,\n        y: y - yHalf,\n        xSize,\n        ySize,\n      }\n\n      if (shape.type === OBROUND) {\n        rectangle.r = Math.min(xHalf, yHalf)\n      }\n\n      return rectangle\n    }\n\n    case POLYGON: {\n      const {diameter, rotation, vertices} = shape\n      const r = diameter / 2\n      const offset = degreesToRadians(rotation ?? 0)\n      const step = TWO_PI / vertices\n      const points = Array.from({length: vertices}).map<Tree.Position>(\n        (_, i) => {\n          const theta = step * i + offset\n          const pointX = x + r * Math.cos(theta)\n          const pointY = y + r * Math.sin(theta)\n          return [pointX, pointY]\n        }\n      )\n\n      return {type: Tree.POLYGON, points}\n    }\n  }\n}\n\nexport function shapeToSegments(shape: Tree.SimpleShape): Tree.PathSegment[] {\n  if (shape.type === Tree.CIRCLE) {\n    const {cx, cy, r} = shape\n    return [\n      {\n        type: Tree.ARC,\n        start: [cx + r, cy, 0],\n        end: [cx + r, cy, TWO_PI],\n        center: [cx, cy],\n        radius: r,\n      },\n    ]\n  }\n\n  if (shape.type === Tree.RECTANGLE) {\n    const {x, y, xSize, ySize, r} = shape\n\n    if (r === xSize / 2) {\n      return [\n        {\n          type: Tree.LINE,\n          start: [x + xSize, y + r],\n          end: [x + xSize, y + ySize - r],\n        },\n        {\n          type: Tree.ARC,\n          start: [x + xSize, y + ySize - r, 0],\n          end: [x, y + ySize - r, PI],\n          center: [x + r, y + ySize - r],\n          radius: r,\n        },\n        {type: Tree.LINE, start: [x, y + ySize - r], end: [x, y + r]},\n        {\n          type: Tree.ARC,\n          start: [x, y + r, PI],\n          end: [x + xSize, y + r, TWO_PI],\n          center: [x + r, y + r],\n          radius: r,\n        },\n      ]\n    }\n\n    if (r === ySize / 2) {\n      return [\n        {type: Tree.LINE, start: [x + r, y], end: [x + xSize - r, y]},\n        {\n          type: Tree.ARC,\n          start: [x + xSize - r, y, -HALF_PI],\n          end: [x + xSize - r, y + ySize, HALF_PI],\n          center: [x + xSize - r, y + r],\n          radius: r,\n        },\n        {\n          type: Tree.LINE,\n          start: [x + xSize - r, y + ySize],\n          end: [x + r, y + ySize],\n        },\n        {\n          type: Tree.ARC,\n          start: [x + r, y + ySize, HALF_PI],\n          end: [x + r, y, THREE_HALF_PI],\n          center: [x + r, y + r],\n          radius: r,\n        },\n      ]\n    }\n\n    return [\n      {type: Tree.LINE, start: [x, y], end: [x + xSize, y]},\n      {type: Tree.LINE, start: [x + xSize, y], end: [x + xSize, y + ySize]},\n      {type: Tree.LINE, start: [x + xSize, y + ySize], end: [x, y + ySize]},\n      {type: Tree.LINE, start: [x, y + ySize], end: [x, y]},\n    ]\n  }\n\n  if (shape.type === Tree.POLYGON) {\n    return shape.points.map((start, i) => {\n      const endIndex = i < shape.points.length - 1 ? i + 1 : 0\n      return {type: Tree.LINE, start, end: shape.points[endIndex]}\n    })\n  }\n\n  return shape.segments\n}\n", "import {MACRO_SHAPE} from '@tracespace/parser'\n\nimport * as Tree from '../tree'\nimport type {Location} from '../location-store'\nimport type {SimpleTool} from '../tool-store'\n\nimport {createShape, shapeToSegments} from './shapes'\n\nexport function plotShape(tool: SimpleTool, location: Location): Tree.Shape {\n  const {shape: toolShape, hole: toolHole} = tool\n  const shape = createShape(toolShape, location.endPoint)\n  const holeShape = toolHole\n    ? createShape(toolHole, location.endPoint)\n    : undefined\n\n  return holeShape === undefined\n    ? shape\n    : {\n        type: Tree.OUTLINE,\n        segments: [...shapeToSegments(shape), ...shapeToSegments(holeShape)],\n      }\n}\n", "// Functions for stroking rectangular tools\n// Stroking rectangular tools is deprecated by the Gerber spec\n// This functionality may be dropped and replaced with a warning\nimport type {Rectangle} from '@tracespace/parser'\n\nimport * as Tree from '../tree'\nimport {positionsEqual, HALF_PI, PI} from '../coordinate-math'\n\n// Rectangular tools make interesting stroke geometry; see the Gerber spec\n// for graphics and examples\nexport function plotRectPath(\n  segments: Tree.PathSegment[],\n  shape: Rectangle\n): Tree.ImageShape {\n  const shapes = segments\n    .filter((s): s is Tree.PathLineSegment => s.type === Tree.LINE)\n    .map(segment => plotRectPathSegment(segment, shape))\n\n  return {type: Tree.IMAGE_SHAPE, shape: {type: Tree.LAYERED_SHAPE, shapes}}\n}\n\nfunction plotRectPathSegment(\n  segment: Tree.PathLineSegment,\n  shape: Rectangle\n): Tree.PolygonShape {\n  // Since a rectangular stroke like this is so unique to Gerber, it's easier\n  // for downstream graphics generators if we calculate the boundaries of the\n  // correct shape and emit a region rather than a path with a width (which is\n  // what we do for circle tools)\n  const {start, end} = segment\n  const [sx, sy] = start\n  const [ex, ey] = end\n  const [xOffset, yOffset] = [shape.xSize / 2, shape.ySize / 2]\n  const theta = Math.atan2(ey - sy, ex - ey)\n\n  const [sxMin, sxMax] = [sx - xOffset, sx + xOffset]\n  const [syMin, syMax] = [sy - yOffset, sy + yOffset]\n  const [exMin, exMax] = [ex - xOffset, ex + xOffset]\n  const [eyMin, eyMax] = [ey - yOffset, ey + yOffset]\n\n  // Go through the quadrants of the XY plane centered about start to decide\n  // which segments define the boundaries of the stroke shape\n  let points: Tree.Position[] = []\n  if (positionsEqual(start, end)) {\n    points = [\n      [sxMin, syMin],\n      [sxMax, syMin],\n      [exMax, eyMin],\n      [exMax, eyMax],\n      [exMin, eyMax],\n      [sxMin, syMax],\n    ]\n  } else if (theta >= 0 && theta < HALF_PI) {\n    // First quadrant move\n    points = [\n      [sxMin, syMin],\n      [sxMax, syMin],\n      [exMax, eyMin],\n      [exMax, eyMax],\n      [exMin, eyMax],\n      [sxMin, syMax],\n    ]\n  } else if (theta >= HALF_PI && theta <= PI) {\n    // Second quadrant move\n    points = [\n      [sxMax, syMin],\n      [sxMax, syMax],\n      [exMax, eyMax],\n      [exMin, eyMax],\n      [exMin, eyMin],\n      [sxMin, syMin],\n    ]\n  } else if (theta >= -PI && theta < -HALF_PI) {\n    // Third quadrant move\n    points = [\n      [sxMax, syMax],\n      [sxMin, syMax],\n      [exMin, eyMax],\n      [exMin, eyMin],\n      [exMax, eyMin],\n      [sxMax, syMin],\n    ]\n  } else {\n    // Fourth quadrant move\n    points = [\n      [sxMin, syMax],\n      [sxMin, syMin],\n      [exMin, eyMin],\n      [exMax, eyMin],\n      [exMax, eyMax],\n      [sxMax, syMax],\n    ]\n  }\n\n  return {type: Tree.POLYGON, points}\n}\n", "import * as Tree from '../tree'\nimport type {Tool} from '../tool-store'\nimport {SIMPLE_TOOL} from '../tool-store'\nimport type {Location, Point} from '../location-store'\nimport {TWO_PI} from '../coordinate-math'\n\nimport {plotRectPath} from './plot-rect-path'\n\nexport const CW = 'cw'\nexport const CCW = 'ccw'\n\nexport type ArcDirection = typeof CW | typeof CCW\n\nexport function plotSegment(\n  location: Location,\n  arcDirection?: ArcDirection,\n  ambiguousArcCenter?: boolean\n): Tree.PathSegment {\n  return arcDirection === undefined\n    ? createLineSegment(location)\n    : createArcSegment(location, arcDirection, ambiguousArcCenter)\n}\n\nexport function plotPath(\n  segments: Tree.PathSegment[],\n  tool: Tool | undefined,\n  region = false\n): Tree.ImageGraphic | undefined {\n  if (segments.length > 0) {\n    if (region) {\n      return {type: Tree.IMAGE_REGION, segments}\n    }\n\n    if (tool?.type === SIMPLE_TOOL && tool.shape.type === Tree.CIRCLE) {\n      return {type: Tree.IMAGE_PATH, width: tool.shape.diameter, segments}\n    }\n\n    if (tool?.type === SIMPLE_TOOL && tool.shape.type === Tree.RECTANGLE) {\n      return plotRectPath(segments, tool.shape)\n    }\n  }\n}\n\nfunction createLineSegment(location: Location): Tree.PathLineSegment {\n  return {\n    type: Tree.LINE,\n    start: [location.startPoint.x, location.startPoint.y],\n    end: [location.endPoint.x, location.endPoint.y],\n  }\n}\n\nfunction createArcSegment(\n  location: Location,\n  arcDirection: ArcDirection,\n  ambiguousArcCenter = false\n): Tree.PathSegment {\n  const {startPoint, endPoint, arcOffsets} = location\n  const radius =\n    arcOffsets.a > 0\n      ? arcOffsets.a\n      : (arcOffsets.i ** 2 + arcOffsets.j ** 2) ** 0.5\n\n  if (ambiguousArcCenter || arcOffsets.a > 0) {\n    if (startPoint.x === endPoint.x && startPoint.y === endPoint.y) {\n      return createLineSegment(location)\n    }\n\n    // Get the center candidates and select the candidate with the smallest arc\n    const [start, end, center] = findCenterCandidates(location, radius)\n      .map(centerPoint => {\n        return getArcPositions(startPoint, endPoint, centerPoint, arcDirection)\n      })\n      .sort(([startA, endA], [startB, endB]) => {\n        const absSweepA = Math.abs(endA[2] - startA[2])\n        const absSweepB = Math.abs(endB[2] - startB[2])\n        return absSweepA - absSweepB\n      })[0]\n\n    return {type: Tree.ARC, start, end, center, radius}\n  }\n\n  const centerPoint = {\n    x: startPoint.x + arcOffsets.i,\n    y: startPoint.y + arcOffsets.j,\n  }\n\n  const [start, end, center] = getArcPositions(\n    startPoint,\n    endPoint,\n    centerPoint,\n    arcDirection\n  )\n\n  return {type: Tree.ARC, start, end, center, radius}\n}\n\nexport function getArcPositions(\n  startPoint: Point,\n  endPoint: Point,\n  centerPoint: Point,\n  arcDirection: ArcDirection\n): [start: Tree.ArcPosition, end: Tree.ArcPosition, center: Tree.Position] {\n  let startAngle = Math.atan2(\n    startPoint.y - centerPoint.y,\n    startPoint.x - centerPoint.x\n  )\n  let endAngle = Math.atan2(\n    endPoint.y - centerPoint.y,\n    endPoint.x - centerPoint.x\n  )\n\n  // If counter-clockwise, end angle should be greater than start angle\n  if (arcDirection === CCW) {\n    endAngle = endAngle > startAngle ? endAngle : endAngle + TWO_PI\n  } else {\n    startAngle = startAngle > endAngle ? startAngle : startAngle + TWO_PI\n  }\n\n  return [\n    [startPoint.x, startPoint.y, startAngle],\n    [endPoint.x, endPoint.y, endAngle],\n    [centerPoint.x, centerPoint.y],\n  ]\n}\n\n// Find arc center candidates by finding the intersection points\n// of two circles with `radius` centered on the start and end points\n// https://math.stackexchange.com/a/1367732\nfunction findCenterCandidates(location: Location, radius: number): Point[] {\n  // This function assumes that start and end are different points\n  const {x: x1, y: y1} = location.startPoint\n  const {x: x2, y: y2} = location.endPoint\n\n  // Distance between the start and end points\n  const [dx, dy] = [x2 - x1, y2 - y1]\n  const [sx, sy] = [x2 + x1, y2 + y1]\n  const distance = Math.sqrt(dx ** 2 + dy ** 2)\n\n  // If the distance to the midpoint equals the arc radius, then there is\n  // exactly one intersection at the midpoint; if the distance to the midpoint\n  // is greater than the radius, assume we've got a rounding error and just use\n  // the midpoint\n  if (radius <= distance / 2) {\n    return [{x: x1 + dx / 2, y: y1 + dy / 2}]\n  }\n\n  // No good name for these variables, but it's how the math works out\n  const factor = Math.sqrt((4 * radius ** 2) / distance ** 2 - 1)\n  const [xBase, yBase] = [sx / 2, sy / 2]\n  const [xAddend, yAddend] = [(dy * factor) / 2, (dx * factor) / 2]\n\n  return [\n    {x: xBase + xAddend, y: yBase - yAddend},\n    {x: xBase - xAddend, y: yBase + yAddend},\n  ]\n}\n", "// Plot a tool macro as shapes\nimport type {MacroPrimitiveCode, MacroValue} from '@tracespace/parser'\nimport {\n  MACRO_VARIABLE,\n  MACRO_PRIMITIVE,\n  MACRO_CIRCLE,\n  MACRO_VECTOR_LINE_DEPRECATED,\n  MACRO_VECTOR_LINE,\n  MACRO_CENTER_LINE,\n  MACRO_LOWER_LEFT_LINE_DEPRECATED,\n  MACRO_OUTLINE,\n  MACRO_POLYGON,\n  MACRO_MOIRE_DEPRECATED,\n  MACRO_THERMAL,\n} from '@tracespace/parser'\n\nimport {PI, rotateAndShift, positionsEqual} from '../coordinate-math'\n\nimport * as Tree from '../tree'\nimport type {MacroTool} from '../tool-store'\nimport type {Location} from '../location-store'\n\nimport {shapeToSegments} from './shapes'\nimport {CW, CCW, getArcPositions} from './plot-path'\n\ntype VariableValues = Record<string, number>\n\nexport function plotMacro(\n  tool: MacroTool,\n  location: Location\n): Tree.LayeredShape {\n  const shapes: Tree.ErasableShape[] = []\n  const variableValues: VariableValues = Object.fromEntries(\n    tool.variableValues.map((value, i) => [`$${i + 1}`, value])\n  )\n\n  for (const block of tool.macro) {\n    if (block.type === MACRO_VARIABLE) {\n      variableValues[block.name] = solveExpression(block.value, variableValues)\n    }\n\n    if (block.type === MACRO_PRIMITIVE) {\n      const origin: Tree.Position = [location.endPoint.x, location.endPoint.y]\n      const parameters = block.parameters.map(p => {\n        return solveExpression(p, variableValues)\n      })\n\n      shapes.push(...plotPrimitive(block.code, origin, parameters))\n    }\n  }\n\n  return {type: Tree.LAYERED_SHAPE, shapes}\n}\n\nfunction solveExpression(\n  expression: MacroValue,\n  variables: VariableValues\n): number {\n  if (typeof expression === 'number') return expression\n  if (typeof expression === 'string') return variables[expression]\n\n  const left = solveExpression(expression.left, variables)\n  const right = solveExpression(expression.right, variables)\n\n  switch (expression.operator) {\n    case '+': {\n      return left + right\n    }\n\n    case '-': {\n      return left - right\n    }\n\n    case 'x': {\n      return left * right\n    }\n\n    case '/': {\n      return left / right\n    }\n  }\n}\n\nfunction plotPrimitive(\n  code: MacroPrimitiveCode,\n  origin: Tree.Position,\n  parameters: number[]\n): Tree.ErasableShape[] {\n  switch (code) {\n    case MACRO_CIRCLE: {\n      return [plotCircle(origin, parameters)]\n    }\n\n    case MACRO_VECTOR_LINE:\n    case MACRO_VECTOR_LINE_DEPRECATED: {\n      return [plotVectorLine(origin, parameters)]\n    }\n\n    case MACRO_CENTER_LINE: {\n      return [plotCenterLine(origin, parameters)]\n    }\n\n    case MACRO_LOWER_LEFT_LINE_DEPRECATED: {\n      return [plotLowerLeftLine(origin, parameters)]\n    }\n\n    case MACRO_OUTLINE: {\n      return [plotOutline(origin, parameters)]\n    }\n\n    case MACRO_POLYGON: {\n      return [plotPolygon(origin, parameters)]\n    }\n\n    case MACRO_MOIRE_DEPRECATED: {\n      return plotMoire(origin, parameters)\n    }\n\n    case MACRO_THERMAL: {\n      return [plotThermal(origin, parameters)]\n    }\n  }\n\n  return []\n}\n\nfunction plotCircle(\n  origin: Tree.Position,\n  parameters: number[]\n): Tree.ErasableShape {\n  const [exposure, diameter, cx0, cy0, degrees] = parameters\n  const r = diameter / 2\n  const [cx, cy] = rotateAndShift([cx0, cy0], origin, degrees)\n\n  return {type: Tree.CIRCLE, erase: exposure === 0, cx, cy, r}\n}\n\nfunction plotVectorLine(\n  origin: Tree.Position,\n  parameters: number[]\n): Tree.ErasableShape {\n  const [exposure, width, sx, sy, ex, ey, degrees] = parameters\n  const [dy, dx] = [ey - sy, ex - sx]\n  const halfWid = width / 2\n  const dist = Math.sqrt(dy ** 2 + dx ** 2)\n  const [xOff, yOff] = [(halfWid * dx) / dist, (halfWid * dy) / dist]\n\n  return {\n    type: Tree.POLYGON,\n    erase: exposure === 0,\n    points: (\n      [\n        [sx + xOff, sy - yOff],\n        [ex + xOff, ey - yOff],\n        [ex - xOff, ey + yOff],\n        [sx - xOff, sy + yOff],\n      ] as Tree.Position[]\n    ).map(p => rotateAndShift(p, origin, degrees)),\n  }\n}\n\nfunction plotCenterLine(\n  origin: Tree.Position,\n  parameters: number[]\n): Tree.ErasableShape {\n  const [exposure, width, height, cx, cy, degrees] = parameters\n  const [halfWidth, halfHeight] = [width / 2, height / 2]\n\n  return {\n    type: Tree.POLYGON,\n    erase: exposure === 0,\n    points: (\n      [\n        [cx - halfWidth, cy - halfHeight],\n        [cx + halfWidth, cy - halfHeight],\n        [cx + halfWidth, cy + halfHeight],\n        [cx - halfWidth, cy + halfHeight],\n      ] as Tree.Position[]\n    ).map(p => rotateAndShift(p, origin, degrees)),\n  }\n}\n\nfunction plotLowerLeftLine(\n  origin: Tree.Position,\n  parameters: number[]\n): Tree.ErasableShape {\n  const [exposure, width, height, x, y, degrees] = parameters\n\n  return {\n    type: Tree.POLYGON,\n    erase: exposure === 0,\n    points: (\n      [\n        [x, y],\n        [x + width, y],\n        [x + width, y + height],\n        [x, y + height],\n      ] as Tree.Position[]\n    ).map(p => rotateAndShift(p, origin, degrees)),\n  }\n}\n\nfunction plotOutline(\n  origin: Tree.Position,\n  parameters: number[]\n): Tree.ErasableShape {\n  const [exposure, , ...coords] = parameters.slice(0, -1)\n  const degrees = parameters[parameters.length - 1]\n\n  return {\n    type: Tree.POLYGON,\n    erase: exposure === 0,\n    points: coords\n      .flatMap<[number, number]>((coordinate, i) =>\n        i % 2 === 1 ? [[coords[i - 1], coordinate]] : []\n      )\n      .map(p => rotateAndShift(p, origin, degrees)),\n  }\n}\n\nfunction plotPolygon(\n  origin: Tree.Position,\n  parameters: number[]\n): Tree.ErasableShape {\n  const [exposure, vertices, cx, cy, diameter, degrees] = parameters\n  const r = diameter / 2\n  const step = (2 * PI) / vertices\n  const points: Tree.Position[] = []\n  let i\n\n  for (i = 0; i < vertices; i++) {\n    const theta = step * i\n    const pointX = cx + r * Math.cos(theta)\n    const pointY = cy + r * Math.sin(theta)\n    points.push(rotateAndShift([pointX, pointY], origin, degrees))\n  }\n\n  return {type: Tree.POLYGON, erase: exposure === 0, points}\n}\n\nfunction plotMoire(\n  origin: Tree.Position,\n  parameters: number[]\n): Tree.ErasableShape[] {\n  const rotate = (p: Tree.Position): Tree.Position =>\n    rotateAndShift(p, origin, parameters[8])\n\n  const [cx0, cy0, d, ringThx, ringGap, ringN, lineThx, lineLength] = parameters\n  const [cx, cy] = rotate([cx0, cy0])\n  const halfLineThx = lineThx / 2\n  const halfLineLength = lineLength / 2\n\n  const radii = []\n  let count = 0\n  let dRemain = d\n\n  while (dRemain >= 0 && count < ringN) {\n    const r = dRemain / 2\n    const rHole = r - ringThx\n\n    radii.push(r)\n    if (rHole > 0) radii.push(rHole)\n    count += 1\n    dRemain = 2 * (rHole - ringGap)\n  }\n\n  return [\n    {\n      type: Tree.OUTLINE,\n      segments: radii.flatMap(r => {\n        return shapeToSegments({type: Tree.CIRCLE, cx, cy, r})\n      }),\n    },\n    // Vertical stroke\n    {\n      type: Tree.POLYGON,\n      points: (\n        [\n          [cx0 - halfLineThx, cy0 - halfLineLength],\n          [cx0 + halfLineThx, cy0 - halfLineLength],\n          [cx0 + halfLineThx, cy0 + halfLineLength],\n          [cx0 - halfLineThx, cy0 + halfLineLength],\n        ] as Tree.Position[]\n      ).map(rotate),\n    },\n    // Horizontal stroke\n    {\n      type: Tree.POLYGON,\n      points: (\n        [\n          [cx0 - halfLineLength, cy0 - halfLineThx],\n          [cx0 + halfLineLength, cy0 - halfLineThx],\n          [cx0 + halfLineLength, cy0 + halfLineThx],\n          [cx0 - halfLineLength, cy0 + halfLineThx],\n        ] as Tree.Position[]\n      ).map(rotate),\n    },\n  ]\n}\n\nfunction plotThermal(\n  origin: Tree.Position,\n  parameters: number[]\n): Tree.ErasableShape {\n  const [cx0, cy0, od, id, gap, degrees] = parameters\n  const center = rotateAndShift([cx0, cy0], origin, degrees)\n  const [or, ir] = [od / 2, id / 2]\n  const halfGap = gap / 2\n  const oIntSquare = or ** 2 - halfGap ** 2\n  const iIntSquare = ir ** 2 - halfGap ** 2\n  const oInt = Math.sqrt(oIntSquare)\n  const iInt = iIntSquare >= 0 ? Math.sqrt(iIntSquare) : halfGap\n  const positions = [0, 90, 180, 270]\n  const segments: Tree.PathSegment[] = []\n\n  for (const rot of positions) {\n    const points = (\n      [\n        [iInt, halfGap],\n        [oInt, halfGap],\n        [halfGap, oInt],\n        [halfGap, iInt],\n      ] as Tree.Position[]\n    )\n      .map(p => rotateAndShift(p, [cx0, cy0], rot))\n      .map(p => rotateAndShift(p, origin, degrees))\n\n    const [os, oe, oc] = getArcPositions(\n      {x: points[1][0], y: points[1][1]},\n      {x: points[2][0], y: points[2][1]},\n      {x: center[0], y: center[1]},\n      CCW\n    )\n\n    segments.push(\n      {type: Tree.LINE, start: points[0], end: points[1]},\n      {type: Tree.ARC, start: os, end: oe, center: oc, radius: or},\n      {type: Tree.LINE, start: points[2], end: points[3]}\n    )\n\n    if (!positionsEqual(points[0], points[3])) {\n      const [is, ie, ic] = getArcPositions(\n        {x: points[3][0], y: points[3][1]},\n        {x: points[0][0], y: points[0][1]},\n        {x: center[0], y: center[1]},\n        CW\n      )\n      segments.push({\n        type: Tree.ARC,\n        start: is,\n        end: ie,\n        center: ic,\n        radius: ir,\n      })\n    }\n  }\n\n  return {type: Tree.OUTLINE, segments}\n}\n", "// Graphic plotter\n// Takes nodes and turns them into graphics to be added to the image\nimport type {\n  GerberNode,\n  GraphicType,\n  Filetype,\n  InterpolateModeType,\n} from '@tracespace/parser'\nimport {\n  GRAPHIC,\n  SHAPE,\n  SEGMENT,\n  MOVE,\n  SLOT,\n  DONE,\n  LINE,\n  CCW_ARC,\n  CW_ARC,\n  DRILL,\n  SINGLE,\n  INTERPOLATE_MODE,\n  QUADRANT_MODE,\n  REGION_MODE,\n} from '@tracespace/parser'\n\nimport * as Tree from '../tree'\nimport type {Tool} from '../tool-store'\nimport {SIMPLE_TOOL, MACRO_TOOL} from '../tool-store'\nimport type {Location} from '../location-store'\n\nimport {plotShape} from './plot-shape'\nimport {plotMacro} from './plot-macro'\nimport type {ArcDirection} from './plot-path'\nimport {CCW, CW, plotSegment, plotPath} from './plot-path'\n\nexport interface GraphicPlotter {\n  plot(\n    node: GerberNode,\n    tool: Tool | undefined,\n    location: Location\n  ): Tree.ImageGraphic[]\n}\n\nexport function createGraphicPlotter(filetype: Filetype): GraphicPlotter {\n  const plotter = Object.create(GraphicPlotterPrototype)\n\n  return filetype === DRILL\n    ? Object.assign(plotter, DrillGraphicPlotterTrait)\n    : plotter\n}\n\ninterface GraphicPlotterImpl extends GraphicPlotter {\n  _currentPath: CurrentPath | undefined\n  _arcDirection: ArcDirection | undefined\n  _ambiguousArcCenter: boolean\n  _regionMode: boolean\n  _defaultGraphic: NonNullable<GraphicType> | undefined\n\n  _setGraphicState(node: GerberNode): NonNullable<GraphicType> | undefined\n\n  _plotCurrentPath(\n    node: GerberNode,\n    nextTool: Tool | undefined,\n    nextGraphicType: NonNullable<GraphicType> | undefined\n  ): Tree.ImageGraphic | undefined\n}\n\ninterface CurrentPath {\n  segments: Tree.PathSegment[]\n  tool: Tool | undefined\n  region: boolean\n}\n\nconst GraphicPlotterPrototype: GraphicPlotterImpl = {\n  _currentPath: undefined,\n  _arcDirection: undefined,\n  _ambiguousArcCenter: false,\n  _regionMode: false,\n  _defaultGraphic: undefined,\n\n  plot(\n    node: GerberNode,\n    tool: Tool | undefined,\n    location: Location\n  ): Tree.ImageGraphic[] {\n    const graphics: Tree.ImageGraphic[] = []\n    const nextGraphicType = this._setGraphicState(node)\n    const pathGraphic = this._plotCurrentPath(node, tool, nextGraphicType)\n\n    if (pathGraphic) {\n      graphics.push(pathGraphic)\n    }\n\n    if (nextGraphicType === SHAPE && tool?.type === SIMPLE_TOOL) {\n      graphics.push({type: Tree.IMAGE_SHAPE, shape: plotShape(tool, location)})\n    }\n\n    if (nextGraphicType === SHAPE && tool?.type === MACRO_TOOL) {\n      graphics.push({type: Tree.IMAGE_SHAPE, shape: plotMacro(tool, location)})\n    }\n\n    if (nextGraphicType === SEGMENT) {\n      this._currentPath = this._currentPath ?? {\n        segments: [],\n        region: this._regionMode,\n        tool,\n      }\n\n      this._currentPath.segments.push(\n        plotSegment(location, this._arcDirection, this._ambiguousArcCenter)\n      )\n    }\n\n    if (nextGraphicType === SLOT) {\n      const pathGraphic = plotPath([plotSegment(location)], tool)\n\n      if (pathGraphic) {\n        graphics.push(pathGraphic)\n      }\n    }\n\n    return graphics\n  },\n\n  _setGraphicState(node: GerberNode): NonNullable<GraphicType> | undefined {\n    if (node.type === INTERPOLATE_MODE) {\n      this._arcDirection = arcDirectionFromMode(node.mode)\n    }\n\n    if (node.type === QUADRANT_MODE) {\n      this._ambiguousArcCenter = node.quadrant === SINGLE\n    }\n\n    if (node.type === REGION_MODE) {\n      this._regionMode = node.region\n    }\n\n    if (node.type !== GRAPHIC) {\n      return undefined\n    }\n\n    if (node.graphic === SEGMENT) {\n      this._defaultGraphic = SEGMENT\n    } else if (node.graphic !== null) {\n      this._defaultGraphic = undefined\n    }\n\n    return node.graphic ?? this._defaultGraphic\n  },\n\n  _plotCurrentPath(\n    node: GerberNode,\n    nextTool: Tool | undefined,\n    nextGraphicType: NonNullable<GraphicType> | undefined\n  ): Tree.ImageGraphic | undefined {\n    if (this._currentPath === undefined) {\n      return undefined\n    }\n\n    if (\n      nextTool !== this._currentPath.tool ||\n      node.type === REGION_MODE ||\n      node.type === DONE ||\n      (nextGraphicType === MOVE && this._currentPath.region) ||\n      (nextGraphicType === SHAPE && this._currentPath !== undefined)\n    ) {\n      const pathGraphic = plotPath(\n        this._currentPath.segments,\n        this._currentPath.tool,\n        this._currentPath.region\n      )\n\n      this._currentPath = undefined\n      return pathGraphic\n    }\n  },\n}\n\nconst DrillGraphicPlotterTrait: Partial<GraphicPlotterImpl> = {\n  _defaultGraphic: SHAPE,\n  _ambiguousArcCenter: true,\n\n  _setGraphicState(node: GerberNode): NonNullable<GraphicType> | undefined {\n    if (node.type === INTERPOLATE_MODE) {\n      const {mode} = node\n      this._arcDirection = arcDirectionFromMode(mode)\n\n      if (mode === CW_ARC || mode === CCW_ARC || mode === LINE) {\n        this._defaultGraphic = SEGMENT\n      } else if (mode === MOVE) {\n        this._defaultGraphic = MOVE\n      } else {\n        this._defaultGraphic = SHAPE\n      }\n    }\n\n    if (node.type !== GRAPHIC) {\n      return undefined\n    }\n\n    return node.graphic ?? this._defaultGraphic\n  },\n}\n\nfunction arcDirectionFromMode(\n  mode: InterpolateModeType\n): ArcDirection | undefined {\n  if (mode === CCW_ARC) return CCW\n  if (mode === CW_ARC) return CW\n  return undefined\n}\n", "// @tracespace/plotter\n// build abstract board images from @tracespace/parser ASTs\nimport type {GerberTree} from '@tracespace/parser'\n\nimport {fromGraphics as sizeFromGraphics} from './bounding-box'\nimport {getPlotOptions} from './options'\nimport {createToolStore} from './tool-store'\nimport {createLocationStore} from './location-store'\nimport {createGraphicPlotter} from './graphic-plotter'\nimport {IMAGE} from './tree'\nimport type {ImageTree} from './tree'\n\nexport * from './tree'\nexport * as BoundingBox from './bounding-box'\nexport {TWO_PI, positionsEqual} from './coordinate-math'\n\nexport function plot(tree: GerberTree): ImageTree {\n  const plotOptions = getPlotOptions(tree)\n  const toolStore = createToolStore()\n  const locationStore = createLocationStore()\n  const graphicPlotter = createGraphicPlotter(tree.filetype)\n  const children = []\n\n  for (const node of tree.children) {\n    const tool = toolStore.use(node)\n    const location = locationStore.use(node, plotOptions)\n    const graphics = graphicPlotter.plot(node, tool, location)\n\n    children.push(...graphics)\n  }\n\n  return {\n    type: IMAGE,\n    units: plotOptions.units,\n    size: sizeFromGraphics(children),\n    children,\n  }\n}\n", "// Tracespace xml id utilities\n\n// subset of characters that are XML ID, CSS identifier, and URL friendly\nconst START_CHAR = '_ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\nconst CHAR = `-0123456789${START_CHAR}`\nconst REPLACE_RE = new RegExp(`^[^${START_CHAR}]|[^\\\\${CHAR}]`, 'g')\n\nconst DEFAULT_RANDOM_LENGTH = 12\n\nexport function random(length: number = DEFAULT_RANDOM_LENGTH): string {\n  length = length || DEFAULT_RANDOM_LENGTH\n  return _getRandomString(1, START_CHAR) + _getRandomString(length - 1, CHAR)\n}\n\nexport function sanitize(source: string): string {\n  return source.replace(REPLACE_RE, '_')\n}\n\nexport function ensure(\n  maybeId: unknown,\n  length: number = DEFAULT_RANDOM_LENGTH\n): string {\n  return typeof maybeId === 'string' ? sanitize(maybeId) : random(length)\n}\n\nfunction _getRandomString(length: number, alphabet: string): string {\n  const abLength = alphabet.length\n  let result = ''\n\n  while (length > 0) {\n    length--\n    result += alphabet[Math.floor(Math.random() * abLength)]\n  }\n\n  return result\n}\n", "/**\n * @typedef {import('./info.js').Info} Info\n * @typedef {Record<string, Info>} Properties\n * @typedef {Record<string, string>} Normal\n */\n\nexport class Schema {\n  /**\n   * @constructor\n   * @param {Properties} property\n   * @param {Normal} normal\n   * @param {string} [space]\n   */\n  constructor(property, normal, space) {\n    this.property = property\n    this.normal = normal\n    if (space) {\n      this.space = space\n    }\n  }\n}\n\n/** @type {Properties} */\nSchema.prototype.property = {}\n/** @type {Normal} */\nSchema.prototype.normal = {}\n/** @type {string|null} */\nSchema.prototype.space = null\n", "/**\n * @typedef {import('./schema.js').Properties} Properties\n * @typedef {import('./schema.js').Normal} Normal\n */\n\nimport {Schema} from './schema.js'\n\n/**\n * @param {Schema[]} definitions\n * @param {string} [space]\n * @returns {Schema}\n */\nexport function merge(definitions, space) {\n  /** @type {Properties} */\n  const property = {}\n  /** @type {Normal} */\n  const normal = {}\n  let index = -1\n\n  while (++index < definitions.length) {\n    Object.assign(property, definitions[index].property)\n    Object.assign(normal, definitions[index].normal)\n  }\n\n  return new Schema(property, normal, space)\n}\n", "/**\n * @param {string} value\n * @returns {string}\n */\nexport function normalize(value) {\n  return value.toLowerCase()\n}\n", "export class Info {\n  /**\n   * @constructor\n   * @param {string} property\n   * @param {string} attribute\n   */\n  constructor(property, attribute) {\n    /** @type {string} */\n    this.property = property\n    /** @type {string} */\n    this.attribute = attribute\n  }\n}\n\n/** @type {string|null} */\nInfo.prototype.space = null\nInfo.prototype.boolean = false\nInfo.prototype.booleanish = false\nInfo.prototype.overloadedBoolean = false\nInfo.prototype.number = false\nInfo.prototype.commaSeparated = false\nInfo.prototype.spaceSeparated = false\nInfo.prototype.commaOrSpaceSeparated = false\nInfo.prototype.mustUseProperty = false\nInfo.prototype.defined = false\n", "let powers = 0\n\nexport const boolean = increment()\nexport const booleanish = increment()\nexport const overloadedBoolean = increment()\nexport const number = increment()\nexport const spaceSeparated = increment()\nexport const commaSeparated = increment()\nexport const commaOrSpaceSeparated = increment()\n\nfunction increment() {\n  return 2 ** ++powers\n}\n", "import {Info} from './info.js'\nimport * as types from './types.js'\n\n/** @type {Array<keyof types>} */\n// @ts-expect-error: hush.\nconst checks = Object.keys(types)\n\nexport class DefinedInfo extends Info {\n  /**\n   * @constructor\n   * @param {string} property\n   * @param {string} attribute\n   * @param {number|null} [mask]\n   * @param {string} [space]\n   */\n  constructor(property, attribute, mask, space) {\n    let index = -1\n\n    super(property, attribute)\n\n    mark(this, 'space', space)\n\n    if (typeof mask === 'number') {\n      while (++index < checks.length) {\n        const check = checks[index]\n        mark(this, checks[index], (mask & types[check]) === types[check])\n      }\n    }\n  }\n}\n\nDefinedInfo.prototype.defined = true\n\n/**\n * @param {DefinedInfo} values\n * @param {string} key\n * @param {unknown} value\n */\nfunction mark(values, key, value) {\n  if (value) {\n    // @ts-expect-error: assume `value` matches the expected value of `key`.\n    values[key] = value\n  }\n}\n", "/**\n * @typedef {import('./schema.js').Properties} Properties\n * @typedef {import('./schema.js').Normal} Normal\n *\n * @typedef {Record<string, string>} Attributes\n *\n * @typedef {Object} Definition\n * @property {Record<string, number|null>} properties\n * @property {(attributes: Attributes, property: string) => string} transform\n * @property {string} [space]\n * @property {Attributes} [attributes]\n * @property {Array<string>} [mustUseProperty]\n */\n\nimport {normalize} from '../normalize.js'\nimport {Schema} from './schema.js'\nimport {DefinedInfo} from './defined-info.js'\n\nconst own = {}.hasOwnProperty\n\n/**\n * @param {Definition} definition\n * @returns {Schema}\n */\nexport function create(definition) {\n  /** @type {Properties} */\n  const property = {}\n  /** @type {Normal} */\n  const normal = {}\n  /** @type {string} */\n  let prop\n\n  for (prop in definition.properties) {\n    if (own.call(definition.properties, prop)) {\n      const value = definition.properties[prop]\n      const info = new DefinedInfo(\n        prop,\n        definition.transform(definition.attributes || {}, prop),\n        value,\n        definition.space\n      )\n\n      if (\n        definition.mustUseProperty &&\n        definition.mustUseProperty.includes(prop)\n      ) {\n        info.mustUseProperty = true\n      }\n\n      property[prop] = info\n\n      normal[normalize(prop)] = prop\n      normal[normalize(info.attribute)] = prop\n    }\n  }\n\n  return new Schema(property, normal, definition.space)\n}\n", "import {create} from './util/create.js'\n\nexport const xlink = create({\n  space: 'xlink',\n  transform(_, prop) {\n    return 'xlink:' + prop.slice(5).toLowerCase()\n  },\n  properties: {\n    xLinkActuate: null,\n    xLinkArcRole: null,\n    xLinkHref: null,\n    xLinkRole: null,\n    xLinkShow: null,\n    xLinkTitle: null,\n    xLinkType: null\n  }\n})\n", "import {create} from './util/create.js'\n\nexport const xml = create({\n  space: 'xml',\n  transform(_, prop) {\n    return 'xml:' + prop.slice(3).toLowerCase()\n  },\n  properties: {xmlLang: null, xmlBase: null, xmlSpace: null}\n})\n", "/**\n * @param {Record<string, string>} attributes\n * @param {string} attribute\n * @returns {string}\n */\nexport function caseSensitiveTransform(attributes, attribute) {\n  return attribute in attributes ? attributes[attribute] : attribute\n}\n", "import {caseSensitiveTransform} from './case-sensitive-transform.js'\n\n/**\n * @param {Record<string, string>} attributes\n * @param {string} property\n * @returns {string}\n */\nexport function caseInsensitiveTransform(attributes, property) {\n  return caseSensitiveTransform(attributes, property.toLowerCase())\n}\n", "import {create} from './util/create.js'\nimport {caseInsensitiveTransform} from './util/case-insensitive-transform.js'\n\nexport const xmlns = create({\n  space: 'xmlns',\n  attributes: {xmlnsxlink: 'xmlns:xlink'},\n  transform: caseInsensitiveTransform,\n  properties: {xmlns: null, xmlnsXLink: null}\n})\n", "import {booleanish, number, spaceSeparated} from './util/types.js'\nimport {create} from './util/create.js'\n\nexport const aria = create({\n  transform(_, prop) {\n    return prop === 'role' ? prop : 'aria-' + prop.slice(4).toLowerCase()\n  },\n  properties: {\n    ariaActiveDescendant: null,\n    ariaAtomic: booleanish,\n    ariaAutoComplete: null,\n    ariaBusy: booleanish,\n    ariaChecked: booleanish,\n    ariaColCount: number,\n    ariaColIndex: number,\n    ariaColSpan: number,\n    ariaControls: spaceSeparated,\n    ariaCurrent: null,\n    ariaDescribedBy: spaceSeparated,\n    ariaDetails: null,\n    ariaDisabled: booleanish,\n    ariaDropEffect: spaceSeparated,\n    ariaErrorMessage: null,\n    ariaExpanded: booleanish,\n    ariaFlowTo: spaceSeparated,\n    ariaGrabbed: booleanish,\n    ariaHasPopup: null,\n    ariaHidden: booleanish,\n    ariaInvalid: null,\n    ariaKeyShortcuts: null,\n    ariaLabel: null,\n    ariaLabelledBy: spaceSeparated,\n    ariaLevel: number,\n    ariaLive: null,\n    ariaModal: booleanish,\n    ariaMultiLine: booleanish,\n    ariaMultiSelectable: booleanish,\n    ariaOrientation: null,\n    ariaOwns: spaceSeparated,\n    ariaPlaceholder: null,\n    ariaPosInSet: number,\n    ariaPressed: booleanish,\n    ariaReadOnly: booleanish,\n    ariaRelevant: null,\n    ariaRequired: booleanish,\n    ariaRoleDescription: spaceSeparated,\n    ariaRowCount: number,\n    ariaRowIndex: number,\n    ariaRowSpan: number,\n    ariaSelected: booleanish,\n    ariaSetSize: number,\n    ariaSort: null,\n    ariaValueMax: number,\n    ariaValueMin: number,\n    ariaValueNow: number,\n    ariaValueText: null,\n    role: null\n  }\n})\n", "import {\n  boolean,\n  overloadedBoolean,\n  booleanish,\n  number,\n  spaceSeparated,\n  commaSeparated\n} from './util/types.js'\nimport {create} from './util/create.js'\nimport {caseInsensitiveTransform} from './util/case-insensitive-transform.js'\n\nexport const html = create({\n  space: 'html',\n  attributes: {\n    acceptcharset: 'accept-charset',\n    classname: 'class',\n    htmlfor: 'for',\n    httpequiv: 'http-equiv'\n  },\n  transform: caseInsensitiveTransform,\n  mustUseProperty: ['checked', 'multiple', 'muted', 'selected'],\n  properties: {\n    // Standard Properties.\n    abbr: null,\n    accept: commaSeparated,\n    acceptCharset: spaceSeparated,\n    accessKey: spaceSeparated,\n    action: null,\n    allow: null,\n    allowFullScreen: boolean,\n    allowPaymentRequest: boolean,\n    allowUserMedia: boolean,\n    alt: null,\n    as: null,\n    async: boolean,\n    autoCapitalize: null,\n    autoComplete: spaceSeparated,\n    autoFocus: boolean,\n    autoPlay: boolean,\n    capture: boolean,\n    charSet: null,\n    checked: boolean,\n    cite: null,\n    className: spaceSeparated,\n    cols: number,\n    colSpan: null,\n    content: null,\n    contentEditable: booleanish,\n    controls: boolean,\n    controlsList: spaceSeparated,\n    coords: number | commaSeparated,\n    crossOrigin: null,\n    data: null,\n    dateTime: null,\n    decoding: null,\n    default: boolean,\n    defer: boolean,\n    dir: null,\n    dirName: null,\n    disabled: boolean,\n    download: overloadedBoolean,\n    draggable: booleanish,\n    encType: null,\n    enterKeyHint: null,\n    form: null,\n    formAction: null,\n    formEncType: null,\n    formMethod: null,\n    formNoValidate: boolean,\n    formTarget: null,\n    headers: spaceSeparated,\n    height: number,\n    hidden: boolean,\n    high: number,\n    href: null,\n    hrefLang: null,\n    htmlFor: spaceSeparated,\n    httpEquiv: spaceSeparated,\n    id: null,\n    imageSizes: null,\n    imageSrcSet: null,\n    inputMode: null,\n    integrity: null,\n    is: null,\n    isMap: boolean,\n    itemId: null,\n    itemProp: spaceSeparated,\n    itemRef: spaceSeparated,\n    itemScope: boolean,\n    itemType: spaceSeparated,\n    kind: null,\n    label: null,\n    lang: null,\n    language: null,\n    list: null,\n    loading: null,\n    loop: boolean,\n    low: number,\n    manifest: null,\n    max: null,\n    maxLength: number,\n    media: null,\n    method: null,\n    min: null,\n    minLength: number,\n    multiple: boolean,\n    muted: boolean,\n    name: null,\n    nonce: null,\n    noModule: boolean,\n    noValidate: boolean,\n    onAbort: null,\n    onAfterPrint: null,\n    onAuxClick: null,\n    onBeforeMatch: null,\n    onBeforePrint: null,\n    onBeforeUnload: null,\n    onBlur: null,\n    onCancel: null,\n    onCanPlay: null,\n    onCanPlayThrough: null,\n    onChange: null,\n    onClick: null,\n    onClose: null,\n    onContextLost: null,\n    onContextMenu: null,\n    onContextRestored: null,\n    onCopy: null,\n    onCueChange: null,\n    onCut: null,\n    onDblClick: null,\n    onDrag: null,\n    onDragEnd: null,\n    onDragEnter: null,\n    onDragExit: null,\n    onDragLeave: null,\n    onDragOver: null,\n    onDragStart: null,\n    onDrop: null,\n    onDurationChange: null,\n    onEmptied: null,\n    onEnded: null,\n    onError: null,\n    onFocus: null,\n    onFormData: null,\n    onHashChange: null,\n    onInput: null,\n    onInvalid: null,\n    onKeyDown: null,\n    onKeyPress: null,\n    onKeyUp: null,\n    onLanguageChange: null,\n    onLoad: null,\n    onLoadedData: null,\n    onLoadedMetadata: null,\n    onLoadEnd: null,\n    onLoadStart: null,\n    onMessage: null,\n    onMessageError: null,\n    onMouseDown: null,\n    onMouseEnter: null,\n    onMouseLeave: null,\n    onMouseMove: null,\n    onMouseOut: null,\n    onMouseOver: null,\n    onMouseUp: null,\n    onOffline: null,\n    onOnline: null,\n    onPageHide: null,\n    onPageShow: null,\n    onPaste: null,\n    onPause: null,\n    onPlay: null,\n    onPlaying: null,\n    onPopState: null,\n    onProgress: null,\n    onRateChange: null,\n    onRejectionHandled: null,\n    onReset: null,\n    onResize: null,\n    onScroll: null,\n    onScrollEnd: null,\n    onSecurityPolicyViolation: null,\n    onSeeked: null,\n    onSeeking: null,\n    onSelect: null,\n    onSlotChange: null,\n    onStalled: null,\n    onStorage: null,\n    onSubmit: null,\n    onSuspend: null,\n    onTimeUpdate: null,\n    onToggle: null,\n    onUnhandledRejection: null,\n    onUnload: null,\n    onVolumeChange: null,\n    onWaiting: null,\n    onWheel: null,\n    open: boolean,\n    optimum: number,\n    pattern: null,\n    ping: spaceSeparated,\n    placeholder: null,\n    playsInline: boolean,\n    poster: null,\n    preload: null,\n    readOnly: boolean,\n    referrerPolicy: null,\n    rel: spaceSeparated,\n    required: boolean,\n    reversed: boolean,\n    rows: number,\n    rowSpan: number,\n    sandbox: spaceSeparated,\n    scope: null,\n    scoped: boolean,\n    seamless: boolean,\n    selected: boolean,\n    shape: null,\n    size: number,\n    sizes: null,\n    slot: null,\n    span: number,\n    spellCheck: booleanish,\n    src: null,\n    srcDoc: null,\n    srcLang: null,\n    srcSet: null,\n    start: number,\n    step: null,\n    style: null,\n    tabIndex: number,\n    target: null,\n    title: null,\n    translate: null,\n    type: null,\n    typeMustMatch: boolean,\n    useMap: null,\n    value: booleanish,\n    width: number,\n    wrap: null,\n\n    // Legacy.\n    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis\n    align: null, // Several. Use CSS `text-align` instead,\n    aLink: null, // `<body>`. Use CSS `a:active {color}` instead\n    archive: spaceSeparated, // `<object>`. List of URIs to archives\n    axis: null, // `<td>` and `<th>`. Use `scope` on `<th>`\n    background: null, // `<body>`. Use CSS `background-image` instead\n    bgColor: null, // `<body>` and table elements. Use CSS `background-color` instead\n    border: number, // `<table>`. Use CSS `border-width` instead,\n    borderColor: null, // `<table>`. Use CSS `border-color` instead,\n    bottomMargin: number, // `<body>`\n    cellPadding: null, // `<table>`\n    cellSpacing: null, // `<table>`\n    char: null, // Several table elements. When `align=char`, sets the character to align on\n    charOff: null, // Several table elements. When `char`, offsets the alignment\n    classId: null, // `<object>`\n    clear: null, // `<br>`. Use CSS `clear` instead\n    code: null, // `<object>`\n    codeBase: null, // `<object>`\n    codeType: null, // `<object>`\n    color: null, // `<font>` and `<hr>`. Use CSS instead\n    compact: boolean, // Lists. Use CSS to reduce space between items instead\n    declare: boolean, // `<object>`\n    event: null, // `<script>`\n    face: null, // `<font>`. Use CSS instead\n    frame: null, // `<table>`\n    frameBorder: null, // `<iframe>`. Use CSS `border` instead\n    hSpace: number, // `<img>` and `<object>`\n    leftMargin: number, // `<body>`\n    link: null, // `<body>`. Use CSS `a:link {color: *}` instead\n    longDesc: null, // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`\n    lowSrc: null, // `<img>`. Use a `<picture>`\n    marginHeight: number, // `<body>`\n    marginWidth: number, // `<body>`\n    noResize: boolean, // `<frame>`\n    noHref: boolean, // `<area>`. Use no href instead of an explicit `nohref`\n    noShade: boolean, // `<hr>`. Use background-color and height instead of borders\n    noWrap: boolean, // `<td>` and `<th>`\n    object: null, // `<applet>`\n    profile: null, // `<head>`\n    prompt: null, // `<isindex>`\n    rev: null, // `<link>`\n    rightMargin: number, // `<body>`\n    rules: null, // `<table>`\n    scheme: null, // `<meta>`\n    scrolling: booleanish, // `<frame>`. Use overflow in the child context\n    standby: null, // `<object>`\n    summary: null, // `<table>`\n    text: null, // `<body>`. Use CSS `color` instead\n    topMargin: number, // `<body>`\n    valueType: null, // `<param>`\n    version: null, // `<html>`. Use a doctype.\n    vAlign: null, // Several. Use CSS `vertical-align` instead\n    vLink: null, // `<body>`. Use CSS `a:visited {color}` instead\n    vSpace: number, // `<img>` and `<object>`\n\n    // Non-standard Properties.\n    allowTransparency: null,\n    autoCorrect: null,\n    autoSave: null,\n    disablePictureInPicture: boolean,\n    disableRemotePlayback: boolean,\n    prefix: null,\n    property: null,\n    results: number,\n    security: null,\n    unselectable: null\n  }\n})\n", "import {\n  boolean,\n  number,\n  spaceSeparated,\n  commaSeparated,\n  commaOrSpaceSeparated\n} from './util/types.js'\nimport {create} from './util/create.js'\nimport {caseSensitiveTransform} from './util/case-sensitive-transform.js'\n\nexport const svg = create({\n  space: 'svg',\n  attributes: {\n    accentHeight: 'accent-height',\n    alignmentBaseline: 'alignment-baseline',\n    arabicForm: 'arabic-form',\n    baselineShift: 'baseline-shift',\n    capHeight: 'cap-height',\n    className: 'class',\n    clipPath: 'clip-path',\n    clipRule: 'clip-rule',\n    colorInterpolation: 'color-interpolation',\n    colorInterpolationFilters: 'color-interpolation-filters',\n    colorProfile: 'color-profile',\n    colorRendering: 'color-rendering',\n    crossOrigin: 'crossorigin',\n    dataType: 'datatype',\n    dominantBaseline: 'dominant-baseline',\n    enableBackground: 'enable-background',\n    fillOpacity: 'fill-opacity',\n    fillRule: 'fill-rule',\n    floodColor: 'flood-color',\n    floodOpacity: 'flood-opacity',\n    fontFamily: 'font-family',\n    fontSize: 'font-size',\n    fontSizeAdjust: 'font-size-adjust',\n    fontStretch: 'font-stretch',\n    fontStyle: 'font-style',\n    fontVariant: 'font-variant',\n    fontWeight: 'font-weight',\n    glyphName: 'glyph-name',\n    glyphOrientationHorizontal: 'glyph-orientation-horizontal',\n    glyphOrientationVertical: 'glyph-orientation-vertical',\n    hrefLang: 'hreflang',\n    horizAdvX: 'horiz-adv-x',\n    horizOriginX: 'horiz-origin-x',\n    horizOriginY: 'horiz-origin-y',\n    imageRendering: 'image-rendering',\n    letterSpacing: 'letter-spacing',\n    lightingColor: 'lighting-color',\n    markerEnd: 'marker-end',\n    markerMid: 'marker-mid',\n    markerStart: 'marker-start',\n    navDown: 'nav-down',\n    navDownLeft: 'nav-down-left',\n    navDownRight: 'nav-down-right',\n    navLeft: 'nav-left',\n    navNext: 'nav-next',\n    navPrev: 'nav-prev',\n    navRight: 'nav-right',\n    navUp: 'nav-up',\n    navUpLeft: 'nav-up-left',\n    navUpRight: 'nav-up-right',\n    onAbort: 'onabort',\n    onActivate: 'onactivate',\n    onAfterPrint: 'onafterprint',\n    onBeforePrint: 'onbeforeprint',\n    onBegin: 'onbegin',\n    onCancel: 'oncancel',\n    onCanPlay: 'oncanplay',\n    onCanPlayThrough: 'oncanplaythrough',\n    onChange: 'onchange',\n    onClick: 'onclick',\n    onClose: 'onclose',\n    onCopy: 'oncopy',\n    onCueChange: 'oncuechange',\n    onCut: 'oncut',\n    onDblClick: 'ondblclick',\n    onDrag: 'ondrag',\n    onDragEnd: 'ondragend',\n    onDragEnter: 'ondragenter',\n    onDragExit: 'ondragexit',\n    onDragLeave: 'ondragleave',\n    onDragOver: 'ondragover',\n    onDragStart: 'ondragstart',\n    onDrop: 'ondrop',\n    onDurationChange: 'ondurationchange',\n    onEmptied: 'onemptied',\n    onEnd: 'onend',\n    onEnded: 'onended',\n    onError: 'onerror',\n    onFocus: 'onfocus',\n    onFocusIn: 'onfocusin',\n    onFocusOut: 'onfocusout',\n    onHashChange: 'onhashchange',\n    onInput: 'oninput',\n    onInvalid: 'oninvalid',\n    onKeyDown: 'onkeydown',\n    onKeyPress: 'onkeypress',\n    onKeyUp: 'onkeyup',\n    onLoad: 'onload',\n    onLoadedData: 'onloadeddata',\n    onLoadedMetadata: 'onloadedmetadata',\n    onLoadStart: 'onloadstart',\n    onMessage: 'onmessage',\n    onMouseDown: 'onmousedown',\n    onMouseEnter: 'onmouseenter',\n    onMouseLeave: 'onmouseleave',\n    onMouseMove: 'onmousemove',\n    onMouseOut: 'onmouseout',\n    onMouseOver: 'onmouseover',\n    onMouseUp: 'onmouseup',\n    onMouseWheel: 'onmousewheel',\n    onOffline: 'onoffline',\n    onOnline: 'ononline',\n    onPageHide: 'onpagehide',\n    onPageShow: 'onpageshow',\n    onPaste: 'onpaste',\n    onPause: 'onpause',\n    onPlay: 'onplay',\n    onPlaying: 'onplaying',\n    onPopState: 'onpopstate',\n    onProgress: 'onprogress',\n    onRateChange: 'onratechange',\n    onRepeat: 'onrepeat',\n    onReset: 'onreset',\n    onResize: 'onresize',\n    onScroll: 'onscroll',\n    onSeeked: 'onseeked',\n    onSeeking: 'onseeking',\n    onSelect: 'onselect',\n    onShow: 'onshow',\n    onStalled: 'onstalled',\n    onStorage: 'onstorage',\n    onSubmit: 'onsubmit',\n    onSuspend: 'onsuspend',\n    onTimeUpdate: 'ontimeupdate',\n    onToggle: 'ontoggle',\n    onUnload: 'onunload',\n    onVolumeChange: 'onvolumechange',\n    onWaiting: 'onwaiting',\n    onZoom: 'onzoom',\n    overlinePosition: 'overline-position',\n    overlineThickness: 'overline-thickness',\n    paintOrder: 'paint-order',\n    panose1: 'panose-1',\n    pointerEvents: 'pointer-events',\n    referrerPolicy: 'referrerpolicy',\n    renderingIntent: 'rendering-intent',\n    shapeRendering: 'shape-rendering',\n    stopColor: 'stop-color',\n    stopOpacity: 'stop-opacity',\n    strikethroughPosition: 'strikethrough-position',\n    strikethroughThickness: 'strikethrough-thickness',\n    strokeDashArray: 'stroke-dasharray',\n    strokeDashOffset: 'stroke-dashoffset',\n    strokeLineCap: 'stroke-linecap',\n    strokeLineJoin: 'stroke-linejoin',\n    strokeMiterLimit: 'stroke-miterlimit',\n    strokeOpacity: 'stroke-opacity',\n    strokeWidth: 'stroke-width',\n    tabIndex: 'tabindex',\n    textAnchor: 'text-anchor',\n    textDecoration: 'text-decoration',\n    textRendering: 'text-rendering',\n    typeOf: 'typeof',\n    underlinePosition: 'underline-position',\n    underlineThickness: 'underline-thickness',\n    unicodeBidi: 'unicode-bidi',\n    unicodeRange: 'unicode-range',\n    unitsPerEm: 'units-per-em',\n    vAlphabetic: 'v-alphabetic',\n    vHanging: 'v-hanging',\n    vIdeographic: 'v-ideographic',\n    vMathematical: 'v-mathematical',\n    vectorEffect: 'vector-effect',\n    vertAdvY: 'vert-adv-y',\n    vertOriginX: 'vert-origin-x',\n    vertOriginY: 'vert-origin-y',\n    wordSpacing: 'word-spacing',\n    writingMode: 'writing-mode',\n    xHeight: 'x-height',\n    // These were camelcased in Tiny. Now lowercased in SVG 2\n    playbackOrder: 'playbackorder',\n    timelineBegin: 'timelinebegin'\n  },\n  transform: caseSensitiveTransform,\n  properties: {\n    about: commaOrSpaceSeparated,\n    accentHeight: number,\n    accumulate: null,\n    additive: null,\n    alignmentBaseline: null,\n    alphabetic: number,\n    amplitude: number,\n    arabicForm: null,\n    ascent: number,\n    attributeName: null,\n    attributeType: null,\n    azimuth: number,\n    bandwidth: null,\n    baselineShift: null,\n    baseFrequency: null,\n    baseProfile: null,\n    bbox: null,\n    begin: null,\n    bias: number,\n    by: null,\n    calcMode: null,\n    capHeight: number,\n    className: spaceSeparated,\n    clip: null,\n    clipPath: null,\n    clipPathUnits: null,\n    clipRule: null,\n    color: null,\n    colorInterpolation: null,\n    colorInterpolationFilters: null,\n    colorProfile: null,\n    colorRendering: null,\n    content: null,\n    contentScriptType: null,\n    contentStyleType: null,\n    crossOrigin: null,\n    cursor: null,\n    cx: null,\n    cy: null,\n    d: null,\n    dataType: null,\n    defaultAction: null,\n    descent: number,\n    diffuseConstant: number,\n    direction: null,\n    display: null,\n    dur: null,\n    divisor: number,\n    dominantBaseline: null,\n    download: boolean,\n    dx: null,\n    dy: null,\n    edgeMode: null,\n    editable: null,\n    elevation: number,\n    enableBackground: null,\n    end: null,\n    event: null,\n    exponent: number,\n    externalResourcesRequired: null,\n    fill: null,\n    fillOpacity: number,\n    fillRule: null,\n    filter: null,\n    filterRes: null,\n    filterUnits: null,\n    floodColor: null,\n    floodOpacity: null,\n    focusable: null,\n    focusHighlight: null,\n    fontFamily: null,\n    fontSize: null,\n    fontSizeAdjust: null,\n    fontStretch: null,\n    fontStyle: null,\n    fontVariant: null,\n    fontWeight: null,\n    format: null,\n    fr: null,\n    from: null,\n    fx: null,\n    fy: null,\n    g1: commaSeparated,\n    g2: commaSeparated,\n    glyphName: commaSeparated,\n    glyphOrientationHorizontal: null,\n    glyphOrientationVertical: null,\n    glyphRef: null,\n    gradientTransform: null,\n    gradientUnits: null,\n    handler: null,\n    hanging: number,\n    hatchContentUnits: null,\n    hatchUnits: null,\n    height: null,\n    href: null,\n    hrefLang: null,\n    horizAdvX: number,\n    horizOriginX: number,\n    horizOriginY: number,\n    id: null,\n    ideographic: number,\n    imageRendering: null,\n    initialVisibility: null,\n    in: null,\n    in2: null,\n    intercept: number,\n    k: number,\n    k1: number,\n    k2: number,\n    k3: number,\n    k4: number,\n    kernelMatrix: commaOrSpaceSeparated,\n    kernelUnitLength: null,\n    keyPoints: null, // SEMI_COLON_SEPARATED\n    keySplines: null, // SEMI_COLON_SEPARATED\n    keyTimes: null, // SEMI_COLON_SEPARATED\n    kerning: null,\n    lang: null,\n    lengthAdjust: null,\n    letterSpacing: null,\n    lightingColor: null,\n    limitingConeAngle: number,\n    local: null,\n    markerEnd: null,\n    markerMid: null,\n    markerStart: null,\n    markerHeight: null,\n    markerUnits: null,\n    markerWidth: null,\n    mask: null,\n    maskContentUnits: null,\n    maskUnits: null,\n    mathematical: null,\n    max: null,\n    media: null,\n    mediaCharacterEncoding: null,\n    mediaContentEncodings: null,\n    mediaSize: number,\n    mediaTime: null,\n    method: null,\n    min: null,\n    mode: null,\n    name: null,\n    navDown: null,\n    navDownLeft: null,\n    navDownRight: null,\n    navLeft: null,\n    navNext: null,\n    navPrev: null,\n    navRight: null,\n    navUp: null,\n    navUpLeft: null,\n    navUpRight: null,\n    numOctaves: null,\n    observer: null,\n    offset: null,\n    onAbort: null,\n    onActivate: null,\n    onAfterPrint: null,\n    onBeforePrint: null,\n    onBegin: null,\n    onCancel: null,\n    onCanPlay: null,\n    onCanPlayThrough: null,\n    onChange: null,\n    onClick: null,\n    onClose: null,\n    onCopy: null,\n    onCueChange: null,\n    onCut: null,\n    onDblClick: null,\n    onDrag: null,\n    onDragEnd: null,\n    onDragEnter: null,\n    onDragExit: null,\n    onDragLeave: null,\n    onDragOver: null,\n    onDragStart: null,\n    onDrop: null,\n    onDurationChange: null,\n    onEmptied: null,\n    onEnd: null,\n    onEnded: null,\n    onError: null,\n    onFocus: null,\n    onFocusIn: null,\n    onFocusOut: null,\n    onHashChange: null,\n    onInput: null,\n    onInvalid: null,\n    onKeyDown: null,\n    onKeyPress: null,\n    onKeyUp: null,\n    onLoad: null,\n    onLoadedData: null,\n    onLoadedMetadata: null,\n    onLoadStart: null,\n    onMessage: null,\n    onMouseDown: null,\n    onMouseEnter: null,\n    onMouseLeave: null,\n    onMouseMove: null,\n    onMouseOut: null,\n    onMouseOver: null,\n    onMouseUp: null,\n    onMouseWheel: null,\n    onOffline: null,\n    onOnline: null,\n    onPageHide: null,\n    onPageShow: null,\n    onPaste: null,\n    onPause: null,\n    onPlay: null,\n    onPlaying: null,\n    onPopState: null,\n    onProgress: null,\n    onRateChange: null,\n    onRepeat: null,\n    onReset: null,\n    onResize: null,\n    onScroll: null,\n    onSeeked: null,\n    onSeeking: null,\n    onSelect: null,\n    onShow: null,\n    onStalled: null,\n    onStorage: null,\n    onSubmit: null,\n    onSuspend: null,\n    onTimeUpdate: null,\n    onToggle: null,\n    onUnload: null,\n    onVolumeChange: null,\n    onWaiting: null,\n    onZoom: null,\n    opacity: null,\n    operator: null,\n    order: null,\n    orient: null,\n    orientation: null,\n    origin: null,\n    overflow: null,\n    overlay: null,\n    overlinePosition: number,\n    overlineThickness: number,\n    paintOrder: null,\n    panose1: null,\n    path: null,\n    pathLength: number,\n    patternContentUnits: null,\n    patternTransform: null,\n    patternUnits: null,\n    phase: null,\n    ping: spaceSeparated,\n    pitch: null,\n    playbackOrder: null,\n    pointerEvents: null,\n    points: null,\n    pointsAtX: number,\n    pointsAtY: number,\n    pointsAtZ: number,\n    preserveAlpha: null,\n    preserveAspectRatio: null,\n    primitiveUnits: null,\n    propagate: null,\n    property: commaOrSpaceSeparated,\n    r: null,\n    radius: null,\n    referrerPolicy: null,\n    refX: null,\n    refY: null,\n    rel: commaOrSpaceSeparated,\n    rev: commaOrSpaceSeparated,\n    renderingIntent: null,\n    repeatCount: null,\n    repeatDur: null,\n    requiredExtensions: commaOrSpaceSeparated,\n    requiredFeatures: commaOrSpaceSeparated,\n    requiredFonts: commaOrSpaceSeparated,\n    requiredFormats: commaOrSpaceSeparated,\n    resource: null,\n    restart: null,\n    result: null,\n    rotate: null,\n    rx: null,\n    ry: null,\n    scale: null,\n    seed: null,\n    shapeRendering: null,\n    side: null,\n    slope: null,\n    snapshotTime: null,\n    specularConstant: number,\n    specularExponent: number,\n    spreadMethod: null,\n    spacing: null,\n    startOffset: null,\n    stdDeviation: null,\n    stemh: null,\n    stemv: null,\n    stitchTiles: null,\n    stopColor: null,\n    stopOpacity: null,\n    strikethroughPosition: number,\n    strikethroughThickness: number,\n    string: null,\n    stroke: null,\n    strokeDashArray: commaOrSpaceSeparated,\n    strokeDashOffset: null,\n    strokeLineCap: null,\n    strokeLineJoin: null,\n    strokeMiterLimit: number,\n    strokeOpacity: number,\n    strokeWidth: null,\n    style: null,\n    surfaceScale: number,\n    syncBehavior: null,\n    syncBehaviorDefault: null,\n    syncMaster: null,\n    syncTolerance: null,\n    syncToleranceDefault: null,\n    systemLanguage: commaOrSpaceSeparated,\n    tabIndex: number,\n    tableValues: null,\n    target: null,\n    targetX: number,\n    targetY: number,\n    textAnchor: null,\n    textDecoration: null,\n    textRendering: null,\n    textLength: null,\n    timelineBegin: null,\n    title: null,\n    transformBehavior: null,\n    type: null,\n    typeOf: commaOrSpaceSeparated,\n    to: null,\n    transform: null,\n    u1: null,\n    u2: null,\n    underlinePosition: number,\n    underlineThickness: number,\n    unicode: null,\n    unicodeBidi: null,\n    unicodeRange: null,\n    unitsPerEm: number,\n    values: null,\n    vAlphabetic: number,\n    vMathematical: number,\n    vectorEffect: null,\n    vHanging: number,\n    vIdeographic: number,\n    version: null,\n    vertAdvY: number,\n    vertOriginX: number,\n    vertOriginY: number,\n    viewBox: null,\n    viewTarget: null,\n    visibility: null,\n    width: null,\n    widths: null,\n    wordSpacing: null,\n    writingMode: null,\n    x: null,\n    x1: null,\n    x2: null,\n    xChannelSelector: null,\n    xHeight: number,\n    y: null,\n    y1: null,\n    y2: null,\n    yChannelSelector: null,\n    z: null,\n    zoomAndPan: null\n  }\n})\n", "/**\n * @typedef {import('./util/schema.js').Schema} Schema\n */\n\nimport {normalize} from './normalize.js'\nimport {DefinedInfo} from './util/defined-info.js'\nimport {Info} from './util/info.js'\n\nconst valid = /^data[-\\w.:]+$/i\nconst dash = /-[a-z]/g\nconst cap = /[A-Z]/g\n\n/**\n * @param {Schema} schema\n * @param {string} value\n * @returns {Info}\n */\nexport function find(schema, value) {\n  const normal = normalize(value)\n  let prop = value\n  let Type = Info\n\n  if (normal in schema.normal) {\n    return schema.property[schema.normal[normal]]\n  }\n\n  if (normal.length > 4 && normal.slice(0, 4) === 'data' && valid.test(value)) {\n    // Attribute or property.\n    if (value.charAt(4) === '-') {\n      // Turn it into a property.\n      const rest = value.slice(5).replace(dash, camelcase)\n      prop = 'data' + rest.charAt(0).toUpperCase() + rest.slice(1)\n    } else {\n      // Turn it into an attribute.\n      const rest = value.slice(4)\n\n      if (!dash.test(rest)) {\n        let dashes = rest.replace(cap, kebab)\n\n        if (dashes.charAt(0) !== '-') {\n          dashes = '-' + dashes\n        }\n\n        value = 'data' + dashes\n      }\n    }\n\n    Type = DefinedInfo\n  }\n\n  return new Type(prop, value)\n}\n\n/**\n * @param {string} $0\n * @returns {string}\n */\nfunction kebab($0) {\n  return '-' + $0.toLowerCase()\n}\n\n/**\n * @param {string} $0\n * @returns {string}\n */\nfunction camelcase($0) {\n  return $0.charAt(1).toUpperCase()\n}\n", "/**\n * @typedef {import('./lib/util/info.js').Info} Info\n * @typedef {import('./lib/util/schema.js').Schema} Schema\n */\n\nimport {merge} from './lib/util/merge.js'\nimport {xlink} from './lib/xlink.js'\nimport {xml} from './lib/xml.js'\nimport {xmlns} from './lib/xmlns.js'\nimport {aria} from './lib/aria.js'\nimport {html as htmlBase} from './lib/html.js'\nimport {svg as svgBase} from './lib/svg.js'\n\nexport {find} from './lib/find.js'\nexport {hastToReact} from './lib/hast-to-react.js'\nexport {normalize} from './lib/normalize.js'\nexport const html = merge([xml, xlink, xmlns, aria, htmlBase], 'html')\nexport const svg = merge([xml, xlink, xmlns, aria, svgBase], 'svg')\n", "/**\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('hast').Element} Element\n */\n\nconst search = /[#.]/g\n\n/**\n * Create a hast element from a simple CSS selector.\n *\n * @template {string} Selector\n *   Type of selector.\n * @template {string} [DefaultTagName='div']\n *   Type of default tag name.\n * @param {Selector | null | undefined} [selector]\n *   Simple CSS selector.\n *\n *   Can contain a tag name (`foo`), classes (`.bar`), and an ID (`#baz`).\n *   Multiple classes are allowed.\n *   Uses the last ID if multiple IDs are found.\n * @param {DefaultTagName | null | undefined} [defaultTagName='div']\n *   Tag name to use if `selector` does not specify one (default: `'div'`).\n * @returns {Element & {tagName: import('./extract.js').ExtractTagName<Selector, DefaultTagName>}}\n *   Built element.\n */\nexport function parseSelector(selector, defaultTagName) {\n  const value = selector || ''\n  /** @type {Properties} */\n  const props = {}\n  let start = 0\n  /** @type {string | undefined} */\n  let previous\n  /** @type {string | undefined} */\n  let tagName\n\n  while (start < value.length) {\n    search.lastIndex = start\n    const match = search.exec(value)\n    const subvalue = value.slice(start, match ? match.index : value.length)\n\n    if (subvalue) {\n      if (!previous) {\n        tagName = subvalue\n      } else if (previous === '#') {\n        props.id = subvalue\n      } else if (Array.isArray(props.className)) {\n        props.className.push(subvalue)\n      } else {\n        props.className = [subvalue]\n      }\n\n      start += subvalue.length\n    }\n\n    if (match) {\n      previous = match[0]\n      start++\n    }\n  }\n\n  return {\n    type: 'element',\n    // @ts-expect-error: fine.\n    tagName: tagName || defaultTagName || 'div',\n    properties: props,\n    children: []\n  }\n}\n", "/**\n * Parse space-separated tokens to an array of strings.\n *\n * @param {string} value\n *   Space-separated tokens.\n * @returns {Array<string>}\n *   List of tokens.\n */\nexport function parse(value) {\n  const input = String(value || '').trim()\n  return input ? input.split(/[ \\t\\n\\r\\f]+/g) : []\n}\n\n/**\n * Serialize an array of strings as space separated-tokens.\n *\n * @param {Array<string|number>} values\n *   List of tokens.\n * @returns {string}\n *   Space-separated tokens.\n */\nexport function stringify(values) {\n  return values.join(' ').trim()\n}\n", "/**\n * @typedef Options\n *   Configuration for `stringify`.\n * @property {boolean} [padLeft=true]\n *   Whether to pad a space before a token.\n * @property {boolean} [padRight=false]\n *   Whether to pad a space after a token.\n */\n\n/**\n * @typedef {Options} StringifyOptions\n *   Please use `StringifyOptions` instead.\n */\n\n/**\n * Parse comma-separated tokens to an array.\n *\n * @param {string} value\n *   Comma-separated tokens.\n * @returns {Array<string>}\n *   List of tokens.\n */\nexport function parse(value) {\n  /** @type {Array<string>} */\n  const tokens = []\n  const input = String(value || '')\n  let index = input.indexOf(',')\n  let start = 0\n  /** @type {boolean} */\n  let end = false\n\n  while (!end) {\n    if (index === -1) {\n      index = input.length\n      end = true\n    }\n\n    const token = input.slice(start, index).trim()\n\n    if (token || !end) {\n      tokens.push(token)\n    }\n\n    start = index + 1\n    index = input.indexOf(',', start)\n  }\n\n  return tokens\n}\n\n/**\n * Serialize an array of strings or numbers to comma-separated tokens.\n *\n * @param {Array<string|number>} values\n *   List of tokens.\n * @param {Options} [options]\n *   Configuration for `stringify` (optional).\n * @returns {string}\n *   Comma-separated tokens.\n */\nexport function stringify(values, options) {\n  const settings = options || {}\n\n  // Ensure the last empty entry is seen.\n  const input = values[values.length - 1] === '' ? [...values, ''] : values\n\n  return input\n    .join(\n      (settings.padRight ? ' ' : '') +\n        ',' +\n        (settings.padLeft === false ? '' : ' ')\n    )\n    .trim()\n}\n", "/**\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Content} Content\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('property-information').Info} Info\n * @typedef {import('property-information').Schema} Schema\n */\n\n/**\n * @typedef {Content | Root} Node\n *   Any concrete `hast` node.\n * @typedef {Root | Element} HResult\n *   Result from a `h` (or `s`) call.\n *\n * @typedef {string | number} HStyleValue\n *   Value for a CSS style field.\n * @typedef {Record<string, HStyleValue>} HStyle\n *   Supported value of a `style` prop.\n * @typedef {string | number | boolean | null | undefined} HPrimitiveValue\n *   Primitive property value.\n * @typedef {Array<string | number>} HArrayValue\n *   List of property values for space- or comma separated values (such as `className`).\n * @typedef {HPrimitiveValue | HArrayValue} HPropertyValue\n *   Primitive value or list value.\n * @typedef {{[property: string]: HPropertyValue | HStyle}} HProperties\n *   Acceptable value for element properties.\n *\n * @typedef {string | number | null | undefined} HPrimitiveChild\n *   Primitive children, either ignored (nullish), or turned into text nodes.\n * @typedef {Array<Node | HPrimitiveChild>} HArrayChild\n *   List of children.\n * @typedef {Node | HPrimitiveChild | HArrayChild} HChild\n *   Acceptable child value.\n */\n\nimport {find, normalize} from 'property-information'\nimport {parseSelector} from 'hast-util-parse-selector'\nimport {parse as spaces} from 'space-separated-tokens'\nimport {parse as commas} from 'comma-separated-tokens'\n\nconst buttonTypes = new Set(['menu', 'submit', 'reset', 'button'])\n\nconst own = {}.hasOwnProperty\n\n/**\n * @param {Schema} schema\n * @param {string} defaultTagName\n * @param {Array<string>} [caseSensitive]\n */\nexport function core(schema, defaultTagName, caseSensitive) {\n  const adjust = caseSensitive && createAdjustMap(caseSensitive)\n\n  const h =\n    /**\n     * @type {{\n     *   (): Root\n     *   (selector: null | undefined, ...children: Array<HChild>): Root\n     *   (selector: string, properties?: HProperties, ...children: Array<HChild>): Element\n     *   (selector: string, ...children: Array<HChild>): Element\n     * }}\n     */\n    (\n      /**\n       * Hyperscript compatible DSL for creating virtual hast trees.\n       *\n       * @param {string | null} [selector]\n       * @param {HProperties | HChild} [properties]\n       * @param {Array<HChild>} children\n       * @returns {HResult}\n       */\n      function (selector, properties, ...children) {\n        let index = -1\n        /** @type {HResult} */\n        let node\n\n        if (selector === undefined || selector === null) {\n          node = {type: 'root', children: []}\n          // @ts-expect-error Properties are not supported for roots.\n          children.unshift(properties)\n        } else {\n          node = parseSelector(selector, defaultTagName)\n          // Normalize the name.\n          node.tagName = node.tagName.toLowerCase()\n          if (adjust && own.call(adjust, node.tagName)) {\n            node.tagName = adjust[node.tagName]\n          }\n\n          // Handle props.\n          if (isProperties(properties, node.tagName)) {\n            /** @type {string} */\n            let key\n\n            for (key in properties) {\n              if (own.call(properties, key)) {\n                // @ts-expect-error `node.properties` is set.\n                addProperty(schema, node.properties, key, properties[key])\n              }\n            }\n          } else {\n            children.unshift(properties)\n          }\n        }\n\n        // Handle children.\n        while (++index < children.length) {\n          addChild(node.children, children[index])\n        }\n\n        if (node.type === 'element' && node.tagName === 'template') {\n          node.content = {type: 'root', children: node.children}\n          node.children = []\n        }\n\n        return node\n      }\n    )\n\n  return h\n}\n\n/**\n * @param {HProperties | HChild} value\n * @param {string} name\n * @returns {value is HProperties}\n */\nfunction isProperties(value, name) {\n  if (\n    value === null ||\n    value === undefined ||\n    typeof value !== 'object' ||\n    Array.isArray(value)\n  ) {\n    return false\n  }\n\n  if (name === 'input' || !value.type || typeof value.type !== 'string') {\n    return true\n  }\n\n  if ('children' in value && Array.isArray(value.children)) {\n    return false\n  }\n\n  if (name === 'button') {\n    return buttonTypes.has(value.type.toLowerCase())\n  }\n\n  return !('value' in value)\n}\n\n/**\n * @param {Schema} schema\n * @param {Properties} properties\n * @param {string} key\n * @param {HStyle | HPropertyValue} value\n * @returns {void}\n */\nfunction addProperty(schema, properties, key, value) {\n  const info = find(schema, key)\n  let index = -1\n  /** @type {HPropertyValue} */\n  let result\n\n  // Ignore nullish and NaN values.\n  if (value === undefined || value === null) return\n\n  if (typeof value === 'number') {\n    // Ignore NaN.\n    if (Number.isNaN(value)) return\n\n    result = value\n  }\n  // Booleans.\n  else if (typeof value === 'boolean') {\n    result = value\n  }\n  // Handle list values.\n  else if (typeof value === 'string') {\n    if (info.spaceSeparated) {\n      result = spaces(value)\n    } else if (info.commaSeparated) {\n      result = commas(value)\n    } else if (info.commaOrSpaceSeparated) {\n      result = spaces(commas(value).join(' '))\n    } else {\n      result = parsePrimitive(info, info.property, value)\n    }\n  } else if (Array.isArray(value)) {\n    result = value.concat()\n  } else {\n    result = info.property === 'style' ? style(value) : String(value)\n  }\n\n  if (Array.isArray(result)) {\n    /** @type {Array<string | number>} */\n    const finalResult = []\n\n    while (++index < result.length) {\n      // @ts-expect-error Assume no booleans in array.\n      finalResult[index] = parsePrimitive(info, info.property, result[index])\n    }\n\n    result = finalResult\n  }\n\n  // Class names (which can be added both on the `selector` and here).\n  if (info.property === 'className' && Array.isArray(properties.className)) {\n    // @ts-expect-error Assume no booleans in `className`.\n    result = properties.className.concat(result)\n  }\n\n  properties[info.property] = result\n}\n\n/**\n * @param {Array<Content>} nodes\n * @param {HChild} value\n * @returns {void}\n */\nfunction addChild(nodes, value) {\n  let index = -1\n\n  if (value === undefined || value === null) {\n    // Empty.\n  } else if (typeof value === 'string' || typeof value === 'number') {\n    nodes.push({type: 'text', value: String(value)})\n  } else if (Array.isArray(value)) {\n    while (++index < value.length) {\n      addChild(nodes, value[index])\n    }\n  } else if (typeof value === 'object' && 'type' in value) {\n    if (value.type === 'root') {\n      addChild(nodes, value.children)\n    } else {\n      nodes.push(value)\n    }\n  } else {\n    throw new Error('Expected node, nodes, or string, got `' + value + '`')\n  }\n}\n\n/**\n * Parse a single primitives.\n *\n * @param {Info} info\n * @param {string} name\n * @param {HPrimitiveValue} value\n * @returns {HPrimitiveValue}\n */\nfunction parsePrimitive(info, name, value) {\n  if (typeof value === 'string') {\n    if (info.number && value && !Number.isNaN(Number(value))) {\n      return Number(value)\n    }\n\n    if (\n      (info.boolean || info.overloadedBoolean) &&\n      (value === '' || normalize(value) === normalize(name))\n    ) {\n      return true\n    }\n  }\n\n  return value\n}\n\n/**\n * Serialize a `style` object as a string.\n *\n * @param {HStyle} value\n *   Style object.\n * @returns {string}\n *   CSS string.\n */\nfunction style(value) {\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {string} */\n  let key\n\n  for (key in value) {\n    if (own.call(value, key)) {\n      result.push([key, value[key]].join(': '))\n    }\n  }\n\n  return result.join('; ')\n}\n\n/**\n * Create a map to adjust casing.\n *\n * @param {Array<string>} values\n *   List of properly cased keys.\n * @returns {Record<string, string>}\n *   Map of lowercase keys to uppercase keys.\n */\nfunction createAdjustMap(values) {\n  /** @type {Record<string, string>} */\n  const result = {}\n  let index = -1\n\n  while (++index < values.length) {\n    result[values[index].toLowerCase()] = values[index]\n  }\n\n  return result\n}\n", "export const svgCaseSensitiveTagNames = [\n  'altGlyph',\n  'altGlyphDef',\n  'altGlyphItem',\n  'animateColor',\n  'animateMotion',\n  'animateTransform',\n  'clipPath',\n  'feBlend',\n  'feColorMatrix',\n  'feComponentTransfer',\n  'feComposite',\n  'feConvolveMatrix',\n  'feDiffuseLighting',\n  'feDisplacementMap',\n  'feDistantLight',\n  'feDropShadow',\n  'feFlood',\n  'feFuncA',\n  'feFuncB',\n  'feFuncG',\n  'feFuncR',\n  'feGaussianBlur',\n  'feImage',\n  'feMerge',\n  'feMergeNode',\n  'feMorphology',\n  'feOffset',\n  'fePointLight',\n  'feSpecularLighting',\n  'feSpotLight',\n  'feTile',\n  'feTurbulence',\n  'foreignObject',\n  'glyphRef',\n  'linearGradient',\n  'radialGradient',\n  'solidColor',\n  'textArea',\n  'textPath'\n]\n", "/**\n * @typedef {import('./core.js').HChild} Child\n *   Acceptable child value.\n * @typedef {import('./core.js').HProperties} Properties\n *   Acceptable value for element properties.\n * @typedef {import('./core.js').HResult} Result\n *   Result from a `h` (or `s`) call.\n *\n * @typedef {import('./jsx-classic.js').Element} s.JSX.Element\n * @typedef {import('./jsx-classic.js').IntrinsicAttributes} s.JSX.IntrinsicAttributes\n * @typedef {import('./jsx-classic.js').IntrinsicElements} s.JSX.IntrinsicElements\n * @typedef {import('./jsx-classic.js').ElementChildrenAttribute} s.JSX.ElementChildrenAttribute\n */\n\nimport {svg} from 'property-information'\nimport {core} from './core.js'\nimport {svgCaseSensitiveTagNames} from './svg-case-sensitive-tag-names.js'\n\nexport const s = core(svg, 'g', svgCaseSensitiveTagNames)\n", "import {s} from 'hastscript'\n\nimport {random as createId} from '@tracespace/xml-id'\nimport type {\n  ImageGraphic,\n  ImageShape,\n  ImagePath,\n  ImageRegion,\n  PathSegment,\n  Shape,\n} from '@tracespace/plotter'\nimport {\n  BoundingBox,\n  positionsEqual,\n  IMAGE_SHAPE,\n  IMAGE_PATH,\n  CIRCLE,\n  RECTANGLE,\n  POLYGON,\n  OUTLINE,\n  LAYERED_SHAPE,\n  LINE,\n  ARC,\n} from '@tracespace/plotter'\n\nimport type {SvgElement} from './types'\n\nexport function renderGraphic(node: ImageGraphic): SvgElement {\n  if (node.type === IMAGE_SHAPE) {\n    return renderShape(node)\n  }\n\n  return renderPath(node)\n}\n\nexport function renderShape(node: ImageShape): SvgElement {\n  const {shape} = node\n\n  return shapeToElement(shape)\n}\n\nexport function shapeToElement(shape: Shape): SvgElement {\n  switch (shape.type) {\n    case CIRCLE: {\n      const {cx, cy, r} = shape\n      return s('circle', {cx, cy: -cy, r})\n    }\n\n    case RECTANGLE: {\n      const {x, y, xSize: width, ySize: height, r} = shape\n      return s('rect', {\n        x,\n        y: -y - height,\n        width,\n        height,\n        rx: r,\n        ry: r,\n      })\n    }\n\n    case POLYGON: {\n      const points = shape.points.map(([x, y]) => `${x},${-y}`).join(' ')\n\n      return s('polygon', {points})\n    }\n\n    case OUTLINE: {\n      return s('path', {d: segmentsToPathData(shape.segments)})\n    }\n\n    case LAYERED_SHAPE: {\n      const boundingBox = BoundingBox.fromShape(shape)\n      const clipIdBase = createId()\n      const defs: SvgElement[] = []\n      let children: SvgElement[] = []\n\n      for (const [i, layerShape] of shape.shapes.entries()) {\n        if (layerShape.erase && !BoundingBox.isEmpty(boundingBox)) {\n          const clipId = `${clipIdBase}__${i}`\n\n          defs.push(s('clipPath', {id: clipId}, [shapeToElement(layerShape)]))\n          children = [s('g', {clipPath: `url(#${clipId})`}, children)]\n        } else {\n          children.push(shapeToElement(layerShape))\n        }\n      }\n\n      if (defs.length > 0) children.unshift(s('defs', defs))\n      if (children.length === 1) return children[0]\n      return s('g', children)\n    }\n\n    default: {\n      return s('g')\n    }\n  }\n}\n\nexport function renderPath(node: ImagePath | ImageRegion): SvgElement {\n  const pathData = segmentsToPathData(node.segments)\n  const props =\n    node.type === IMAGE_PATH ? {strokeWidth: node.width, fill: 'none'} : {}\n\n  return s('path', {...props, d: pathData})\n}\n\nfunction segmentsToPathData(segments: PathSegment[]): string {\n  const pathCommands: string[] = []\n\n  for (const [i, next] of segments.entries()) {\n    const previous = segments[i - 1]\n    const {start, end} = next\n\n    if (!previous || !positionsEqual(previous.end, start)) {\n      pathCommands.push(`M${start[0]} ${-start[1]}`)\n    }\n\n    if (next.type === LINE) {\n      pathCommands.push(`L${end[0]} ${-end[1]}`)\n    } else if (next.type === ARC) {\n      const sweep = next.end[2] - next.start[2]\n      const absSweep = Math.abs(sweep)\n      const {center, radius} = next\n\n      // Sweep flag flipped from SVG value because Y-axis is positive-down\n      const sweepFlag = sweep < 0 ? '1' : '0'\n      let largeFlag = absSweep <= Math.PI ? '0' : '1'\n\n      // A full circle needs two SVG arcs to draw\n      if (absSweep === 2 * Math.PI) {\n        const [mx, my] = [2 * center[0] - end[0], -(2 * center[1] - end[1])]\n        largeFlag = '0'\n        pathCommands.push(`A${radius} ${radius} 0 0 ${sweepFlag} ${mx} ${my}`)\n      }\n\n      pathCommands.push(\n        `A${radius} ${radius} 0 ${largeFlag} ${sweepFlag} ${end[0]} ${-end[1]}`\n      )\n    }\n  }\n\n  return pathCommands.join('')\n}\n", "import {s} from 'hastscript'\n\nimport type {ImageTree, SizeEnvelope} from '@tracespace/plotter'\nimport {BoundingBox} from '@tracespace/plotter'\n\nimport {renderGraphic} from './render'\nimport type {SvgElement, ViewBox} from './types'\n\nexport {renderGraphic} from './render'\n\nexport type {SvgElement, ViewBox} from './types'\n\nexport const BASE_SVG_PROPS = {\n  version: '1.1',\n  xmlns: 'http://www.w3.org/2000/svg',\n  'xmlns:xlink': 'http://www.w3.org/1999/xlink',\n}\n\nexport const BASE_IMAGE_PROPS = {\n  'stroke-linecap': 'round',\n  'stroke-linejoin': 'round',\n  'stroke-width': '0',\n  'fill-rule': 'evenodd',\n  'clip-rule': 'evenodd',\n  fill: 'currentColor',\n  stroke: 'currentColor',\n}\n\nexport function render(image: ImageTree, viewBox?: ViewBox): SvgElement {\n  const {units, size, children} = image\n\n  viewBox = viewBox ?? sizeToViewBox(size)\n\n  return s(\n    'svg',\n    {\n      ...BASE_SVG_PROPS,\n      ...BASE_IMAGE_PROPS,\n      viewBox: viewBox.join(' '),\n      width: `${viewBox[2]}${units}`,\n      height: `${viewBox[3]}${units}`,\n    },\n    children.map(renderGraphic)\n  )\n}\n\nexport function renderFragment(image: ImageTree): SvgElement {\n  return s('g', {}, image.children.map(renderGraphic))\n}\n\nexport function sizeToViewBox(size: SizeEnvelope): ViewBox {\n  return BoundingBox.isEmpty(size)\n    ? [0, 0, 0, 0]\n    : [size[0], -size[3], size[2] - size[0], size[3] - size[1]]\n}\n", "import type {LayerTestMatch, GerberCad} from './types'\n\nexport function getCommonCad(matches: LayerTestMatch[]): GerberCad {\n  let mode: GerberCad = null\n  let modeCount = 0\n  const countsByCad: Partial<Record<string, number>> = {}\n\n  for (const match of matches) {\n    const {cad} = match\n    if (cad !== null) {\n      const count = (countsByCad[cad] ?? 0) + 1\n      if (count > modeCount) {\n        modeCount = count\n        mode = cad\n      }\n\n      countsByCad[cad] = count\n    }\n  }\n\n  return mode\n}\n", "// Layer types\nexport const TYPE_COPPER = 'copper'\nexport const TYPE_SOLDERMASK = 'soldermask'\nexport const TYPE_SILKSCREEN = 'silkscreen'\nexport const TYPE_SOLDERPASTE = 'solderpaste'\nexport const TYPE_DRILL = 'drill'\nexport const TYPE_OUTLINE = 'outline'\nexport const TYPE_DRAWING = 'drawing'\n\n// Board sides\nexport const SIDE_TOP = 'top'\nexport const SIDE_BOTTOM = 'bottom'\nexport const SIDE_INNER = 'inner'\nexport const SIDE_ALL = 'all'\n\n// Cad packages\n// internal use only, for now\nexport const CAD_KICAD = 'kicad'\nexport const CAD_ALTIUM = 'altium'\nexport const CAD_ALLEGRO = 'allegro'\nexport const CAD_EAGLE = 'eagle'\nexport const CAD_EAGLE_LEGACY = 'eagle-legacy'\nexport const CAD_EAGLE_OSHPARK = 'eagle-oshpark'\nexport const CAD_EAGLE_PCBNG = 'eagle-pcbng'\nexport const CAD_GEDA_PCB = 'geda-pcb'\nexport const CAD_ORCAD = 'orcad'\nexport const CAD_DIPTRACE = 'diptrace'\n", "import {\n  TYPE_COPPER,\n  TYPE_SOLDERMASK,\n  TYPE_SILKSCREEN,\n  TYPE_SOLDERPASTE,\n  TYPE_DRILL,\n  TYPE_OUTLINE,\n  TYPE_DRAWING,\n  SIDE_TOP,\n  SIDE_BOTTOM,\n  SIDE_INNER,\n  SIDE_ALL,\n  CAD_KICAD,\n  CAD_ALTIUM,\n  CAD_ALLEGRO,\n  CAD_EAGLE,\n  CAD_EAGLE_LEGACY,\n  CAD_EAGLE_OSHPARK,\n  CAD_EAGLE_PCBNG,\n  CAD_GEDA_PCB,\n  CAD_ORCAD,\n  CAD_DIPTRACE,\n} from './constants'\n\nimport type {LayerType} from './types'\n\nexport const layerTypes: LayerType[] = [\n  // High-priority non-matches\n  {\n    type: null,\n    side: null,\n    matchers: [\n      // Eagle gerber generation metadata\n      {\n        ext: 'gpi',\n        cad: [CAD_EAGLE, CAD_EAGLE_LEGACY, CAD_EAGLE_OSHPARK, CAD_EAGLE_PCBNG],\n      },\n      // Eagle drill generation metadata\n      {\n        ext: 'dri',\n        cad: [CAD_EAGLE, CAD_EAGLE_LEGACY, CAD_EAGLE_OSHPARK, CAD_EAGLE_PCBNG],\n      },\n      // General data/BOM files\n      {ext: 'csv', cad: null},\n      // Pick-n-place BOMs\n      {match: /pnp_bom/, cad: CAD_EAGLE_PCBNG},\n    ],\n  },\n  {\n    type: TYPE_COPPER,\n    side: SIDE_TOP,\n    matchers: [\n      {ext: 'cmp', cad: CAD_EAGLE_LEGACY},\n      {ext: 'top', cad: [CAD_EAGLE_LEGACY, CAD_ORCAD]},\n      {ext: 'gtl', cad: [CAD_KICAD, CAD_ALTIUM]},\n      {ext: 'toplayer\\\\.ger', cad: CAD_EAGLE_OSHPARK},\n      {match: /top\\.\\w+$/, cad: [CAD_GEDA_PCB, CAD_DIPTRACE]},\n      {match: /f[._]cu/, cad: CAD_KICAD},\n      {match: /copper_top/, cad: CAD_EAGLE},\n      {match: /top_copper/, cad: CAD_EAGLE_PCBNG},\n      {match: /top copper/, cad: null},\n    ],\n  },\n  {\n    type: TYPE_SOLDERMASK,\n    side: SIDE_TOP,\n    matchers: [\n      {ext: 'stc', cad: CAD_EAGLE_LEGACY},\n      {ext: 'tsm', cad: CAD_EAGLE_LEGACY},\n      {ext: 'gts', cad: [CAD_KICAD, CAD_ALTIUM]},\n      {ext: 'smt', cad: CAD_ORCAD},\n      {ext: 'topsoldermask\\\\.ger', cad: CAD_EAGLE_OSHPARK},\n      {match: /topmask\\.\\w+$/, cad: [CAD_GEDA_PCB, CAD_DIPTRACE]},\n      {match: /f[._]mask/, cad: CAD_KICAD},\n      {match: /soldermask_top/, cad: CAD_EAGLE},\n      {match: /top_mask/, cad: CAD_EAGLE_PCBNG},\n      {match: /top solder resist/, cad: null},\n    ],\n  },\n  {\n    type: TYPE_SILKSCREEN,\n    side: SIDE_TOP,\n    matchers: [\n      {ext: 'plc', cad: CAD_EAGLE_LEGACY},\n      {ext: 'tsk', cad: CAD_EAGLE_LEGACY},\n      {ext: 'gto', cad: [CAD_KICAD, CAD_ALTIUM]},\n      {ext: 'sst', cad: CAD_ORCAD},\n      {ext: 'topsilkscreen\\\\.ger', cad: CAD_EAGLE_OSHPARK},\n      {match: /topsilk\\.\\w+$/, cad: [CAD_GEDA_PCB, CAD_DIPTRACE]},\n      {match: /f[._]silks/, cad: CAD_KICAD},\n      {match: /silkscreen_top/, cad: CAD_EAGLE},\n      {match: /top_silk/, cad: CAD_EAGLE_PCBNG},\n      {match: /top silk screen/, cad: null},\n    ],\n  },\n  {\n    type: TYPE_SOLDERPASTE,\n    side: SIDE_TOP,\n    matchers: [\n      {ext: 'crc', cad: CAD_EAGLE_LEGACY},\n      {ext: 'tsp', cad: CAD_EAGLE_LEGACY},\n      {ext: 'gtp', cad: [CAD_KICAD, CAD_ALTIUM]},\n      {ext: 'spt', cad: CAD_ORCAD},\n      {ext: 'tcream\\\\.ger', cad: CAD_EAGLE_OSHPARK},\n      {match: /toppaste\\.\\w+$/, cad: [CAD_GEDA_PCB, CAD_DIPTRACE]},\n      {match: /f[._]paste/, cad: CAD_KICAD},\n      {match: /solderpaste_top/, cad: CAD_EAGLE},\n      {match: /top_paste/, cad: CAD_EAGLE_PCBNG},\n    ],\n  },\n  {\n    type: TYPE_COPPER,\n    side: SIDE_BOTTOM,\n    matchers: [\n      {ext: 'sol', cad: CAD_EAGLE_LEGACY},\n      {ext: 'bot', cad: [CAD_EAGLE_LEGACY, CAD_ORCAD]},\n      {ext: 'gbl', cad: [CAD_KICAD, CAD_ALTIUM]},\n      {ext: 'bottomlayer\\\\.ger', cad: CAD_EAGLE_OSHPARK},\n      {match: /bottom\\.\\w+$/, cad: [CAD_GEDA_PCB, CAD_DIPTRACE]},\n      {match: /b[._]cu/, cad: CAD_KICAD},\n      {match: /copper_bottom/, cad: CAD_EAGLE},\n      {match: /bottom_copper/, cad: CAD_EAGLE_PCBNG},\n      {match: /bottom copper/, cad: null},\n    ],\n  },\n  {\n    type: TYPE_SOLDERMASK,\n    side: SIDE_BOTTOM,\n    matchers: [\n      {ext: 'sts', cad: CAD_EAGLE_LEGACY},\n      {ext: 'bsm', cad: CAD_EAGLE_LEGACY},\n      {ext: 'gbs', cad: [CAD_KICAD, CAD_ALTIUM]},\n      {ext: 'smb', cad: CAD_ORCAD},\n      {ext: 'bottomsoldermask\\\\.ger', cad: CAD_EAGLE_OSHPARK},\n      {match: /bottommask\\.\\w+$/, cad: [CAD_GEDA_PCB, CAD_DIPTRACE]},\n      {match: /b[._]mask/, cad: CAD_KICAD},\n      {match: /soldermask_bottom/, cad: CAD_EAGLE},\n      {match: /bottom_mask/, cad: CAD_EAGLE_PCBNG},\n      {match: /bottom solder resist/, cad: null},\n    ],\n  },\n  {\n    type: TYPE_SILKSCREEN,\n    side: SIDE_BOTTOM,\n    matchers: [\n      {ext: 'pls', cad: CAD_EAGLE_LEGACY},\n      {ext: 'bsk', cad: CAD_EAGLE_LEGACY},\n      {ext: 'gbo', cad: [CAD_KICAD, CAD_ALTIUM]},\n      {ext: 'ssb', cad: CAD_ORCAD},\n      {ext: 'bottomsilkscreen\\\\.ger', cad: CAD_EAGLE_OSHPARK},\n      {match: /bottomsilk\\.\\w+$/, cad: [CAD_GEDA_PCB, CAD_DIPTRACE]},\n      {match: /b[._]silks/, cad: CAD_KICAD},\n      {match: /silkscreen_bottom/, cad: CAD_EAGLE},\n      {match: /bottom_silk/, cad: CAD_EAGLE_PCBNG},\n      {match: /bottom silk screen/, cad: null},\n    ],\n  },\n  {\n    type: TYPE_SOLDERPASTE,\n    side: SIDE_BOTTOM,\n    matchers: [\n      {ext: 'crs', cad: CAD_EAGLE_LEGACY},\n      {ext: 'bsp', cad: CAD_EAGLE_LEGACY},\n      {ext: 'gbp', cad: [CAD_KICAD, CAD_ALTIUM]},\n      {ext: 'spb', cad: CAD_ORCAD},\n      {ext: 'bcream\\\\.ger', cad: CAD_EAGLE_OSHPARK},\n      {match: /bottompaste\\.\\w+$/, cad: [CAD_GEDA_PCB, CAD_DIPTRACE]},\n      {match: /b[._]paste/, cad: CAD_KICAD},\n      {match: /solderpaste_bottom/, cad: CAD_EAGLE},\n      {match: /bottom_paste/, cad: CAD_EAGLE_PCBNG},\n    ],\n  },\n  {\n    type: TYPE_COPPER,\n    side: SIDE_INNER,\n    matchers: [\n      {ext: 'ly\\\\d+', cad: CAD_EAGLE_LEGACY},\n      {ext: 'gp?\\\\d+', cad: [CAD_KICAD, CAD_ALTIUM]},\n      {ext: 'in\\\\d+', cad: CAD_ORCAD},\n      {ext: 'internalplane\\\\d+\\\\.ger', cad: CAD_EAGLE_OSHPARK},\n      {match: /in(?:ner)?\\d+[._]cu/, cad: CAD_KICAD},\n      {match: /inner/, cad: CAD_DIPTRACE},\n    ],\n  },\n  {\n    type: TYPE_OUTLINE,\n    side: SIDE_ALL,\n    matchers: [\n      {ext: 'dim', cad: CAD_EAGLE_LEGACY},\n      {ext: 'mil', cad: CAD_EAGLE_LEGACY},\n      {ext: 'gml', cad: CAD_EAGLE_LEGACY},\n      {ext: 'gm\\\\d+', cad: [CAD_KICAD, CAD_ALTIUM]},\n      {ext: 'gko', cad: CAD_ALTIUM},\n      {ext: 'fab', cad: CAD_ORCAD},\n      {ext: 'drd', cad: CAD_ORCAD},\n      {match: /outline/, cad: [CAD_GEDA_PCB, CAD_EAGLE_PCBNG]},\n      {match: /boardoutline/, cad: [CAD_EAGLE_OSHPARK, CAD_DIPTRACE]},\n      {match: /edge[._]cuts/, cad: CAD_KICAD},\n      {match: /profile/, cad: CAD_EAGLE},\n      {match: /mechanical \\d+/, cad: null},\n    ],\n  },\n  {\n    type: TYPE_DRILL,\n    side: SIDE_ALL,\n    matchers: [\n      {ext: 'txt', cad: [CAD_EAGLE_LEGACY, CAD_ALTIUM]},\n      {\n        ext: 'xln',\n        cad: [CAD_EAGLE, CAD_EAGLE_LEGACY, CAD_EAGLE_OSHPARK],\n      },\n      {ext: 'exc', cad: CAD_EAGLE_LEGACY},\n      {ext: 'drd', cad: CAD_EAGLE_LEGACY},\n      {ext: 'drl', cad: [CAD_KICAD, CAD_DIPTRACE]},\n      {ext: 'tap', cad: CAD_ORCAD},\n      {ext: 'npt', cad: CAD_ORCAD},\n      {ext: 'plated-drill\\\\.cnc', cad: CAD_GEDA_PCB},\n      {match: /fab/, cad: CAD_GEDA_PCB},\n      {match: /npth/, cad: CAD_KICAD},\n      {match: /drill/, cad: CAD_EAGLE_PCBNG},\n    ],\n  },\n  {\n    type: TYPE_DRAWING,\n    side: null,\n    matchers: [\n      {ext: 'pos', cad: CAD_KICAD},\n      {ext: 'art', cad: CAD_ALLEGRO},\n      {ext: 'gbr', cad: null},\n      {ext: 'gbx', cad: null},\n      {ext: 'ger', cad: null},\n      {ext: 'pho', cad: null},\n    ],\n  },\n]\n", "import {layerTypes} from './layer-types'\nimport type {LayerTest} from './types'\n\nexport const matchers: LayerTest[] = layerTypes.flatMap(layer => {\n  return layer.matchers.flatMap(matcher => {\n    const cadList = Array.isArray(matcher.cad) ? matcher.cad : [matcher.cad]\n    const match =\n      'ext' in matcher\n        ? new RegExp('\\\\.' + matcher.ext + '$', 'i')\n        : new RegExp(matcher.match, 'i')\n\n    return cadList.map(cad => ({\n      type: layer.type,\n      side: layer.side,\n      match,\n      cad,\n    }))\n  })\n})\n", "import {matchers} from './matchers'\nimport type {LayerTestMatch} from './types'\n\nexport function getMatches(filename: string): LayerTestMatch[] {\n  return matchers\n    .map(m => (m.match.test(filename) ? {...m, filename} : null))\n    .filter((m: LayerTestMatch | null): m is LayerTestMatch => m !== null)\n}\n", "import {getCommonCad} from './get-common-cad'\nimport {getMatches} from './get-matches'\nimport {layerTypes} from './layer-types'\n\nimport type {\n  LayerIdentityMap,\n  ValidLayer,\n  ValidatedLayer,\n  LayerIdentity,\n  LayerTestMatch,\n  GerberType,\n  GerberSide,\n  GerberCad,\n} from './types'\n\nexport * from './constants'\nexport * from './types'\n\nexport function identifyLayers(filenames: string | string[]): LayerIdentityMap {\n  if (typeof filenames === 'string') filenames = [filenames]\n\n  const matches = filenames.flatMap(f => getMatches(f))\n  const commonCad = getCommonCad(matches)\n\n  return Object.fromEntries(\n    filenames.map(filename => {\n      const match = _selectMatch(matches, filename, commonCad)\n      const layerId = match\n        ? {type: match.type, side: match.side}\n        : {type: null, side: null}\n\n      return [filename, layerId]\n    })\n  )\n}\n\nexport function getAllLayers(): ValidLayer[] {\n  return layerTypes\n    .map(layer => ({type: layer.type, side: layer.side}))\n    .filter((layer): layer is ValidLayer => layer.type !== null)\n}\n\nexport function validate<T extends {side: string | null; type: string | null}>(\n  target: T\n): ValidatedLayer {\n  const valid = layerTypes.some(layer => {\n    return layer.side === target.side && layer.type === target.type\n  })\n\n  const validSide = layerTypes.some(layer => layer.side === target.side)\n  const validType = layerTypes.some(layer => layer.type === target.type)\n\n  return {\n    valid,\n    side: validSide ? (target.side as GerberSide) : null,\n    type: validType ? (target.type as GerberType) : null,\n  }\n}\n\nfunction _selectMatch(\n  matches: LayerTestMatch[],\n  filename: string,\n  cad: GerberCad\n): LayerIdentity | null {\n  const filenameMatches = matches.filter(match => match.filename === filename)\n  const result = filenameMatches.find(match => match.cad === cad)\n\n  return result ?? filenameMatches[0] ?? null\n}\n", "/**\n * @typedef {import('./info.js').Info} Info\n * @typedef {Record<string, Info>} Properties\n * @typedef {Record<string, string>} Normal\n */\n\nexport class Schema {\n  /**\n   * @constructor\n   * @param {Properties} property\n   * @param {Normal} normal\n   * @param {string} [space]\n   */\n  constructor(property, normal, space) {\n    this.property = property\n    this.normal = normal\n    if (space) {\n      this.space = space\n    }\n  }\n}\n\n/** @type {Properties} */\nSchema.prototype.property = {}\n/** @type {Normal} */\nSchema.prototype.normal = {}\n/** @type {string|null} */\nSchema.prototype.space = null\n", "/**\n * @typedef {import('./schema.js').Properties} Properties\n * @typedef {import('./schema.js').Normal} Normal\n */\n\nimport {Schema} from './schema.js'\n\n/**\n * @param {Schema[]} definitions\n * @param {string} [space]\n * @returns {Schema}\n */\nexport function merge(definitions, space) {\n  /** @type {Properties} */\n  const property = {}\n  /** @type {Normal} */\n  const normal = {}\n  let index = -1\n\n  while (++index < definitions.length) {\n    Object.assign(property, definitions[index].property)\n    Object.assign(normal, definitions[index].normal)\n  }\n\n  return new Schema(property, normal, space)\n}\n", "/**\n * @param {string} value\n * @returns {string}\n */\nexport function normalize(value) {\n  return value.toLowerCase()\n}\n", "export class Info {\n  /**\n   * @constructor\n   * @param {string} property\n   * @param {string} attribute\n   */\n  constructor(property, attribute) {\n    /** @type {string} */\n    this.property = property\n    /** @type {string} */\n    this.attribute = attribute\n  }\n}\n\n/** @type {string|null} */\nInfo.prototype.space = null\nInfo.prototype.boolean = false\nInfo.prototype.booleanish = false\nInfo.prototype.overloadedBoolean = false\nInfo.prototype.number = false\nInfo.prototype.commaSeparated = false\nInfo.prototype.spaceSeparated = false\nInfo.prototype.commaOrSpaceSeparated = false\nInfo.prototype.mustUseProperty = false\nInfo.prototype.defined = false\n", "let powers = 0\n\nexport const boolean = increment()\nexport const booleanish = increment()\nexport const overloadedBoolean = increment()\nexport const number = increment()\nexport const spaceSeparated = increment()\nexport const commaSeparated = increment()\nexport const commaOrSpaceSeparated = increment()\n\nfunction increment() {\n  return 2 ** ++powers\n}\n", "import {Info} from './info.js'\nimport * as types from './types.js'\n\n/** @type {Array<keyof types>} */\n// @ts-expect-error: hush.\nconst checks = Object.keys(types)\n\nexport class DefinedInfo extends Info {\n  /**\n   * @constructor\n   * @param {string} property\n   * @param {string} attribute\n   * @param {number|null} [mask]\n   * @param {string} [space]\n   */\n  constructor(property, attribute, mask, space) {\n    let index = -1\n\n    super(property, attribute)\n\n    mark(this, 'space', space)\n\n    if (typeof mask === 'number') {\n      while (++index < checks.length) {\n        const check = checks[index]\n        mark(this, checks[index], (mask & types[check]) === types[check])\n      }\n    }\n  }\n}\n\nDefinedInfo.prototype.defined = true\n\n/**\n * @param {DefinedInfo} values\n * @param {string} key\n * @param {unknown} value\n */\nfunction mark(values, key, value) {\n  if (value) {\n    // @ts-expect-error: assume `value` matches the expected value of `key`.\n    values[key] = value\n  }\n}\n", "/**\n * @typedef {import('./schema.js').Properties} Properties\n * @typedef {import('./schema.js').Normal} Normal\n *\n * @typedef {Record<string, string>} Attributes\n *\n * @typedef {Object} Definition\n * @property {Record<string, number|null>} properties\n * @property {(attributes: Attributes, property: string) => string} transform\n * @property {string} [space]\n * @property {Attributes} [attributes]\n * @property {Array<string>} [mustUseProperty]\n */\n\nimport {normalize} from '../normalize.js'\nimport {Schema} from './schema.js'\nimport {DefinedInfo} from './defined-info.js'\n\nconst own = {}.hasOwnProperty\n\n/**\n * @param {Definition} definition\n * @returns {Schema}\n */\nexport function create(definition) {\n  /** @type {Properties} */\n  const property = {}\n  /** @type {Normal} */\n  const normal = {}\n  /** @type {string} */\n  let prop\n\n  for (prop in definition.properties) {\n    if (own.call(definition.properties, prop)) {\n      const value = definition.properties[prop]\n      const info = new DefinedInfo(\n        prop,\n        definition.transform(definition.attributes || {}, prop),\n        value,\n        definition.space\n      )\n\n      if (\n        definition.mustUseProperty &&\n        definition.mustUseProperty.includes(prop)\n      ) {\n        info.mustUseProperty = true\n      }\n\n      property[prop] = info\n\n      normal[normalize(prop)] = prop\n      normal[normalize(info.attribute)] = prop\n    }\n  }\n\n  return new Schema(property, normal, definition.space)\n}\n", "import {create} from './util/create.js'\n\nexport const xlink = create({\n  space: 'xlink',\n  transform(_, prop) {\n    return 'xlink:' + prop.slice(5).toLowerCase()\n  },\n  properties: {\n    xLinkActuate: null,\n    xLinkArcRole: null,\n    xLinkHref: null,\n    xLinkRole: null,\n    xLinkShow: null,\n    xLinkTitle: null,\n    xLinkType: null\n  }\n})\n", "import {create} from './util/create.js'\n\nexport const xml = create({\n  space: 'xml',\n  transform(_, prop) {\n    return 'xml:' + prop.slice(3).toLowerCase()\n  },\n  properties: {xmlLang: null, xmlBase: null, xmlSpace: null}\n})\n", "/**\n * @param {Record<string, string>} attributes\n * @param {string} attribute\n * @returns {string}\n */\nexport function caseSensitiveTransform(attributes, attribute) {\n  return attribute in attributes ? attributes[attribute] : attribute\n}\n", "import {caseSensitiveTransform} from './case-sensitive-transform.js'\n\n/**\n * @param {Record<string, string>} attributes\n * @param {string} property\n * @returns {string}\n */\nexport function caseInsensitiveTransform(attributes, property) {\n  return caseSensitiveTransform(attributes, property.toLowerCase())\n}\n", "import {create} from './util/create.js'\nimport {caseInsensitiveTransform} from './util/case-insensitive-transform.js'\n\nexport const xmlns = create({\n  space: 'xmlns',\n  attributes: {xmlnsxlink: 'xmlns:xlink'},\n  transform: caseInsensitiveTransform,\n  properties: {xmlns: null, xmlnsXLink: null}\n})\n", "import {booleanish, number, spaceSeparated} from './util/types.js'\nimport {create} from './util/create.js'\n\nexport const aria = create({\n  transform(_, prop) {\n    return prop === 'role' ? prop : 'aria-' + prop.slice(4).toLowerCase()\n  },\n  properties: {\n    ariaActiveDescendant: null,\n    ariaAtomic: booleanish,\n    ariaAutoComplete: null,\n    ariaBusy: booleanish,\n    ariaChecked: booleanish,\n    ariaColCount: number,\n    ariaColIndex: number,\n    ariaColSpan: number,\n    ariaControls: spaceSeparated,\n    ariaCurrent: null,\n    ariaDescribedBy: spaceSeparated,\n    ariaDetails: null,\n    ariaDisabled: booleanish,\n    ariaDropEffect: spaceSeparated,\n    ariaErrorMessage: null,\n    ariaExpanded: booleanish,\n    ariaFlowTo: spaceSeparated,\n    ariaGrabbed: booleanish,\n    ariaHasPopup: null,\n    ariaHidden: booleanish,\n    ariaInvalid: null,\n    ariaKeyShortcuts: null,\n    ariaLabel: null,\n    ariaLabelledBy: spaceSeparated,\n    ariaLevel: number,\n    ariaLive: null,\n    ariaModal: booleanish,\n    ariaMultiLine: booleanish,\n    ariaMultiSelectable: booleanish,\n    ariaOrientation: null,\n    ariaOwns: spaceSeparated,\n    ariaPlaceholder: null,\n    ariaPosInSet: number,\n    ariaPressed: booleanish,\n    ariaReadOnly: booleanish,\n    ariaRelevant: null,\n    ariaRequired: booleanish,\n    ariaRoleDescription: spaceSeparated,\n    ariaRowCount: number,\n    ariaRowIndex: number,\n    ariaRowSpan: number,\n    ariaSelected: booleanish,\n    ariaSetSize: number,\n    ariaSort: null,\n    ariaValueMax: number,\n    ariaValueMin: number,\n    ariaValueNow: number,\n    ariaValueText: null,\n    role: null\n  }\n})\n", "import {\n  boolean,\n  overloadedBoolean,\n  booleanish,\n  number,\n  spaceSeparated,\n  commaSeparated\n} from './util/types.js'\nimport {create} from './util/create.js'\nimport {caseInsensitiveTransform} from './util/case-insensitive-transform.js'\n\nexport const html = create({\n  space: 'html',\n  attributes: {\n    acceptcharset: 'accept-charset',\n    classname: 'class',\n    htmlfor: 'for',\n    httpequiv: 'http-equiv'\n  },\n  transform: caseInsensitiveTransform,\n  mustUseProperty: ['checked', 'multiple', 'muted', 'selected'],\n  properties: {\n    // Standard Properties.\n    abbr: null,\n    accept: commaSeparated,\n    acceptCharset: spaceSeparated,\n    accessKey: spaceSeparated,\n    action: null,\n    allow: null,\n    allowFullScreen: boolean,\n    allowPaymentRequest: boolean,\n    allowUserMedia: boolean,\n    alt: null,\n    as: null,\n    async: boolean,\n    autoCapitalize: null,\n    autoComplete: spaceSeparated,\n    autoFocus: boolean,\n    autoPlay: boolean,\n    capture: boolean,\n    charSet: null,\n    checked: boolean,\n    cite: null,\n    className: spaceSeparated,\n    cols: number,\n    colSpan: null,\n    content: null,\n    contentEditable: booleanish,\n    controls: boolean,\n    controlsList: spaceSeparated,\n    coords: number | commaSeparated,\n    crossOrigin: null,\n    data: null,\n    dateTime: null,\n    decoding: null,\n    default: boolean,\n    defer: boolean,\n    dir: null,\n    dirName: null,\n    disabled: boolean,\n    download: overloadedBoolean,\n    draggable: booleanish,\n    encType: null,\n    enterKeyHint: null,\n    form: null,\n    formAction: null,\n    formEncType: null,\n    formMethod: null,\n    formNoValidate: boolean,\n    formTarget: null,\n    headers: spaceSeparated,\n    height: number,\n    hidden: boolean,\n    high: number,\n    href: null,\n    hrefLang: null,\n    htmlFor: spaceSeparated,\n    httpEquiv: spaceSeparated,\n    id: null,\n    imageSizes: null,\n    imageSrcSet: null,\n    inputMode: null,\n    integrity: null,\n    is: null,\n    isMap: boolean,\n    itemId: null,\n    itemProp: spaceSeparated,\n    itemRef: spaceSeparated,\n    itemScope: boolean,\n    itemType: spaceSeparated,\n    kind: null,\n    label: null,\n    lang: null,\n    language: null,\n    list: null,\n    loading: null,\n    loop: boolean,\n    low: number,\n    manifest: null,\n    max: null,\n    maxLength: number,\n    media: null,\n    method: null,\n    min: null,\n    minLength: number,\n    multiple: boolean,\n    muted: boolean,\n    name: null,\n    nonce: null,\n    noModule: boolean,\n    noValidate: boolean,\n    onAbort: null,\n    onAfterPrint: null,\n    onAuxClick: null,\n    onBeforeMatch: null,\n    onBeforePrint: null,\n    onBeforeUnload: null,\n    onBlur: null,\n    onCancel: null,\n    onCanPlay: null,\n    onCanPlayThrough: null,\n    onChange: null,\n    onClick: null,\n    onClose: null,\n    onContextLost: null,\n    onContextMenu: null,\n    onContextRestored: null,\n    onCopy: null,\n    onCueChange: null,\n    onCut: null,\n    onDblClick: null,\n    onDrag: null,\n    onDragEnd: null,\n    onDragEnter: null,\n    onDragExit: null,\n    onDragLeave: null,\n    onDragOver: null,\n    onDragStart: null,\n    onDrop: null,\n    onDurationChange: null,\n    onEmptied: null,\n    onEnded: null,\n    onError: null,\n    onFocus: null,\n    onFormData: null,\n    onHashChange: null,\n    onInput: null,\n    onInvalid: null,\n    onKeyDown: null,\n    onKeyPress: null,\n    onKeyUp: null,\n    onLanguageChange: null,\n    onLoad: null,\n    onLoadedData: null,\n    onLoadedMetadata: null,\n    onLoadEnd: null,\n    onLoadStart: null,\n    onMessage: null,\n    onMessageError: null,\n    onMouseDown: null,\n    onMouseEnter: null,\n    onMouseLeave: null,\n    onMouseMove: null,\n    onMouseOut: null,\n    onMouseOver: null,\n    onMouseUp: null,\n    onOffline: null,\n    onOnline: null,\n    onPageHide: null,\n    onPageShow: null,\n    onPaste: null,\n    onPause: null,\n    onPlay: null,\n    onPlaying: null,\n    onPopState: null,\n    onProgress: null,\n    onRateChange: null,\n    onRejectionHandled: null,\n    onReset: null,\n    onResize: null,\n    onScroll: null,\n    onScrollEnd: null,\n    onSecurityPolicyViolation: null,\n    onSeeked: null,\n    onSeeking: null,\n    onSelect: null,\n    onSlotChange: null,\n    onStalled: null,\n    onStorage: null,\n    onSubmit: null,\n    onSuspend: null,\n    onTimeUpdate: null,\n    onToggle: null,\n    onUnhandledRejection: null,\n    onUnload: null,\n    onVolumeChange: null,\n    onWaiting: null,\n    onWheel: null,\n    open: boolean,\n    optimum: number,\n    pattern: null,\n    ping: spaceSeparated,\n    placeholder: null,\n    playsInline: boolean,\n    poster: null,\n    preload: null,\n    readOnly: boolean,\n    referrerPolicy: null,\n    rel: spaceSeparated,\n    required: boolean,\n    reversed: boolean,\n    rows: number,\n    rowSpan: number,\n    sandbox: spaceSeparated,\n    scope: null,\n    scoped: boolean,\n    seamless: boolean,\n    selected: boolean,\n    shape: null,\n    size: number,\n    sizes: null,\n    slot: null,\n    span: number,\n    spellCheck: booleanish,\n    src: null,\n    srcDoc: null,\n    srcLang: null,\n    srcSet: null,\n    start: number,\n    step: null,\n    style: null,\n    tabIndex: number,\n    target: null,\n    title: null,\n    translate: null,\n    type: null,\n    typeMustMatch: boolean,\n    useMap: null,\n    value: booleanish,\n    width: number,\n    wrap: null,\n\n    // Legacy.\n    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis\n    align: null, // Several. Use CSS `text-align` instead,\n    aLink: null, // `<body>`. Use CSS `a:active {color}` instead\n    archive: spaceSeparated, // `<object>`. List of URIs to archives\n    axis: null, // `<td>` and `<th>`. Use `scope` on `<th>`\n    background: null, // `<body>`. Use CSS `background-image` instead\n    bgColor: null, // `<body>` and table elements. Use CSS `background-color` instead\n    border: number, // `<table>`. Use CSS `border-width` instead,\n    borderColor: null, // `<table>`. Use CSS `border-color` instead,\n    bottomMargin: number, // `<body>`\n    cellPadding: null, // `<table>`\n    cellSpacing: null, // `<table>`\n    char: null, // Several table elements. When `align=char`, sets the character to align on\n    charOff: null, // Several table elements. When `char`, offsets the alignment\n    classId: null, // `<object>`\n    clear: null, // `<br>`. Use CSS `clear` instead\n    code: null, // `<object>`\n    codeBase: null, // `<object>`\n    codeType: null, // `<object>`\n    color: null, // `<font>` and `<hr>`. Use CSS instead\n    compact: boolean, // Lists. Use CSS to reduce space between items instead\n    declare: boolean, // `<object>`\n    event: null, // `<script>`\n    face: null, // `<font>`. Use CSS instead\n    frame: null, // `<table>`\n    frameBorder: null, // `<iframe>`. Use CSS `border` instead\n    hSpace: number, // `<img>` and `<object>`\n    leftMargin: number, // `<body>`\n    link: null, // `<body>`. Use CSS `a:link {color: *}` instead\n    longDesc: null, // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`\n    lowSrc: null, // `<img>`. Use a `<picture>`\n    marginHeight: number, // `<body>`\n    marginWidth: number, // `<body>`\n    noResize: boolean, // `<frame>`\n    noHref: boolean, // `<area>`. Use no href instead of an explicit `nohref`\n    noShade: boolean, // `<hr>`. Use background-color and height instead of borders\n    noWrap: boolean, // `<td>` and `<th>`\n    object: null, // `<applet>`\n    profile: null, // `<head>`\n    prompt: null, // `<isindex>`\n    rev: null, // `<link>`\n    rightMargin: number, // `<body>`\n    rules: null, // `<table>`\n    scheme: null, // `<meta>`\n    scrolling: booleanish, // `<frame>`. Use overflow in the child context\n    standby: null, // `<object>`\n    summary: null, // `<table>`\n    text: null, // `<body>`. Use CSS `color` instead\n    topMargin: number, // `<body>`\n    valueType: null, // `<param>`\n    version: null, // `<html>`. Use a doctype.\n    vAlign: null, // Several. Use CSS `vertical-align` instead\n    vLink: null, // `<body>`. Use CSS `a:visited {color}` instead\n    vSpace: number, // `<img>` and `<object>`\n\n    // Non-standard Properties.\n    allowTransparency: null,\n    autoCorrect: null,\n    autoSave: null,\n    disablePictureInPicture: boolean,\n    disableRemotePlayback: boolean,\n    prefix: null,\n    property: null,\n    results: number,\n    security: null,\n    unselectable: null\n  }\n})\n", "import {\n  boolean,\n  number,\n  spaceSeparated,\n  commaSeparated,\n  commaOrSpaceSeparated\n} from './util/types.js'\nimport {create} from './util/create.js'\nimport {caseSensitiveTransform} from './util/case-sensitive-transform.js'\n\nexport const svg = create({\n  space: 'svg',\n  attributes: {\n    accentHeight: 'accent-height',\n    alignmentBaseline: 'alignment-baseline',\n    arabicForm: 'arabic-form',\n    baselineShift: 'baseline-shift',\n    capHeight: 'cap-height',\n    className: 'class',\n    clipPath: 'clip-path',\n    clipRule: 'clip-rule',\n    colorInterpolation: 'color-interpolation',\n    colorInterpolationFilters: 'color-interpolation-filters',\n    colorProfile: 'color-profile',\n    colorRendering: 'color-rendering',\n    crossOrigin: 'crossorigin',\n    dataType: 'datatype',\n    dominantBaseline: 'dominant-baseline',\n    enableBackground: 'enable-background',\n    fillOpacity: 'fill-opacity',\n    fillRule: 'fill-rule',\n    floodColor: 'flood-color',\n    floodOpacity: 'flood-opacity',\n    fontFamily: 'font-family',\n    fontSize: 'font-size',\n    fontSizeAdjust: 'font-size-adjust',\n    fontStretch: 'font-stretch',\n    fontStyle: 'font-style',\n    fontVariant: 'font-variant',\n    fontWeight: 'font-weight',\n    glyphName: 'glyph-name',\n    glyphOrientationHorizontal: 'glyph-orientation-horizontal',\n    glyphOrientationVertical: 'glyph-orientation-vertical',\n    hrefLang: 'hreflang',\n    horizAdvX: 'horiz-adv-x',\n    horizOriginX: 'horiz-origin-x',\n    horizOriginY: 'horiz-origin-y',\n    imageRendering: 'image-rendering',\n    letterSpacing: 'letter-spacing',\n    lightingColor: 'lighting-color',\n    markerEnd: 'marker-end',\n    markerMid: 'marker-mid',\n    markerStart: 'marker-start',\n    navDown: 'nav-down',\n    navDownLeft: 'nav-down-left',\n    navDownRight: 'nav-down-right',\n    navLeft: 'nav-left',\n    navNext: 'nav-next',\n    navPrev: 'nav-prev',\n    navRight: 'nav-right',\n    navUp: 'nav-up',\n    navUpLeft: 'nav-up-left',\n    navUpRight: 'nav-up-right',\n    onAbort: 'onabort',\n    onActivate: 'onactivate',\n    onAfterPrint: 'onafterprint',\n    onBeforePrint: 'onbeforeprint',\n    onBegin: 'onbegin',\n    onCancel: 'oncancel',\n    onCanPlay: 'oncanplay',\n    onCanPlayThrough: 'oncanplaythrough',\n    onChange: 'onchange',\n    onClick: 'onclick',\n    onClose: 'onclose',\n    onCopy: 'oncopy',\n    onCueChange: 'oncuechange',\n    onCut: 'oncut',\n    onDblClick: 'ondblclick',\n    onDrag: 'ondrag',\n    onDragEnd: 'ondragend',\n    onDragEnter: 'ondragenter',\n    onDragExit: 'ondragexit',\n    onDragLeave: 'ondragleave',\n    onDragOver: 'ondragover',\n    onDragStart: 'ondragstart',\n    onDrop: 'ondrop',\n    onDurationChange: 'ondurationchange',\n    onEmptied: 'onemptied',\n    onEnd: 'onend',\n    onEnded: 'onended',\n    onError: 'onerror',\n    onFocus: 'onfocus',\n    onFocusIn: 'onfocusin',\n    onFocusOut: 'onfocusout',\n    onHashChange: 'onhashchange',\n    onInput: 'oninput',\n    onInvalid: 'oninvalid',\n    onKeyDown: 'onkeydown',\n    onKeyPress: 'onkeypress',\n    onKeyUp: 'onkeyup',\n    onLoad: 'onload',\n    onLoadedData: 'onloadeddata',\n    onLoadedMetadata: 'onloadedmetadata',\n    onLoadStart: 'onloadstart',\n    onMessage: 'onmessage',\n    onMouseDown: 'onmousedown',\n    onMouseEnter: 'onmouseenter',\n    onMouseLeave: 'onmouseleave',\n    onMouseMove: 'onmousemove',\n    onMouseOut: 'onmouseout',\n    onMouseOver: 'onmouseover',\n    onMouseUp: 'onmouseup',\n    onMouseWheel: 'onmousewheel',\n    onOffline: 'onoffline',\n    onOnline: 'ononline',\n    onPageHide: 'onpagehide',\n    onPageShow: 'onpageshow',\n    onPaste: 'onpaste',\n    onPause: 'onpause',\n    onPlay: 'onplay',\n    onPlaying: 'onplaying',\n    onPopState: 'onpopstate',\n    onProgress: 'onprogress',\n    onRateChange: 'onratechange',\n    onRepeat: 'onrepeat',\n    onReset: 'onreset',\n    onResize: 'onresize',\n    onScroll: 'onscroll',\n    onSeeked: 'onseeked',\n    onSeeking: 'onseeking',\n    onSelect: 'onselect',\n    onShow: 'onshow',\n    onStalled: 'onstalled',\n    onStorage: 'onstorage',\n    onSubmit: 'onsubmit',\n    onSuspend: 'onsuspend',\n    onTimeUpdate: 'ontimeupdate',\n    onToggle: 'ontoggle',\n    onUnload: 'onunload',\n    onVolumeChange: 'onvolumechange',\n    onWaiting: 'onwaiting',\n    onZoom: 'onzoom',\n    overlinePosition: 'overline-position',\n    overlineThickness: 'overline-thickness',\n    paintOrder: 'paint-order',\n    panose1: 'panose-1',\n    pointerEvents: 'pointer-events',\n    referrerPolicy: 'referrerpolicy',\n    renderingIntent: 'rendering-intent',\n    shapeRendering: 'shape-rendering',\n    stopColor: 'stop-color',\n    stopOpacity: 'stop-opacity',\n    strikethroughPosition: 'strikethrough-position',\n    strikethroughThickness: 'strikethrough-thickness',\n    strokeDashArray: 'stroke-dasharray',\n    strokeDashOffset: 'stroke-dashoffset',\n    strokeLineCap: 'stroke-linecap',\n    strokeLineJoin: 'stroke-linejoin',\n    strokeMiterLimit: 'stroke-miterlimit',\n    strokeOpacity: 'stroke-opacity',\n    strokeWidth: 'stroke-width',\n    tabIndex: 'tabindex',\n    textAnchor: 'text-anchor',\n    textDecoration: 'text-decoration',\n    textRendering: 'text-rendering',\n    typeOf: 'typeof',\n    underlinePosition: 'underline-position',\n    underlineThickness: 'underline-thickness',\n    unicodeBidi: 'unicode-bidi',\n    unicodeRange: 'unicode-range',\n    unitsPerEm: 'units-per-em',\n    vAlphabetic: 'v-alphabetic',\n    vHanging: 'v-hanging',\n    vIdeographic: 'v-ideographic',\n    vMathematical: 'v-mathematical',\n    vectorEffect: 'vector-effect',\n    vertAdvY: 'vert-adv-y',\n    vertOriginX: 'vert-origin-x',\n    vertOriginY: 'vert-origin-y',\n    wordSpacing: 'word-spacing',\n    writingMode: 'writing-mode',\n    xHeight: 'x-height',\n    // These were camelcased in Tiny. Now lowercased in SVG 2\n    playbackOrder: 'playbackorder',\n    timelineBegin: 'timelinebegin'\n  },\n  transform: caseSensitiveTransform,\n  properties: {\n    about: commaOrSpaceSeparated,\n    accentHeight: number,\n    accumulate: null,\n    additive: null,\n    alignmentBaseline: null,\n    alphabetic: number,\n    amplitude: number,\n    arabicForm: null,\n    ascent: number,\n    attributeName: null,\n    attributeType: null,\n    azimuth: number,\n    bandwidth: null,\n    baselineShift: null,\n    baseFrequency: null,\n    baseProfile: null,\n    bbox: null,\n    begin: null,\n    bias: number,\n    by: null,\n    calcMode: null,\n    capHeight: number,\n    className: spaceSeparated,\n    clip: null,\n    clipPath: null,\n    clipPathUnits: null,\n    clipRule: null,\n    color: null,\n    colorInterpolation: null,\n    colorInterpolationFilters: null,\n    colorProfile: null,\n    colorRendering: null,\n    content: null,\n    contentScriptType: null,\n    contentStyleType: null,\n    crossOrigin: null,\n    cursor: null,\n    cx: null,\n    cy: null,\n    d: null,\n    dataType: null,\n    defaultAction: null,\n    descent: number,\n    diffuseConstant: number,\n    direction: null,\n    display: null,\n    dur: null,\n    divisor: number,\n    dominantBaseline: null,\n    download: boolean,\n    dx: null,\n    dy: null,\n    edgeMode: null,\n    editable: null,\n    elevation: number,\n    enableBackground: null,\n    end: null,\n    event: null,\n    exponent: number,\n    externalResourcesRequired: null,\n    fill: null,\n    fillOpacity: number,\n    fillRule: null,\n    filter: null,\n    filterRes: null,\n    filterUnits: null,\n    floodColor: null,\n    floodOpacity: null,\n    focusable: null,\n    focusHighlight: null,\n    fontFamily: null,\n    fontSize: null,\n    fontSizeAdjust: null,\n    fontStretch: null,\n    fontStyle: null,\n    fontVariant: null,\n    fontWeight: null,\n    format: null,\n    fr: null,\n    from: null,\n    fx: null,\n    fy: null,\n    g1: commaSeparated,\n    g2: commaSeparated,\n    glyphName: commaSeparated,\n    glyphOrientationHorizontal: null,\n    glyphOrientationVertical: null,\n    glyphRef: null,\n    gradientTransform: null,\n    gradientUnits: null,\n    handler: null,\n    hanging: number,\n    hatchContentUnits: null,\n    hatchUnits: null,\n    height: null,\n    href: null,\n    hrefLang: null,\n    horizAdvX: number,\n    horizOriginX: number,\n    horizOriginY: number,\n    id: null,\n    ideographic: number,\n    imageRendering: null,\n    initialVisibility: null,\n    in: null,\n    in2: null,\n    intercept: number,\n    k: number,\n    k1: number,\n    k2: number,\n    k3: number,\n    k4: number,\n    kernelMatrix: commaOrSpaceSeparated,\n    kernelUnitLength: null,\n    keyPoints: null, // SEMI_COLON_SEPARATED\n    keySplines: null, // SEMI_COLON_SEPARATED\n    keyTimes: null, // SEMI_COLON_SEPARATED\n    kerning: null,\n    lang: null,\n    lengthAdjust: null,\n    letterSpacing: null,\n    lightingColor: null,\n    limitingConeAngle: number,\n    local: null,\n    markerEnd: null,\n    markerMid: null,\n    markerStart: null,\n    markerHeight: null,\n    markerUnits: null,\n    markerWidth: null,\n    mask: null,\n    maskContentUnits: null,\n    maskUnits: null,\n    mathematical: null,\n    max: null,\n    media: null,\n    mediaCharacterEncoding: null,\n    mediaContentEncodings: null,\n    mediaSize: number,\n    mediaTime: null,\n    method: null,\n    min: null,\n    mode: null,\n    name: null,\n    navDown: null,\n    navDownLeft: null,\n    navDownRight: null,\n    navLeft: null,\n    navNext: null,\n    navPrev: null,\n    navRight: null,\n    navUp: null,\n    navUpLeft: null,\n    navUpRight: null,\n    numOctaves: null,\n    observer: null,\n    offset: null,\n    onAbort: null,\n    onActivate: null,\n    onAfterPrint: null,\n    onBeforePrint: null,\n    onBegin: null,\n    onCancel: null,\n    onCanPlay: null,\n    onCanPlayThrough: null,\n    onChange: null,\n    onClick: null,\n    onClose: null,\n    onCopy: null,\n    onCueChange: null,\n    onCut: null,\n    onDblClick: null,\n    onDrag: null,\n    onDragEnd: null,\n    onDragEnter: null,\n    onDragExit: null,\n    onDragLeave: null,\n    onDragOver: null,\n    onDragStart: null,\n    onDrop: null,\n    onDurationChange: null,\n    onEmptied: null,\n    onEnd: null,\n    onEnded: null,\n    onError: null,\n    onFocus: null,\n    onFocusIn: null,\n    onFocusOut: null,\n    onHashChange: null,\n    onInput: null,\n    onInvalid: null,\n    onKeyDown: null,\n    onKeyPress: null,\n    onKeyUp: null,\n    onLoad: null,\n    onLoadedData: null,\n    onLoadedMetadata: null,\n    onLoadStart: null,\n    onMessage: null,\n    onMouseDown: null,\n    onMouseEnter: null,\n    onMouseLeave: null,\n    onMouseMove: null,\n    onMouseOut: null,\n    onMouseOver: null,\n    onMouseUp: null,\n    onMouseWheel: null,\n    onOffline: null,\n    onOnline: null,\n    onPageHide: null,\n    onPageShow: null,\n    onPaste: null,\n    onPause: null,\n    onPlay: null,\n    onPlaying: null,\n    onPopState: null,\n    onProgress: null,\n    onRateChange: null,\n    onRepeat: null,\n    onReset: null,\n    onResize: null,\n    onScroll: null,\n    onSeeked: null,\n    onSeeking: null,\n    onSelect: null,\n    onShow: null,\n    onStalled: null,\n    onStorage: null,\n    onSubmit: null,\n    onSuspend: null,\n    onTimeUpdate: null,\n    onToggle: null,\n    onUnload: null,\n    onVolumeChange: null,\n    onWaiting: null,\n    onZoom: null,\n    opacity: null,\n    operator: null,\n    order: null,\n    orient: null,\n    orientation: null,\n    origin: null,\n    overflow: null,\n    overlay: null,\n    overlinePosition: number,\n    overlineThickness: number,\n    paintOrder: null,\n    panose1: null,\n    path: null,\n    pathLength: number,\n    patternContentUnits: null,\n    patternTransform: null,\n    patternUnits: null,\n    phase: null,\n    ping: spaceSeparated,\n    pitch: null,\n    playbackOrder: null,\n    pointerEvents: null,\n    points: null,\n    pointsAtX: number,\n    pointsAtY: number,\n    pointsAtZ: number,\n    preserveAlpha: null,\n    preserveAspectRatio: null,\n    primitiveUnits: null,\n    propagate: null,\n    property: commaOrSpaceSeparated,\n    r: null,\n    radius: null,\n    referrerPolicy: null,\n    refX: null,\n    refY: null,\n    rel: commaOrSpaceSeparated,\n    rev: commaOrSpaceSeparated,\n    renderingIntent: null,\n    repeatCount: null,\n    repeatDur: null,\n    requiredExtensions: commaOrSpaceSeparated,\n    requiredFeatures: commaOrSpaceSeparated,\n    requiredFonts: commaOrSpaceSeparated,\n    requiredFormats: commaOrSpaceSeparated,\n    resource: null,\n    restart: null,\n    result: null,\n    rotate: null,\n    rx: null,\n    ry: null,\n    scale: null,\n    seed: null,\n    shapeRendering: null,\n    side: null,\n    slope: null,\n    snapshotTime: null,\n    specularConstant: number,\n    specularExponent: number,\n    spreadMethod: null,\n    spacing: null,\n    startOffset: null,\n    stdDeviation: null,\n    stemh: null,\n    stemv: null,\n    stitchTiles: null,\n    stopColor: null,\n    stopOpacity: null,\n    strikethroughPosition: number,\n    strikethroughThickness: number,\n    string: null,\n    stroke: null,\n    strokeDashArray: commaOrSpaceSeparated,\n    strokeDashOffset: null,\n    strokeLineCap: null,\n    strokeLineJoin: null,\n    strokeMiterLimit: number,\n    strokeOpacity: number,\n    strokeWidth: null,\n    style: null,\n    surfaceScale: number,\n    syncBehavior: null,\n    syncBehaviorDefault: null,\n    syncMaster: null,\n    syncTolerance: null,\n    syncToleranceDefault: null,\n    systemLanguage: commaOrSpaceSeparated,\n    tabIndex: number,\n    tableValues: null,\n    target: null,\n    targetX: number,\n    targetY: number,\n    textAnchor: null,\n    textDecoration: null,\n    textRendering: null,\n    textLength: null,\n    timelineBegin: null,\n    title: null,\n    transformBehavior: null,\n    type: null,\n    typeOf: commaOrSpaceSeparated,\n    to: null,\n    transform: null,\n    u1: null,\n    u2: null,\n    underlinePosition: number,\n    underlineThickness: number,\n    unicode: null,\n    unicodeBidi: null,\n    unicodeRange: null,\n    unitsPerEm: number,\n    values: null,\n    vAlphabetic: number,\n    vMathematical: number,\n    vectorEffect: null,\n    vHanging: number,\n    vIdeographic: number,\n    version: null,\n    vertAdvY: number,\n    vertOriginX: number,\n    vertOriginY: number,\n    viewBox: null,\n    viewTarget: null,\n    visibility: null,\n    width: null,\n    widths: null,\n    wordSpacing: null,\n    writingMode: null,\n    x: null,\n    x1: null,\n    x2: null,\n    xChannelSelector: null,\n    xHeight: number,\n    y: null,\n    y1: null,\n    y2: null,\n    yChannelSelector: null,\n    z: null,\n    zoomAndPan: null\n  }\n})\n", "/**\n * @typedef {import('./util/schema.js').Schema} Schema\n */\n\nimport {normalize} from './normalize.js'\nimport {DefinedInfo} from './util/defined-info.js'\nimport {Info} from './util/info.js'\n\nconst valid = /^data[-\\w.:]+$/i\nconst dash = /-[a-z]/g\nconst cap = /[A-Z]/g\n\n/**\n * @param {Schema} schema\n * @param {string} value\n * @returns {Info}\n */\nexport function find(schema, value) {\n  const normal = normalize(value)\n  let prop = value\n  let Type = Info\n\n  if (normal in schema.normal) {\n    return schema.property[schema.normal[normal]]\n  }\n\n  if (normal.length > 4 && normal.slice(0, 4) === 'data' && valid.test(value)) {\n    // Attribute or property.\n    if (value.charAt(4) === '-') {\n      // Turn it into a property.\n      const rest = value.slice(5).replace(dash, camelcase)\n      prop = 'data' + rest.charAt(0).toUpperCase() + rest.slice(1)\n    } else {\n      // Turn it into an attribute.\n      const rest = value.slice(4)\n\n      if (!dash.test(rest)) {\n        let dashes = rest.replace(cap, kebab)\n\n        if (dashes.charAt(0) !== '-') {\n          dashes = '-' + dashes\n        }\n\n        value = 'data' + dashes\n      }\n    }\n\n    Type = DefinedInfo\n  }\n\n  return new Type(prop, value)\n}\n\n/**\n * @param {string} $0\n * @returns {string}\n */\nfunction kebab($0) {\n  return '-' + $0.toLowerCase()\n}\n\n/**\n * @param {string} $0\n * @returns {string}\n */\nfunction camelcase($0) {\n  return $0.charAt(1).toUpperCase()\n}\n", "/**\n * @typedef {import('./lib/util/info.js').Info} Info\n * @typedef {import('./lib/util/schema.js').Schema} Schema\n */\n\nimport {merge} from './lib/util/merge.js'\nimport {xlink} from './lib/xlink.js'\nimport {xml} from './lib/xml.js'\nimport {xmlns} from './lib/xmlns.js'\nimport {aria} from './lib/aria.js'\nimport {html as htmlBase} from './lib/html.js'\nimport {svg as svgBase} from './lib/svg.js'\n\nexport {find} from './lib/find.js'\nexport {hastToReact} from './lib/hast-to-react.js'\nexport {normalize} from './lib/normalize.js'\nexport const html = merge([xml, xlink, xmlns, aria, htmlBase], 'html')\nexport const svg = merge([xml, xlink, xmlns, aria, svgBase], 'svg')\n", "/**\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('hast').Element} Element\n */\n\nconst search = /[#.]/g\n\n/**\n * Create a hast element from a simple CSS selector.\n *\n * @template {string} Selector\n *   Type of selector.\n * @template {string} [DefaultTagName='div']\n *   Type of default tag name.\n * @param {Selector | null | undefined} [selector]\n *   Simple CSS selector.\n *\n *   Can contain a tag name (`foo`), classes (`.bar`), and an ID (`#baz`).\n *   Multiple classes are allowed.\n *   Uses the last ID if multiple IDs are found.\n * @param {DefaultTagName | null | undefined} [defaultTagName='div']\n *   Tag name to use if `selector` does not specify one (default: `'div'`).\n * @returns {Element & {tagName: import('./extract.js').ExtractTagName<Selector, DefaultTagName>}}\n *   Built element.\n */\nexport function parseSelector(selector, defaultTagName) {\n  const value = selector || ''\n  /** @type {Properties} */\n  const props = {}\n  let start = 0\n  /** @type {string | undefined} */\n  let previous\n  /** @type {string | undefined} */\n  let tagName\n\n  while (start < value.length) {\n    search.lastIndex = start\n    const match = search.exec(value)\n    const subvalue = value.slice(start, match ? match.index : value.length)\n\n    if (subvalue) {\n      if (!previous) {\n        tagName = subvalue\n      } else if (previous === '#') {\n        props.id = subvalue\n      } else if (Array.isArray(props.className)) {\n        props.className.push(subvalue)\n      } else {\n        props.className = [subvalue]\n      }\n\n      start += subvalue.length\n    }\n\n    if (match) {\n      previous = match[0]\n      start++\n    }\n  }\n\n  return {\n    type: 'element',\n    // @ts-expect-error: fine.\n    tagName: tagName || defaultTagName || 'div',\n    properties: props,\n    children: []\n  }\n}\n", "/**\n * Parse space-separated tokens to an array of strings.\n *\n * @param {string} value\n *   Space-separated tokens.\n * @returns {Array<string>}\n *   List of tokens.\n */\nexport function parse(value) {\n  const input = String(value || '').trim()\n  return input ? input.split(/[ \\t\\n\\r\\f]+/g) : []\n}\n\n/**\n * Serialize an array of strings as space separated-tokens.\n *\n * @param {Array<string|number>} values\n *   List of tokens.\n * @returns {string}\n *   Space-separated tokens.\n */\nexport function stringify(values) {\n  return values.join(' ').trim()\n}\n", "/**\n * @typedef Options\n *   Configuration for `stringify`.\n * @property {boolean} [padLeft=true]\n *   Whether to pad a space before a token.\n * @property {boolean} [padRight=false]\n *   Whether to pad a space after a token.\n */\n\n/**\n * @typedef {Options} StringifyOptions\n *   Please use `StringifyOptions` instead.\n */\n\n/**\n * Parse comma-separated tokens to an array.\n *\n * @param {string} value\n *   Comma-separated tokens.\n * @returns {Array<string>}\n *   List of tokens.\n */\nexport function parse(value) {\n  /** @type {Array<string>} */\n  const tokens = []\n  const input = String(value || '')\n  let index = input.indexOf(',')\n  let start = 0\n  /** @type {boolean} */\n  let end = false\n\n  while (!end) {\n    if (index === -1) {\n      index = input.length\n      end = true\n    }\n\n    const token = input.slice(start, index).trim()\n\n    if (token || !end) {\n      tokens.push(token)\n    }\n\n    start = index + 1\n    index = input.indexOf(',', start)\n  }\n\n  return tokens\n}\n\n/**\n * Serialize an array of strings or numbers to comma-separated tokens.\n *\n * @param {Array<string|number>} values\n *   List of tokens.\n * @param {Options} [options]\n *   Configuration for `stringify` (optional).\n * @returns {string}\n *   Comma-separated tokens.\n */\nexport function stringify(values, options) {\n  const settings = options || {}\n\n  // Ensure the last empty entry is seen.\n  const input = values[values.length - 1] === '' ? [...values, ''] : values\n\n  return input\n    .join(\n      (settings.padRight ? ' ' : '') +\n        ',' +\n        (settings.padLeft === false ? '' : ' ')\n    )\n    .trim()\n}\n", "/**\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Content} Content\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('property-information').Info} Info\n * @typedef {import('property-information').Schema} Schema\n */\n\n/**\n * @typedef {Content | Root} Node\n *   Any concrete `hast` node.\n * @typedef {Root | Element} HResult\n *   Result from a `h` (or `s`) call.\n *\n * @typedef {string | number} HStyleValue\n *   Value for a CSS style field.\n * @typedef {Record<string, HStyleValue>} HStyle\n *   Supported value of a `style` prop.\n * @typedef {string | number | boolean | null | undefined} HPrimitiveValue\n *   Primitive property value.\n * @typedef {Array<string | number>} HArrayValue\n *   List of property values for space- or comma separated values (such as `className`).\n * @typedef {HPrimitiveValue | HArrayValue} HPropertyValue\n *   Primitive value or list value.\n * @typedef {{[property: string]: HPropertyValue | HStyle}} HProperties\n *   Acceptable value for element properties.\n *\n * @typedef {string | number | null | undefined} HPrimitiveChild\n *   Primitive children, either ignored (nullish), or turned into text nodes.\n * @typedef {Array<Node | HPrimitiveChild>} HArrayChild\n *   List of children.\n * @typedef {Node | HPrimitiveChild | HArrayChild} HChild\n *   Acceptable child value.\n */\n\nimport {find, normalize} from 'property-information'\nimport {parseSelector} from 'hast-util-parse-selector'\nimport {parse as spaces} from 'space-separated-tokens'\nimport {parse as commas} from 'comma-separated-tokens'\n\nconst buttonTypes = new Set(['menu', 'submit', 'reset', 'button'])\n\nconst own = {}.hasOwnProperty\n\n/**\n * @param {Schema} schema\n * @param {string} defaultTagName\n * @param {Array<string>} [caseSensitive]\n */\nexport function core(schema, defaultTagName, caseSensitive) {\n  const adjust = caseSensitive && createAdjustMap(caseSensitive)\n\n  const h =\n    /**\n     * @type {{\n     *   (): Root\n     *   (selector: null | undefined, ...children: Array<HChild>): Root\n     *   (selector: string, properties?: HProperties, ...children: Array<HChild>): Element\n     *   (selector: string, ...children: Array<HChild>): Element\n     * }}\n     */\n    (\n      /**\n       * Hyperscript compatible DSL for creating virtual hast trees.\n       *\n       * @param {string | null} [selector]\n       * @param {HProperties | HChild} [properties]\n       * @param {Array<HChild>} children\n       * @returns {HResult}\n       */\n      function (selector, properties, ...children) {\n        let index = -1\n        /** @type {HResult} */\n        let node\n\n        if (selector === undefined || selector === null) {\n          node = {type: 'root', children: []}\n          // @ts-expect-error Properties are not supported for roots.\n          children.unshift(properties)\n        } else {\n          node = parseSelector(selector, defaultTagName)\n          // Normalize the name.\n          node.tagName = node.tagName.toLowerCase()\n          if (adjust && own.call(adjust, node.tagName)) {\n            node.tagName = adjust[node.tagName]\n          }\n\n          // Handle props.\n          if (isProperties(properties, node.tagName)) {\n            /** @type {string} */\n            let key\n\n            for (key in properties) {\n              if (own.call(properties, key)) {\n                // @ts-expect-error `node.properties` is set.\n                addProperty(schema, node.properties, key, properties[key])\n              }\n            }\n          } else {\n            children.unshift(properties)\n          }\n        }\n\n        // Handle children.\n        while (++index < children.length) {\n          addChild(node.children, children[index])\n        }\n\n        if (node.type === 'element' && node.tagName === 'template') {\n          node.content = {type: 'root', children: node.children}\n          node.children = []\n        }\n\n        return node\n      }\n    )\n\n  return h\n}\n\n/**\n * @param {HProperties | HChild} value\n * @param {string} name\n * @returns {value is HProperties}\n */\nfunction isProperties(value, name) {\n  if (\n    value === null ||\n    value === undefined ||\n    typeof value !== 'object' ||\n    Array.isArray(value)\n  ) {\n    return false\n  }\n\n  if (name === 'input' || !value.type || typeof value.type !== 'string') {\n    return true\n  }\n\n  if ('children' in value && Array.isArray(value.children)) {\n    return false\n  }\n\n  if (name === 'button') {\n    return buttonTypes.has(value.type.toLowerCase())\n  }\n\n  return !('value' in value)\n}\n\n/**\n * @param {Schema} schema\n * @param {Properties} properties\n * @param {string} key\n * @param {HStyle | HPropertyValue} value\n * @returns {void}\n */\nfunction addProperty(schema, properties, key, value) {\n  const info = find(schema, key)\n  let index = -1\n  /** @type {HPropertyValue} */\n  let result\n\n  // Ignore nullish and NaN values.\n  if (value === undefined || value === null) return\n\n  if (typeof value === 'number') {\n    // Ignore NaN.\n    if (Number.isNaN(value)) return\n\n    result = value\n  }\n  // Booleans.\n  else if (typeof value === 'boolean') {\n    result = value\n  }\n  // Handle list values.\n  else if (typeof value === 'string') {\n    if (info.spaceSeparated) {\n      result = spaces(value)\n    } else if (info.commaSeparated) {\n      result = commas(value)\n    } else if (info.commaOrSpaceSeparated) {\n      result = spaces(commas(value).join(' '))\n    } else {\n      result = parsePrimitive(info, info.property, value)\n    }\n  } else if (Array.isArray(value)) {\n    result = value.concat()\n  } else {\n    result = info.property === 'style' ? style(value) : String(value)\n  }\n\n  if (Array.isArray(result)) {\n    /** @type {Array<string | number>} */\n    const finalResult = []\n\n    while (++index < result.length) {\n      // @ts-expect-error Assume no booleans in array.\n      finalResult[index] = parsePrimitive(info, info.property, result[index])\n    }\n\n    result = finalResult\n  }\n\n  // Class names (which can be added both on the `selector` and here).\n  if (info.property === 'className' && Array.isArray(properties.className)) {\n    // @ts-expect-error Assume no booleans in `className`.\n    result = properties.className.concat(result)\n  }\n\n  properties[info.property] = result\n}\n\n/**\n * @param {Array<Content>} nodes\n * @param {HChild} value\n * @returns {void}\n */\nfunction addChild(nodes, value) {\n  let index = -1\n\n  if (value === undefined || value === null) {\n    // Empty.\n  } else if (typeof value === 'string' || typeof value === 'number') {\n    nodes.push({type: 'text', value: String(value)})\n  } else if (Array.isArray(value)) {\n    while (++index < value.length) {\n      addChild(nodes, value[index])\n    }\n  } else if (typeof value === 'object' && 'type' in value) {\n    if (value.type === 'root') {\n      addChild(nodes, value.children)\n    } else {\n      nodes.push(value)\n    }\n  } else {\n    throw new Error('Expected node, nodes, or string, got `' + value + '`')\n  }\n}\n\n/**\n * Parse a single primitives.\n *\n * @param {Info} info\n * @param {string} name\n * @param {HPrimitiveValue} value\n * @returns {HPrimitiveValue}\n */\nfunction parsePrimitive(info, name, value) {\n  if (typeof value === 'string') {\n    if (info.number && value && !Number.isNaN(Number(value))) {\n      return Number(value)\n    }\n\n    if (\n      (info.boolean || info.overloadedBoolean) &&\n      (value === '' || normalize(value) === normalize(name))\n    ) {\n      return true\n    }\n  }\n\n  return value\n}\n\n/**\n * Serialize a `style` object as a string.\n *\n * @param {HStyle} value\n *   Style object.\n * @returns {string}\n *   CSS string.\n */\nfunction style(value) {\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {string} */\n  let key\n\n  for (key in value) {\n    if (own.call(value, key)) {\n      result.push([key, value[key]].join(': '))\n    }\n  }\n\n  return result.join('; ')\n}\n\n/**\n * Create a map to adjust casing.\n *\n * @param {Array<string>} values\n *   List of properly cased keys.\n * @returns {Record<string, string>}\n *   Map of lowercase keys to uppercase keys.\n */\nfunction createAdjustMap(values) {\n  /** @type {Record<string, string>} */\n  const result = {}\n  let index = -1\n\n  while (++index < values.length) {\n    result[values[index].toLowerCase()] = values[index]\n  }\n\n  return result\n}\n", "export const svgCaseSensitiveTagNames = [\n  'altGlyph',\n  'altGlyphDef',\n  'altGlyphItem',\n  'animateColor',\n  'animateMotion',\n  'animateTransform',\n  'clipPath',\n  'feBlend',\n  'feColorMatrix',\n  'feComponentTransfer',\n  'feComposite',\n  'feConvolveMatrix',\n  'feDiffuseLighting',\n  'feDisplacementMap',\n  'feDistantLight',\n  'feDropShadow',\n  'feFlood',\n  'feFuncA',\n  'feFuncB',\n  'feFuncG',\n  'feFuncR',\n  'feGaussianBlur',\n  'feImage',\n  'feMerge',\n  'feMergeNode',\n  'feMorphology',\n  'feOffset',\n  'fePointLight',\n  'feSpecularLighting',\n  'feSpotLight',\n  'feTile',\n  'feTurbulence',\n  'foreignObject',\n  'glyphRef',\n  'linearGradient',\n  'radialGradient',\n  'solidColor',\n  'textArea',\n  'textPath'\n]\n", "/**\n * @typedef {import('./core.js').HChild} Child\n *   Acceptable child value.\n * @typedef {import('./core.js').HProperties} Properties\n *   Acceptable value for element properties.\n * @typedef {import('./core.js').HResult} Result\n *   Result from a `h` (or `s`) call.\n *\n * @typedef {import('./jsx-classic.js').Element} s.JSX.Element\n * @typedef {import('./jsx-classic.js').IntrinsicAttributes} s.JSX.IntrinsicAttributes\n * @typedef {import('./jsx-classic.js').IntrinsicElements} s.JSX.IntrinsicElements\n * @typedef {import('./jsx-classic.js').ElementChildrenAttribute} s.JSX.ElementChildrenAttribute\n */\n\nimport {svg} from 'property-information'\nimport {core} from './core.js'\nimport {svgCaseSensitiveTagNames} from './svg-case-sensitive-tag-names.js'\n\nexport const s = core(svg, 'g', svgCaseSensitiveTagNames)\n", "export interface FileRead {\n  filename: string\n  contents: string\n}\n\nexport async function readFile(file: File | string): Promise<FileRead> {\n  return typeof file === 'string' ? readNodeFile(file) : readBrowserFile(file)\n}\n\nasync function readBrowserFile(file: File): Promise<FileRead> {\n  if (typeof File === 'undefined' || typeof FileReader === 'undefined') {\n    throw new TypeError(\n      `Cannot read \"file\" object of type ${typeof file} in a non-browser environment`\n    )\n  }\n\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader()\n\n    reader.addEventListener('load', handleLoad, {once: true})\n    reader.addEventListener('error', handleError, {once: true})\n    reader.readAsText(file)\n\n    function handleLoad() {\n      const contents = reader.result as string\n      reader.removeEventListener('error', handleError)\n      resolve({filename: file.name, contents})\n    }\n\n    function handleError() {\n      reader.removeEventListener('load', handleLoad)\n      reject(reader.error)\n    }\n  })\n}\n\nasync function readNodeFile(file: string): Promise<FileRead> {\n  const [fs, path] = await Promise.all([\n    import('node:fs/promises'),\n    import('node:path'),\n  ]).catch(() => {\n    throw new TypeError(\n      'Cannot read a file path string in a non-Node.js environment'\n    )\n  })\n\n  const filename = path.basename(file)\n  const contents = await fs.readFile(file, 'utf8')\n\n  return {filename, contents}\n}\n", "import {DRILL, GERBER} from '@tracespace/parser'\nimport {TYPE_DRILL, SIDE_ALL, identifyLayers} from '@tracespace/identify-layers'\n\nimport type {LayerIdentity} from '@tracespace/identify-layers'\nimport type {GerberTree} from '@tracespace/parser'\n\nexport interface ParsedLayer {\n  id: string\n  filename: string\n  parseTree: GerberTree\n}\n\nexport function determineLayerTypes(\n  layers: ParsedLayer[]\n): Record<string, LayerIdentity> {\n  const gerberFilenames = layers\n    .filter(layer => layer.parseTree.filetype === GERBER)\n    .map(layer => layer.filename)\n\n  const identitiesByFilename = identifyLayers(gerberFilenames)\n\n  return Object.fromEntries(\n    layers.map(({id, filename, parseTree}) => {\n      const layerIdentity: LayerIdentity =\n        parseTree.filetype === DRILL\n          ? {type: TYPE_DRILL, side: SIDE_ALL}\n          : identitiesByFilename[filename]\n\n      return [id, layerIdentity]\n    })\n  )\n}\n", "import {\n  TYPE_COPPER,\n  TYPE_SOLDERMASK,\n  TYPE_SILKSCREEN,\n  TYPE_SOLDERPASTE,\n  TYPE_DRILL,\n  TYPE_OUTLINE,\n} from '@tracespace/identify-layers'\n\nimport type {\n  SIDE_TOP,\n  SIDE_BOTTOM,\n  GerberType,\n} from '@tracespace/identify-layers'\nimport type {Layer} from '.'\n\nexport interface SideLayers {\n  copper: string[]\n  solderMask: string[]\n  silkScreen: string[]\n  solderPaste: string[]\n}\n\nexport type Side = typeof SIDE_TOP | typeof SIDE_BOTTOM\n\nconst toId = ({id}: Layer) => id\nconst isType = (type: GerberType, side?: Side) => (layer: Layer) => {\n  return layer.type === type && (side === undefined || layer.side === side)\n}\n\nexport function getOutlineLayer(layers: Layer[]): string | undefined {\n  return layers.filter(isType(TYPE_OUTLINE)).map(toId)[0]\n}\n\nexport function getDrillLayers(layers: Layer[]): string[] {\n  return layers.filter(isType(TYPE_DRILL)).map(toId)\n}\n\nexport function getSideLayers(side: Side, layers: Layer[]): SideLayers {\n  return {\n    copper: layers.filter(isType(TYPE_COPPER, side)).map(toId),\n    solderMask: layers.filter(isType(TYPE_SOLDERMASK, side)).map(toId),\n    silkScreen: layers.filter(isType(TYPE_SILKSCREEN, side)).map(toId),\n    solderPaste: layers.filter(isType(TYPE_SOLDERPASTE, side)).map(toId),\n  }\n}\n", "import type {PathSegment, Position, ArcPosition} from '@tracespace/plotter'\n\nexport interface PathWalk {\n  start: Position\n  end: Position\n  segments: PathSegment[]\n}\n\nexport function walkPaths(segments: PathSegment[]): PathWalk[] {\n  const segmentsById = new Map<string, PathSegment>()\n  const segmentIdsByPointId = new Map<string, string[]>()\n\n  for (const segment of segments) {\n    const segmentId = hashSegment(segment)\n\n    segmentsById.set(segmentId, segment)\n\n    for (const point of [segment.start, segment.end]) {\n      const pointId = hashPoint(point)\n      const pointSegmentIds = segmentIdsByPointId.get(pointId) ?? []\n\n      pointSegmentIds.push(segmentId)\n      segmentIdsByPointId.set(pointId, pointSegmentIds)\n    }\n  }\n\n  const pointMap: PointMap = Object.assign(Object.create(PointMapPrototype), {\n    segmentsById,\n    segmentIdsByPointId,\n  })\n\n  return pointMap.walk()\n}\n\ninterface PointMapProperties {\n  segmentsById: Map<string, PathSegment>\n  segmentIdsByPointId: Map<string, string[]>\n}\n\ninterface PointMapMethods {\n  walkPath(pointId: string): PathSegment[]\n  shiftNextSegment(pointId: string): PathSegment | undefined\n  shiftSegmentId(pointId: string): string | undefined\n  consumeSegment(segmentId: string): PathSegment | undefined\n  walk(): PathWalk[]\n}\n\ninterface PointMap extends PointMapProperties, PointMapMethods {}\n\nconst PointMapPrototype: PointMapMethods = {\n  walk(this: PointMap): PathWalk[] {\n    const results: PathWalk[] = []\n\n    while (this.segmentsById.size > 0) {\n      const pointId = this.segmentIdsByPointId.keys().next().value as string\n      const segments = this.walkPath(pointId)\n\n      if (segments.length > 0) {\n        const firstSegment = segments[0]\n        const lastSegment = segments[segments.length - 1]\n        const start: Position = [firstSegment.start[0], firstSegment.start[1]]\n        const end: Position = [lastSegment.end[0], lastSegment.end[1]]\n\n        results.push({start, end, segments})\n      }\n    }\n\n    return results\n  },\n\n  walkPath(this: PointMap, pointId: string): PathSegment[] {\n    const segment = this.shiftNextSegment(pointId)\n\n    if (segment !== undefined) {\n      const startId = hashPoint(segment.start)\n      const endId = hashPoint(segment.end)\n      const nextPointId = pointId === startId ? endId : startId\n\n      return [\n        pointId === startId ? segment : reverseSegment(segment),\n        ...this.walkPath(nextPointId),\n      ]\n    }\n\n    return []\n  },\n\n  shiftNextSegment(this: PointMap, pointId: string): PathSegment | undefined {\n    const segmentId = this.shiftSegmentId(pointId)\n\n    if (segmentId === undefined) {\n      return undefined\n    }\n\n    return this.consumeSegment(segmentId) ?? this.shiftNextSegment(pointId)\n  },\n\n  shiftSegmentId(this: PointMap, pointId: string): string | undefined {\n    const segmentIds = this.segmentIdsByPointId.get(pointId)\n    const nextId = segmentIds?.shift()\n\n    if (segmentIds?.length === 0) {\n      this.segmentIdsByPointId.delete(pointId)\n    }\n\n    return nextId\n  },\n\n  consumeSegment(this: PointMap, segmentId: string): PathSegment | undefined {\n    const segment = this.segmentsById.get(segmentId)\n    this.segmentsById.delete(segmentId)\n    return segment\n  },\n}\n\nfunction hashPoint(point: Position | ArcPosition): string {\n  return `${point[0]},${point[1]}`\n}\n\nfunction hashSegment(segment: PathSegment): string {\n  const {type} = segment\n  const [start, end] = sortPoints(segment.start, segment.end)\n\n  return `${type}:${hashPoint(start)}:${hashPoint(end)}`\n}\n\nfunction sortPoints<P extends Position | ArcPosition>(a: P, b: P): [P, P] {\n  if (b[0] < a[0]) return [b, a]\n  if (b[0] > a[0]) return [a, b]\n  if (b[1] < a[1]) return [b, a]\n  return [a, b]\n}\n\nexport function reverseSegment<S extends PathSegment>(segment: S): S {\n  return {...segment, start: segment.end, end: segment.start}\n}\n", "import {LINE, IMAGE_REGION, IMAGE_PATH} from '@tracespace/plotter'\n\nimport type {\n  ImagePath,\n  ImageRegion,\n  PathSegment,\n  Position,\n} from '@tracespace/plotter'\nimport type {PathWalk} from './walk-paths'\n\nimport {reverseSegment} from './walk-paths'\n\nconst segmentsToRegion = (segments: PathSegment[]): ImageRegion => ({\n  type: IMAGE_REGION,\n  segments,\n})\n\nconst segmentsToPath = (segments: PathSegment[]): ImagePath => ({\n  type: IMAGE_PATH,\n  width: 0,\n  segments,\n})\n\nexport function fillGaps(\n  pathWalks: PathWalk[],\n  maximumGap: number\n): [regions: ImageRegion[], openPaths: ImagePath[]] {\n  const maximumSquareGap = maximumGap ** 2\n  const walksToCheck: PathWalk[] = [...pathWalks]\n  const closedPaths: PathSegment[][] = []\n  const openPaths: PathSegment[][] = []\n\n  while (walksToCheck.length > 0) {\n    const pathWalk = walksToCheck.shift()!\n    let smallestGap = squareDistance(pathWalk.end, pathWalk.start)\n    let nearestPathWalk = pathWalk\n    let nearestEndPoint = pathWalk.start\n\n    if (smallestGap === 0) {\n      closedPaths.push(pathWalk.segments)\n      continue\n    }\n\n    for (const otherWalk of walksToCheck) {\n      for (const otherEndPoint of [otherWalk.start, otherWalk.end]) {\n        const gap = squareDistance(pathWalk.end, otherEndPoint)\n        if (gap < smallestGap) {\n          smallestGap = gap\n          nearestPathWalk = otherWalk\n          nearestEndPoint = otherEndPoint\n        }\n      }\n    }\n\n    if (smallestGap <= maximumSquareGap) {\n      const gapFill: PathSegment = {\n        type: LINE,\n        start: pathWalk.end,\n        end: nearestEndPoint,\n      }\n\n      if (pathWalk === nearestPathWalk) {\n        closedPaths.push([...pathWalk.segments, gapFill])\n        continue\n      }\n\n      const nearestPathWalkIndex = walksToCheck.indexOf(nearestPathWalk)\n      if (nearestPathWalkIndex !== -1) {\n        walksToCheck.splice(nearestPathWalkIndex, 1)\n      }\n\n      const nearestPathSegments =\n        nearestEndPoint === nearestPathWalk.start\n          ? nearestPathWalk.segments\n          : nearestPathWalk.segments.map(reverseSegment).reverse()\n\n      const nearestPathEnd =\n        nearestEndPoint === nearestPathWalk.start\n          ? nearestPathWalk.end\n          : nearestPathWalk.start\n\n      walksToCheck.unshift({\n        start: pathWalk.start,\n        end: nearestPathEnd,\n        segments: [...pathWalk.segments, gapFill, ...nearestPathSegments],\n      })\n    } else {\n      openPaths.push(pathWalk.segments)\n    }\n  }\n\n  return [closedPaths.map(segmentsToRegion), openPaths.map(segmentsToPath)]\n}\n\nfunction squareDistance(a: Position, b: Position): number {\n  return a[0] !== b[0] || a[1] !== b[1]\n    ? (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n    : 0\n}\n", "import {IMAGE_PATH, IMAGE_REGION, BoundingBox} from '@tracespace/plotter'\nimport {renderGraphic, sizeToViewBox} from '@tracespace/renderer'\n\nimport type {\n  ImageTree,\n  ImagePath,\n  ImageRegion,\n  SizeEnvelope,\n} from '@tracespace/plotter'\nimport type {SvgElement, ViewBox} from '@tracespace/renderer'\n\nimport type {Layer} from '..'\nimport {getOutlineLayer} from '../sort-layers'\nimport {walkPaths} from './walk-paths'\nimport {fillGaps} from './fill-gaps'\n\nexport const MISSING_OUTLINE_LAYER = 'missingOutlineLayer'\nexport const NO_PATHS_IN_OUTLINE_LAYER = 'noPathsInOutlineLayer'\nexport const NO_CLOSED_REGIONS_FOUND = 'noClosedRegionsFound'\n\nexport interface BoardShape {\n  size: SizeEnvelope\n  regions: ImageRegion[]\n  openPaths: ImagePath[]\n  failureReason?: BoardShapeFailureReason\n}\n\nexport interface BoardShapeRender {\n  viewBox: ViewBox\n  path?: SvgElement\n  failureReason?: BoardShapeFailureReason\n}\n\nexport type BoardShapeFailureReason =\n  | typeof MISSING_OUTLINE_LAYER\n  | typeof NO_PATHS_IN_OUTLINE_LAYER\n  | typeof NO_CLOSED_REGIONS_FOUND\n\nexport function plotBoardShape(\n  layers: Layer[],\n  plotTreesById: Record<string, ImageTree>,\n  maximumGap: number\n): BoardShape {\n  const outlineId = getOutlineLayer(layers)\n  const outlinePlot = outlineId ? plotTreesById[outlineId] : undefined\n  const size = BoundingBox.sum(\n    Object.values(plotTreesById).map(({size}) => size)\n  )\n\n  if (outlinePlot === undefined) {\n    return {\n      size,\n      regions: [],\n      openPaths: [],\n      failureReason: MISSING_OUTLINE_LAYER,\n    }\n  }\n\n  const inputSegments = outlinePlot.children\n    .filter((node): node is ImagePath => node.type === IMAGE_PATH)\n    .flatMap(path => path.segments)\n\n  if (inputSegments.length === 0) {\n    return {\n      size,\n      regions: [],\n      openPaths: [],\n      failureReason: NO_PATHS_IN_OUTLINE_LAYER,\n    }\n  }\n\n  const allPaths = walkPaths(inputSegments)\n  const [regions, openPaths] = fillGaps(allPaths, maximumGap)\n\n  if (regions.length === 0) {\n    return {size, regions, openPaths, failureReason: NO_CLOSED_REGIONS_FOUND}\n  }\n\n  return {\n    regions,\n    openPaths,\n    size: BoundingBox.fromGraphics(regions),\n  }\n}\n\nexport function renderBoardShape(boardShape: BoardShape): BoardShapeRender {\n  const {regions, size, failureReason} = boardShape\n  const viewBox = sizeToViewBox(size)\n  const segments = regions.flatMap(r => r.segments)\n\n  return failureReason\n    ? {viewBox, failureReason}\n    : {viewBox, path: renderGraphic({type: IMAGE_REGION, segments})}\n}\n", "/**\n * List of HTML void tag names.\n *\n * @type {Array<string>}\n */\nexport const htmlVoidElements = [\n  'area',\n  'base',\n  'basefont',\n  'bgsound',\n  'br',\n  'col',\n  'command',\n  'embed',\n  'frame',\n  'hr',\n  'image',\n  'img',\n  'input',\n  'isindex',\n  'keygen',\n  'link',\n  'menuitem',\n  'meta',\n  'nextid',\n  'param',\n  'source',\n  'track',\n  'wbr'\n]\n", "/**\n * @callback Handler\n *   Handle a value, with a certain ID field set to a certain value.\n *   The ID field is passed to `zwitch`, and it’s value is this function’s\n *   place on the `handlers` record.\n * @param {...any} parameters\n *   Arbitrary parameters passed to the zwitch.\n *   The first will be an object with a certain ID field set to a certain value.\n * @returns {any}\n *   Anything!\n */\n\n/**\n * @callback UnknownHandler\n *   Handle values that do have a certain ID field, but it’s set to a value\n *   that is not listed in the `handlers` record.\n * @param {unknown} value\n *   An object with a certain ID field set to an unknown value.\n * @param {...any} rest\n *   Arbitrary parameters passed to the zwitch.\n * @returns {any}\n *   Anything!\n */\n\n/**\n * @callback InvalidHandler\n *   Handle values that do not have a certain ID field.\n * @param {unknown} value\n *   Any unknown value.\n * @param {...any} rest\n *   Arbitrary parameters passed to the zwitch.\n * @returns {void|null|undefined|never}\n *   This should crash or return nothing.\n */\n\n/**\n * @template {InvalidHandler} [Invalid=InvalidHandler]\n * @template {UnknownHandler} [Unknown=UnknownHandler]\n * @template {Record<string, Handler>} [Handlers=Record<string, Handler>]\n * @typedef Options\n *   Configuration (required).\n * @property {Invalid} [invalid]\n *   Handler to use for invalid values.\n * @property {Unknown} [unknown]\n *   Handler to use for unknown values.\n * @property {Handlers} [handlers]\n *   Handlers to use.\n */\n\nconst own = {}.hasOwnProperty\n\n/**\n * Handle values based on a field.\n *\n * @template {InvalidHandler} [Invalid=InvalidHandler]\n * @template {UnknownHandler} [Unknown=UnknownHandler]\n * @template {Record<string, Handler>} [Handlers=Record<string, Handler>]\n * @param {string} key\n *   Field to switch on.\n * @param {Options<Invalid, Unknown, Handlers>} [options]\n *   Configuration (required).\n * @returns {{unknown: Unknown, invalid: Invalid, handlers: Handlers, (...parameters: Parameters<Handlers[keyof Handlers]>): ReturnType<Handlers[keyof Handlers]>, (...parameters: Parameters<Unknown>): ReturnType<Unknown>}}\n */\nexport function zwitch(key, options) {\n  const settings = options || {}\n\n  /**\n   * Handle one value.\n   *\n   * Based on the bound `key`, a respective handler will be called.\n   * If `value` is not an object, or doesn’t have a `key` property, the special\n   * “invalid” handler will be called.\n   * If `value` has an unknown `key`, the special “unknown” handler will be\n   * called.\n   *\n   * All arguments, and the context object, are passed through to the handler,\n   * and it’s result is returned.\n   *\n   * @this {unknown}\n   *   Any context object.\n   * @param {unknown} [value]\n   *   Any value.\n   * @param {...unknown} parameters\n   *   Arbitrary parameters passed to the zwitch.\n   * @property {Handler} invalid\n   *   Handle for values that do not have a certain ID field.\n   * @property {Handler} unknown\n   *   Handle values that do have a certain ID field, but it’s set to a value\n   *   that is not listed in the `handlers` record.\n   * @property {Handlers} handlers\n   *   Record of handlers.\n   * @returns {unknown}\n   *   Anything.\n   */\n  function one(value, ...parameters) {\n    /** @type {Handler|undefined} */\n    let fn = one.invalid\n    const handlers = one.handlers\n\n    if (value && own.call(value, key)) {\n      // @ts-expect-error Indexable.\n      const id = String(value[key])\n      // @ts-expect-error Indexable.\n      fn = own.call(handlers, id) ? handlers[id] : one.unknown\n    }\n\n    if (fn) {\n      return fn.call(this, value, ...parameters)\n    }\n  }\n\n  one.handlers = settings.handlers || {}\n  one.invalid = settings.invalid\n  one.unknown = settings.unknown\n\n  // @ts-expect-error: matches!\n  return one\n}\n", "/**\n * @typedef CoreOptions\n * @property {Array<string>} [subset=[]]\n *   Whether to only escape the given subset of characters.\n * @property {boolean} [escapeOnly=false]\n *   Whether to only escape possibly dangerous characters.\n *   Those characters are `\"`, `&`, `'`, `<`, `>`, and `` ` ``.\n *\n * @typedef FormatOptions\n * @property {(code: number, next: number, options: CoreWithFormatOptions) => string} format\n *   Format strategy.\n *\n * @typedef {CoreOptions & FormatOptions & import('./util/format-smart.js').FormatSmartOptions} CoreWithFormatOptions\n */\n\n/**\n * Encode certain characters in `value`.\n *\n * @param {string} value\n * @param {CoreWithFormatOptions} options\n * @returns {string}\n */\nexport function core(value, options) {\n  value = value.replace(\n    options.subset ? charactersToExpression(options.subset) : /[\"&'<>`]/g,\n    basic\n  )\n\n  if (options.subset || options.escapeOnly) {\n    return value\n  }\n\n  return (\n    value\n      // Surrogate pairs.\n      .replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, surrogate)\n      // BMP control characters (C0 except for LF, CR, SP; DEL; and some more\n      // non-ASCII ones).\n      .replace(\n        // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape\n        /[\\x01-\\t\\v\\f\\x0E-\\x1F\\x7F\\x81\\x8D\\x8F\\x90\\x9D\\xA0-\\uFFFF]/g,\n        basic\n      )\n  )\n\n  /**\n   * @param {string} pair\n   * @param {number} index\n   * @param {string} all\n   */\n  function surrogate(pair, index, all) {\n    return options.format(\n      (pair.charCodeAt(0) - 0xd800) * 0x400 +\n        pair.charCodeAt(1) -\n        0xdc00 +\n        0x10000,\n      all.charCodeAt(index + 2),\n      options\n    )\n  }\n\n  /**\n   * @param {string} character\n   * @param {number} index\n   * @param {string} all\n   */\n  function basic(character, index, all) {\n    return options.format(\n      character.charCodeAt(0),\n      all.charCodeAt(index + 1),\n      options\n    )\n  }\n}\n\n/**\n * @param {Array<string>} subset\n * @returns {RegExp}\n */\nfunction charactersToExpression(subset) {\n  /** @type {Array<string>} */\n  const groups = []\n  let index = -1\n\n  while (++index < subset.length) {\n    groups.push(subset[index].replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&'))\n  }\n\n  return new RegExp('(?:' + groups.join('|') + ')', 'g')\n}\n", "/**\n * Configurable ways to encode characters as hexadecimal references.\n *\n * @param {number} code\n * @param {number} next\n * @param {boolean|undefined} omit\n * @returns {string}\n */\nexport function toHexadecimal(code, next, omit) {\n  const value = '&#x' + code.toString(16).toUpperCase()\n  return omit && next && !/[\\dA-Fa-f]/.test(String.fromCharCode(next))\n    ? value\n    : value + ';'\n}\n", "/**\n * Configurable ways to encode characters as decimal references.\n *\n * @param {number} code\n * @param {number} next\n * @param {boolean|undefined} omit\n * @returns {string}\n */\nexport function toDecimal(code, next, omit) {\n  const value = '&#' + String(code)\n  return omit && next && !/\\d/.test(String.fromCharCode(next))\n    ? value\n    : value + ';'\n}\n", "/**\n * List of legacy HTML named character references that don’t need a trailing semicolon.\n *\n * @type {Array<string>}\n */\nexport const characterEntitiesLegacy = [\n  'AElig',\n  'AMP',\n  'Aacute',\n  'Acirc',\n  'Agrave',\n  'Aring',\n  'Atilde',\n  'Auml',\n  'COPY',\n  'Ccedil',\n  'ETH',\n  'Eacute',\n  'Ecirc',\n  'Egrave',\n  'Euml',\n  'GT',\n  'Iacute',\n  'Icirc',\n  'Igrave',\n  'Iuml',\n  'LT',\n  'Ntilde',\n  'Oacute',\n  'Ocirc',\n  'Ograve',\n  'Oslash',\n  'Otilde',\n  'Ouml',\n  'QUOT',\n  'REG',\n  'THORN',\n  'Uacute',\n  'Ucirc',\n  'Ugrave',\n  'Uuml',\n  'Yacute',\n  'aacute',\n  'acirc',\n  'acute',\n  'aelig',\n  'agrave',\n  'amp',\n  'aring',\n  'atilde',\n  'auml',\n  'brvbar',\n  'ccedil',\n  'cedil',\n  'cent',\n  'copy',\n  'curren',\n  'deg',\n  'divide',\n  'eacute',\n  'ecirc',\n  'egrave',\n  'eth',\n  'euml',\n  'frac12',\n  'frac14',\n  'frac34',\n  'gt',\n  'iacute',\n  'icirc',\n  'iexcl',\n  'igrave',\n  'iquest',\n  'iuml',\n  'laquo',\n  'lt',\n  'macr',\n  'micro',\n  'middot',\n  'nbsp',\n  'not',\n  'ntilde',\n  'oacute',\n  'ocirc',\n  'ograve',\n  'ordf',\n  'ordm',\n  'oslash',\n  'otilde',\n  'ouml',\n  'para',\n  'plusmn',\n  'pound',\n  'quot',\n  'raquo',\n  'reg',\n  'sect',\n  'shy',\n  'sup1',\n  'sup2',\n  'sup3',\n  'szlig',\n  'thorn',\n  'times',\n  'uacute',\n  'ucirc',\n  'ugrave',\n  'uml',\n  'uuml',\n  'yacute',\n  'yen',\n  'yuml'\n]\n", "/**\n * Map of named character references from HTML 4.\n *\n * @type {Record<string, string>}\n */\nexport const characterEntitiesHtml4 = {\n  nbsp: ' ',\n  iexcl: '¡',\n  cent: '¢',\n  pound: '£',\n  curren: '¤',\n  yen: '¥',\n  brvbar: '¦',\n  sect: '§',\n  uml: '¨',\n  copy: '©',\n  ordf: 'ª',\n  laquo: '«',\n  not: '¬',\n  shy: '­',\n  reg: '®',\n  macr: '¯',\n  deg: '°',\n  plusmn: '±',\n  sup2: '²',\n  sup3: '³',\n  acute: '´',\n  micro: 'µ',\n  para: '¶',\n  middot: '·',\n  cedil: '¸',\n  sup1: '¹',\n  ordm: 'º',\n  raquo: '»',\n  frac14: '¼',\n  frac12: '½',\n  frac34: '¾',\n  iquest: '¿',\n  Agrave: 'À',\n  Aacute: 'Á',\n  Acirc: 'Â',\n  Atilde: 'Ã',\n  Auml: 'Ä',\n  Aring: 'Å',\n  AElig: 'Æ',\n  Ccedil: 'Ç',\n  Egrave: 'È',\n  Eacute: 'É',\n  Ecirc: 'Ê',\n  Euml: 'Ë',\n  Igrave: 'Ì',\n  Iacute: 'Í',\n  Icirc: 'Î',\n  Iuml: 'Ï',\n  ETH: 'Ð',\n  Ntilde: 'Ñ',\n  Ograve: 'Ò',\n  Oacute: 'Ó',\n  Ocirc: 'Ô',\n  Otilde: 'Õ',\n  Ouml: 'Ö',\n  times: '×',\n  Oslash: 'Ø',\n  Ugrave: 'Ù',\n  Uacute: 'Ú',\n  Ucirc: 'Û',\n  Uuml: 'Ü',\n  Yacute: 'Ý',\n  THORN: 'Þ',\n  szlig: 'ß',\n  agrave: 'à',\n  aacute: 'á',\n  acirc: 'â',\n  atilde: 'ã',\n  auml: 'ä',\n  aring: 'å',\n  aelig: 'æ',\n  ccedil: 'ç',\n  egrave: 'è',\n  eacute: 'é',\n  ecirc: 'ê',\n  euml: 'ë',\n  igrave: 'ì',\n  iacute: 'í',\n  icirc: 'î',\n  iuml: 'ï',\n  eth: 'ð',\n  ntilde: 'ñ',\n  ograve: 'ò',\n  oacute: 'ó',\n  ocirc: 'ô',\n  otilde: 'õ',\n  ouml: 'ö',\n  divide: '÷',\n  oslash: 'ø',\n  ugrave: 'ù',\n  uacute: 'ú',\n  ucirc: 'û',\n  uuml: 'ü',\n  yacute: 'ý',\n  thorn: 'þ',\n  yuml: 'ÿ',\n  fnof: 'ƒ',\n  Alpha: 'Α',\n  Beta: 'Β',\n  Gamma: 'Γ',\n  Delta: 'Δ',\n  Epsilon: 'Ε',\n  Zeta: 'Ζ',\n  Eta: 'Η',\n  Theta: 'Θ',\n  Iota: 'Ι',\n  Kappa: 'Κ',\n  Lambda: 'Λ',\n  Mu: 'Μ',\n  Nu: 'Ν',\n  Xi: 'Ξ',\n  Omicron: 'Ο',\n  Pi: 'Π',\n  Rho: 'Ρ',\n  Sigma: 'Σ',\n  Tau: 'Τ',\n  Upsilon: 'Υ',\n  Phi: 'Φ',\n  Chi: 'Χ',\n  Psi: 'Ψ',\n  Omega: 'Ω',\n  alpha: 'α',\n  beta: 'β',\n  gamma: 'γ',\n  delta: 'δ',\n  epsilon: 'ε',\n  zeta: 'ζ',\n  eta: 'η',\n  theta: 'θ',\n  iota: 'ι',\n  kappa: 'κ',\n  lambda: 'λ',\n  mu: 'μ',\n  nu: 'ν',\n  xi: 'ξ',\n  omicron: 'ο',\n  pi: 'π',\n  rho: 'ρ',\n  sigmaf: 'ς',\n  sigma: 'σ',\n  tau: 'τ',\n  upsilon: 'υ',\n  phi: 'φ',\n  chi: 'χ',\n  psi: 'ψ',\n  omega: 'ω',\n  thetasym: 'ϑ',\n  upsih: 'ϒ',\n  piv: 'ϖ',\n  bull: '•',\n  hellip: '…',\n  prime: '′',\n  Prime: '″',\n  oline: '‾',\n  frasl: '⁄',\n  weierp: '℘',\n  image: 'ℑ',\n  real: 'ℜ',\n  trade: '™',\n  alefsym: 'ℵ',\n  larr: '←',\n  uarr: '↑',\n  rarr: '→',\n  darr: '↓',\n  harr: '↔',\n  crarr: '↵',\n  lArr: '⇐',\n  uArr: '⇑',\n  rArr: '⇒',\n  dArr: '⇓',\n  hArr: '⇔',\n  forall: '∀',\n  part: '∂',\n  exist: '∃',\n  empty: '∅',\n  nabla: '∇',\n  isin: '∈',\n  notin: '∉',\n  ni: '∋',\n  prod: '∏',\n  sum: '∑',\n  minus: '−',\n  lowast: '∗',\n  radic: '√',\n  prop: '∝',\n  infin: '∞',\n  ang: '∠',\n  and: '∧',\n  or: '∨',\n  cap: '∩',\n  cup: '∪',\n  int: '∫',\n  there4: '∴',\n  sim: '∼',\n  cong: '≅',\n  asymp: '≈',\n  ne: '≠',\n  equiv: '≡',\n  le: '≤',\n  ge: '≥',\n  sub: '⊂',\n  sup: '⊃',\n  nsub: '⊄',\n  sube: '⊆',\n  supe: '⊇',\n  oplus: '⊕',\n  otimes: '⊗',\n  perp: '⊥',\n  sdot: '⋅',\n  lceil: '⌈',\n  rceil: '⌉',\n  lfloor: '⌊',\n  rfloor: '⌋',\n  lang: '〈',\n  rang: '〉',\n  loz: '◊',\n  spades: '♠',\n  clubs: '♣',\n  hearts: '♥',\n  diams: '♦',\n  quot: '\"',\n  amp: '&',\n  lt: '<',\n  gt: '>',\n  OElig: 'Œ',\n  oelig: 'œ',\n  Scaron: 'Š',\n  scaron: 'š',\n  Yuml: 'Ÿ',\n  circ: 'ˆ',\n  tilde: '˜',\n  ensp: ' ',\n  emsp: ' ',\n  thinsp: ' ',\n  zwnj: '‌',\n  zwj: '‍',\n  lrm: '‎',\n  rlm: '‏',\n  ndash: '–',\n  mdash: '—',\n  lsquo: '‘',\n  rsquo: '’',\n  sbquo: '‚',\n  ldquo: '“',\n  rdquo: '”',\n  bdquo: '„',\n  dagger: '†',\n  Dagger: '‡',\n  permil: '‰',\n  lsaquo: '‹',\n  rsaquo: '›',\n  euro: '€'\n}\n", "/**\n * List of legacy (that don’t need a trailing `;`) named references which could,\n * depending on what follows them, turn into a different meaning\n *\n * @type {Array<string>}\n */\nexport const dangerous = [\n  'cent',\n  'copy',\n  'divide',\n  'gt',\n  'lt',\n  'not',\n  'para',\n  'times'\n]\n", "import {characterEntitiesLegacy} from 'character-entities-legacy'\nimport {characterEntitiesHtml4} from 'character-entities-html4'\nimport {dangerous} from '../constant/dangerous.js'\n\nconst own = {}.hasOwnProperty\n\n/**\n * `characterEntitiesHtml4` but inverted.\n *\n * @type {Record<string, string>}\n */\nconst characters = {}\n\n/** @type {string} */\nlet key\n\nfor (key in characterEntitiesHtml4) {\n  if (own.call(characterEntitiesHtml4, key)) {\n    characters[characterEntitiesHtml4[key]] = key\n  }\n}\n\n/**\n * Configurable ways to encode characters as named references.\n *\n * @param {number} code\n * @param {number} next\n * @param {boolean|undefined} omit\n * @param {boolean|undefined} attribute\n * @returns {string}\n */\nexport function toNamed(code, next, omit, attribute) {\n  const character = String.fromCharCode(code)\n\n  if (own.call(characters, character)) {\n    const name = characters[character]\n    const value = '&' + name\n\n    if (\n      omit &&\n      characterEntitiesLegacy.includes(name) &&\n      !dangerous.includes(name) &&\n      (!attribute ||\n        (next &&\n          next !== 61 /* `=` */ &&\n          /[^\\da-z]/i.test(String.fromCharCode(next))))\n    ) {\n      return value\n    }\n\n    return value + ';'\n  }\n\n  return ''\n}\n", "/**\n * @typedef FormatSmartOptions\n * @property {boolean} [useNamedReferences=false]\n *   Prefer named character references (`&amp;`) where possible.\n * @property {boolean} [useShortestReferences=false]\n *   Prefer the shortest possible reference, if that results in less bytes.\n *   **Note**: `useNamedReferences` can be omitted when using `useShortestReferences`.\n * @property {boolean} [omitOptionalSemicolons=false]\n *   Whether to omit semicolons when possible.\n *   **Note**: This creates what HTML calls “parse errors” but is otherwise still valid HTML — don’t use this except when building a minifier.\n *   Omitting semicolons is possible for certain named and numeric references in some cases.\n * @property {boolean} [attribute=false]\n *   Create character references which don’t fail in attributes.\n *   **Note**: `attribute` only applies when operating dangerously with\n *   `omitOptionalSemicolons: true`.\n */\n\nimport {toHexadecimal} from './to-hexadecimal.js'\nimport {toDecimal} from './to-decimal.js'\nimport {toNamed} from './to-named.js'\n\n/**\n * Configurable ways to encode a character yielding pretty or small results.\n *\n * @param {number} code\n * @param {number} next\n * @param {FormatSmartOptions} options\n * @returns {string}\n */\nexport function formatSmart(code, next, options) {\n  let numeric = toHexadecimal(code, next, options.omitOptionalSemicolons)\n  /** @type {string|undefined} */\n  let named\n\n  if (options.useNamedReferences || options.useShortestReferences) {\n    named = toNamed(\n      code,\n      next,\n      options.omitOptionalSemicolons,\n      options.attribute\n    )\n  }\n\n  // Use the shortest numeric reference when requested.\n  // A simple algorithm would use decimal for all code points under 100, as\n  // those are shorter than hexadecimal:\n  //\n  // * `&#99;` vs `&#x63;` (decimal shorter)\n  // * `&#100;` vs `&#x64;` (equal)\n  //\n  // However, because we take `next` into consideration when `omit` is used,\n  // And it would be possible that decimals are shorter on bigger values as\n  // well if `next` is hexadecimal but not decimal, we instead compare both.\n  if (\n    (options.useShortestReferences || !named) &&\n    options.useShortestReferences\n  ) {\n    const decimal = toDecimal(code, next, options.omitOptionalSemicolons)\n\n    if (decimal.length < numeric.length) {\n      numeric = decimal\n    }\n  }\n\n  return named &&\n    (!options.useShortestReferences || named.length < numeric.length)\n    ? named\n    : numeric\n}\n", "/**\n * @typedef {import('./core.js').CoreOptions & import('./util/format-smart.js').FormatSmartOptions} Options\n * @typedef {import('./core.js').CoreOptions} LightOptions\n */\n\nimport {core} from './core.js'\nimport {formatSmart} from './util/format-smart.js'\nimport {formatBasic} from './util/format-basic.js'\n\n/**\n * Encode special characters in `value`.\n *\n * @param {string} value\n *   Value to encode.\n * @param {Options} [options]\n *   Configuration.\n * @returns {string}\n *   Encoded value.\n */\nexport function stringifyEntities(value, options) {\n  return core(value, Object.assign({format: formatSmart}, options))\n}\n\n/**\n * Encode special characters in `value` as hexadecimals.\n *\n * @param {string} value\n *   Value to encode.\n * @param {LightOptions} [options]\n *   Configuration.\n * @returns {string}\n *   Encoded value.\n */\nexport function stringifyEntitiesLight(value, options) {\n  return core(value, Object.assign({format: formatBasic}, options))\n}\n", "/**\n * @typedef {import('../types.js').Comment} Comment\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n */\n\nimport {stringifyEntities} from 'stringify-entities'\n\n/**\n * Serialize a comment.\n *\n * @param {Comment} node\n *   Node to handle.\n * @param {number | undefined} _1\n *   Index of `node` in `parent.\n * @param {Parent | undefined} _2\n *   Parent of `node`.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {string}\n *   Serialized node.\n */\nexport function comment(node, _1, _2, state) {\n  // See: <https://html.spec.whatwg.org/multipage/syntax.html#comments>\n  return state.settings.bogusComments\n    ? '<?' +\n        stringifyEntities(\n          node.value,\n          Object.assign({}, state.settings.characterReferences, {subset: ['>']})\n        ) +\n        '>'\n    : '<!--' + node.value.replace(/^>|^->|<!--|-->|--!>|<!-$/g, encode) + '-->'\n\n  /**\n   * @param {string} $0\n   */\n  function encode($0) {\n    return stringifyEntities(\n      $0,\n      Object.assign({}, state.settings.characterReferences, {\n        subset: ['<', '>']\n      })\n    )\n  }\n}\n", "/**\n * @typedef {import('../types.js').DocType} DocType\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * Serialize a doctype.\n *\n * @param {DocType} _1\n *   Node to handle.\n * @param {number | undefined} _2\n *   Index of `node` in `parent.\n * @param {Parent | undefined} _3\n *   Parent of `node`.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {string}\n *   Serialized node.\n */\nexport function doctype(_1, _2, _3, state) {\n  return (\n    '<!' +\n    (state.settings.upperDoctype ? 'DOCTYPE' : 'doctype') +\n    (state.settings.tightDoctype ? '' : ' ') +\n    'html>'\n  )\n}\n", "/**\n * Count how often a character (or substring) is used in a string.\n *\n * @param {string} value\n *   Value to search in.\n * @param {string} character\n *   Character (or substring) to look for.\n * @return {number}\n *   Number of times `character` occurred in `value`.\n */\nexport function ccount(value, character) {\n  const source = String(value)\n\n  if (typeof character !== 'string') {\n    throw new TypeError('Expected character')\n  }\n\n  let count = 0\n  let index = source.indexOf(character)\n\n  while (index !== -1) {\n    count++\n    index = source.indexOf(character, index + character.length)\n  }\n\n  return count\n}\n", "/**\n * Check if the given value is *inter-element whitespace*.\n *\n * @param {unknown} thing\n *   Thing to check (typically `Node` or `string`).\n * @returns {boolean}\n *   Whether the `value` is inter-element whitespace (`boolean`): consisting of\n *   zero or more of space, tab (`\\t`), line feed (`\\n`), carriage return\n *   (`\\r`), or form feed (`\\f`).\n *   If a node is passed it must be a `Text` node, whose `value` field is\n *   checked.\n */\nexport function whitespace(thing) {\n  /** @type {string} */\n  const value =\n    // @ts-expect-error looks like a node.\n    thing && typeof thing === 'object' && thing.type === 'text'\n      ? // @ts-expect-error looks like a text.\n        thing.value || ''\n      : thing\n\n  // HTML whitespace expression.\n  // See <https://infra.spec.whatwg.org/#ascii-whitespace>.\n  return typeof value === 'string' && value.replace(/[ \\t\\n\\f\\r]/g, '') === ''\n}\n", "/**\n * @typedef {import('../../types.js').Parent} Parent\n * @typedef {import('../../types.js').Content} Content\n */\n\nimport {whitespace} from 'hast-util-whitespace'\n\nexport const siblingAfter = siblings(1)\nexport const siblingBefore = siblings(-1)\n\n/**\n * Factory to check siblings in a direction.\n *\n * @param {number} increment\n */\nfunction siblings(increment) {\n  return sibling\n\n  /**\n   * Find applicable siblings in a direction.\n   *\n   * @param {Parent | null | undefined} parent\n   * @param {number | null | undefined} index\n   * @param {boolean | null | undefined} [includeWhitespace=false]\n   * @returns {Content}\n   */\n  function sibling(parent, index, includeWhitespace) {\n    const siblings = parent ? parent.children : []\n    let offset = (index || 0) + increment\n    let next = siblings && siblings[offset]\n\n    if (!includeWhitespace) {\n      while (next && whitespace(next)) {\n        offset += increment\n        next = siblings[offset]\n      }\n    }\n\n    return next\n  }\n}\n", "/**\n * @typedef {import('../types.js').OmitHandle} OmitHandle\n */\n\nconst own = {}.hasOwnProperty\n\n/**\n * Factory to check if a given node can have a tag omitted.\n *\n * @param {Record<string, OmitHandle>} handlers\n *   Omission handlers, where each key is a tag name, and each value is the\n *   corresponding handler.\n * @returns {OmitHandle}\n *   Whether to omit a tag of an element.\n */\nexport function omission(handlers) {\n  return omit\n\n  /**\n   * Check if a given node can have a tag omitted.\n   *\n   * @type {OmitHandle}\n   */\n  function omit(node, index, parent) {\n    return (\n      own.call(handlers, node.tagName) &&\n      handlers[node.tagName](node, index, parent)\n    )\n  }\n}\n", "/**\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').Parent} Parent\n */\n\nimport {whitespace} from 'hast-util-whitespace'\nimport {siblingAfter} from './util/siblings.js'\nimport {omission} from './omission.js'\n\nexport const closing = omission({\n  html,\n  head: headOrColgroupOrCaption,\n  body,\n  p,\n  li,\n  dt,\n  dd,\n  rt: rubyElement,\n  rp: rubyElement,\n  optgroup,\n  option,\n  menuitem,\n  colgroup: headOrColgroupOrCaption,\n  caption: headOrColgroupOrCaption,\n  thead,\n  tbody,\n  tfoot,\n  tr,\n  td: cells,\n  th: cells\n})\n\n/**\n * Macro for `</head>`, `</colgroup>`, and `</caption>`.\n *\n * @param {Element} _\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parent | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the closing tag can be omitted.\n */\nfunction headOrColgroupOrCaption(_, index, parent) {\n  const next = siblingAfter(parent, index, true)\n  return (\n    !next ||\n    (next.type !== 'comment' &&\n      !(next.type === 'text' && whitespace(next.value.charAt(0))))\n  )\n}\n\n/**\n * Whether to omit `</html>`.\n *\n * @param {Element} _\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parent | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the closing tag can be omitted.\n */\nfunction html(_, index, parent) {\n  const next = siblingAfter(parent, index)\n  return !next || next.type !== 'comment'\n}\n\n/**\n * Whether to omit `</body>`.\n *\n * @param {Element} _\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parent | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the closing tag can be omitted.\n */\nfunction body(_, index, parent) {\n  const next = siblingAfter(parent, index)\n  return !next || next.type !== 'comment'\n}\n\n/**\n * Whether to omit `</p>`.\n *\n * @param {Element} _\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parent | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the closing tag can be omitted.\n */\n// eslint-disable-next-line complexity\nfunction p(_, index, parent) {\n  const next = siblingAfter(parent, index)\n  return next\n    ? next.type === 'element' &&\n        (next.tagName === 'address' ||\n          next.tagName === 'article' ||\n          next.tagName === 'aside' ||\n          next.tagName === 'blockquote' ||\n          next.tagName === 'details' ||\n          next.tagName === 'div' ||\n          next.tagName === 'dl' ||\n          next.tagName === 'fieldset' ||\n          next.tagName === 'figcaption' ||\n          next.tagName === 'figure' ||\n          next.tagName === 'footer' ||\n          next.tagName === 'form' ||\n          next.tagName === 'h1' ||\n          next.tagName === 'h2' ||\n          next.tagName === 'h3' ||\n          next.tagName === 'h4' ||\n          next.tagName === 'h5' ||\n          next.tagName === 'h6' ||\n          next.tagName === 'header' ||\n          next.tagName === 'hgroup' ||\n          next.tagName === 'hr' ||\n          next.tagName === 'main' ||\n          next.tagName === 'menu' ||\n          next.tagName === 'nav' ||\n          next.tagName === 'ol' ||\n          next.tagName === 'p' ||\n          next.tagName === 'pre' ||\n          next.tagName === 'section' ||\n          next.tagName === 'table' ||\n          next.tagName === 'ul')\n    : !parent ||\n        // Confusing parent.\n        !(\n          parent.type === 'element' &&\n          (parent.tagName === 'a' ||\n            parent.tagName === 'audio' ||\n            parent.tagName === 'del' ||\n            parent.tagName === 'ins' ||\n            parent.tagName === 'map' ||\n            parent.tagName === 'noscript' ||\n            parent.tagName === 'video')\n        )\n}\n\n/**\n * Whether to omit `</li>`.\n *\n * @param {Element} _\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parent | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the closing tag can be omitted.\n */\nfunction li(_, index, parent) {\n  const next = siblingAfter(parent, index)\n  return !next || (next.type === 'element' && next.tagName === 'li')\n}\n\n/**\n * Whether to omit `</dt>`.\n *\n * @param {Element} _\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parent | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the closing tag can be omitted.\n */\nfunction dt(_, index, parent) {\n  const next = siblingAfter(parent, index)\n  return (\n    next &&\n    next.type === 'element' &&\n    (next.tagName === 'dt' || next.tagName === 'dd')\n  )\n}\n\n/**\n * Whether to omit `</dd>`.\n *\n * @param {Element} _\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parent | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the closing tag can be omitted.\n */\nfunction dd(_, index, parent) {\n  const next = siblingAfter(parent, index)\n  return (\n    !next ||\n    (next.type === 'element' &&\n      (next.tagName === 'dt' || next.tagName === 'dd'))\n  )\n}\n\n/**\n * Whether to omit `</rt>` or `</rp>`.\n *\n * @param {Element} _\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parent | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the closing tag can be omitted.\n */\nfunction rubyElement(_, index, parent) {\n  const next = siblingAfter(parent, index)\n  return (\n    !next ||\n    (next.type === 'element' &&\n      (next.tagName === 'rp' || next.tagName === 'rt'))\n  )\n}\n\n/**\n * Whether to omit `</optgroup>`.\n *\n * @param {Element} _\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parent | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the closing tag can be omitted.\n */\nfunction optgroup(_, index, parent) {\n  const next = siblingAfter(parent, index)\n  return !next || (next.type === 'element' && next.tagName === 'optgroup')\n}\n\n/**\n * Whether to omit `</option>`.\n *\n * @param {Element} _\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parent | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the closing tag can be omitted.\n */\nfunction option(_, index, parent) {\n  const next = siblingAfter(parent, index)\n  return (\n    !next ||\n    (next.type === 'element' &&\n      (next.tagName === 'option' || next.tagName === 'optgroup'))\n  )\n}\n\n/**\n * Whether to omit `</menuitem>`.\n *\n * @param {Element} _\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parent | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the closing tag can be omitted.\n */\nfunction menuitem(_, index, parent) {\n  const next = siblingAfter(parent, index)\n  return (\n    !next ||\n    (next.type === 'element' &&\n      (next.tagName === 'menuitem' ||\n        next.tagName === 'hr' ||\n        next.tagName === 'menu'))\n  )\n}\n\n/**\n * Whether to omit `</thead>`.\n *\n * @param {Element} _\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parent | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the closing tag can be omitted.\n */\nfunction thead(_, index, parent) {\n  const next = siblingAfter(parent, index)\n  return (\n    next &&\n    next.type === 'element' &&\n    (next.tagName === 'tbody' || next.tagName === 'tfoot')\n  )\n}\n\n/**\n * Whether to omit `</tbody>`.\n *\n * @param {Element} _\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parent | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the closing tag can be omitted.\n */\nfunction tbody(_, index, parent) {\n  const next = siblingAfter(parent, index)\n  return (\n    !next ||\n    (next.type === 'element' &&\n      (next.tagName === 'tbody' || next.tagName === 'tfoot'))\n  )\n}\n\n/**\n * Whether to omit `</tfoot>`.\n *\n * @param {Element} _\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parent | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the closing tag can be omitted.\n */\nfunction tfoot(_, index, parent) {\n  return !siblingAfter(parent, index)\n}\n\n/**\n * Whether to omit `</tr>`.\n *\n * @param {Element} _\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parent | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the closing tag can be omitted.\n */\nfunction tr(_, index, parent) {\n  const next = siblingAfter(parent, index)\n  return !next || (next.type === 'element' && next.tagName === 'tr')\n}\n\n/**\n * Whether to omit `</td>` or `</th>`.\n *\n * @param {Element} _\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parent | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the closing tag can be omitted.\n */\nfunction cells(_, index, parent) {\n  const next = siblingAfter(parent, index)\n  return (\n    !next ||\n    (next.type === 'element' &&\n      (next.tagName === 'td' || next.tagName === 'th'))\n  )\n}\n", "/**\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').Content} Content\n */\n\nimport {whitespace} from 'hast-util-whitespace'\nimport {siblingBefore, siblingAfter} from './util/siblings.js'\nimport {closing} from './closing.js'\nimport {omission} from './omission.js'\n\nexport const opening = omission({\n  html,\n  head,\n  body,\n  colgroup,\n  tbody\n})\n\n/**\n * Whether to omit `<html>`.\n *\n * @param {Element} node\n *   Element.\n * @returns {boolean}\n *   Whether the opening tag can be omitted.\n */\nfunction html(node) {\n  const head = siblingAfter(node, -1)\n  return !head || head.type !== 'comment'\n}\n\n/**\n * Whether to omit `<head>`.\n *\n * @param {Element} node\n *   Element.\n * @returns {boolean}\n *   Whether the opening tag can be omitted.\n */\nfunction head(node) {\n  const children = node.children\n  /** @type {Array<string>} */\n  const seen = []\n  let index = -1\n\n  while (++index < children.length) {\n    const child = children[index]\n    if (\n      child.type === 'element' &&\n      (child.tagName === 'title' || child.tagName === 'base')\n    ) {\n      if (seen.includes(child.tagName)) return false\n      seen.push(child.tagName)\n    }\n  }\n\n  return children.length > 0\n}\n\n/**\n * Whether to omit `<body>`.\n *\n * @param {Element} node\n *   Element.\n * @returns {boolean}\n *   Whether the opening tag can be omitted.\n */\nfunction body(node) {\n  const head = siblingAfter(node, -1, true)\n\n  return (\n    !head ||\n    (head.type !== 'comment' &&\n      !(head.type === 'text' && whitespace(head.value.charAt(0))) &&\n      !(\n        head.type === 'element' &&\n        (head.tagName === 'meta' ||\n          head.tagName === 'link' ||\n          head.tagName === 'script' ||\n          head.tagName === 'style' ||\n          head.tagName === 'template')\n      ))\n  )\n}\n\n/**\n * Whether to omit `<colgroup>`.\n * The spec describes some logic for the opening tag, but it’s easier to\n * implement in the closing tag, to the same effect, so we handle it there\n * instead.\n *\n * @param {Element} node\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parent | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the opening tag can be omitted.\n */\nfunction colgroup(node, index, parent) {\n  const previous = siblingBefore(parent, index)\n  const head = siblingAfter(node, -1, true)\n\n  // Previous colgroup was already omitted.\n  if (\n    parent &&\n    previous &&\n    previous.type === 'element' &&\n    previous.tagName === 'colgroup' &&\n    closing(previous, parent.children.indexOf(previous), parent)\n  ) {\n    return false\n  }\n\n  return head && head.type === 'element' && head.tagName === 'col'\n}\n\n/**\n * Whether to omit `<tbody>`.\n *\n * @param {Element} node\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parent | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the opening tag can be omitted.\n */\nfunction tbody(node, index, parent) {\n  const previous = siblingBefore(parent, index)\n  const head = siblingAfter(node, -1)\n\n  // Previous table section was already omitted.\n  if (\n    parent &&\n    previous &&\n    previous.type === 'element' &&\n    (previous.tagName === 'thead' || previous.tagName === 'tbody') &&\n    closing(previous, parent.children.indexOf(previous), parent)\n  ) {\n    return false\n  }\n\n  return head && head.type === 'element' && head.tagName === 'tr'\n}\n", "/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').Element} Element\n * @typedef {import('../types.js').Properties} Properties\n * @typedef {import('../types.js').PropertyValue} PropertyValue\n */\n\nimport {ccount} from 'ccount'\nimport {stringify as commas} from 'comma-separated-tokens'\nimport {svg, find} from 'property-information'\nimport {stringify as spaces} from 'space-separated-tokens'\nimport {stringifyEntities} from 'stringify-entities'\nimport {opening} from '../omission/opening.js'\nimport {closing} from '../omission/closing.js'\n\n/**\n * Maps of subsets.\n *\n * Each value is a matrix of tuples.\n * The value at `0` causes parse errors, the value at `1` is valid.\n * Of both, the value at `0` is unsafe, and the value at `1` is safe.\n *\n * @type {Record<'name' | 'unquoted' | 'single' | 'double', Array<[Array<string>, Array<string>]>>}\n */\nconst constants = {\n  // See: <https://html.spec.whatwg.org/#attribute-name-state>.\n  name: [\n    ['\\t\\n\\f\\r &/=>'.split(''), '\\t\\n\\f\\r \"&\\'/=>`'.split('')],\n    ['\\0\\t\\n\\f\\r \"&\\'/<=>'.split(''), '\\0\\t\\n\\f\\r \"&\\'/<=>`'.split('')]\n  ],\n  // See: <https://html.spec.whatwg.org/#attribute-value-(unquoted)-state>.\n  unquoted: [\n    ['\\t\\n\\f\\r &>'.split(''), '\\0\\t\\n\\f\\r \"&\\'<=>`'.split('')],\n    ['\\0\\t\\n\\f\\r \"&\\'<=>`'.split(''), '\\0\\t\\n\\f\\r \"&\\'<=>`'.split('')]\n  ],\n  // See: <https://html.spec.whatwg.org/#attribute-value-(single-quoted)-state>.\n  single: [\n    [\"&'\".split(''), '\"&\\'`'.split('')],\n    [\"\\0&'\".split(''), '\\0\"&\\'`'.split('')]\n  ],\n  // See: <https://html.spec.whatwg.org/#attribute-value-(double-quoted)-state>.\n  double: [\n    ['\"&'.split(''), '\"&\\'`'.split('')],\n    ['\\0\"&'.split(''), '\\0\"&\\'`'.split('')]\n  ]\n}\n\n/**\n * Serialize an element node.\n *\n * @param {Element} node\n *   Node to handle.\n * @param {number | undefined} index\n *   Index of `node` in `parent.\n * @param {Parent | undefined} parent\n *   Parent of `node`.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {string}\n *   Serialized node.\n */\n// eslint-disable-next-line complexity\nexport function element(node, index, parent, state) {\n  const schema = state.schema\n  const omit = schema.space === 'svg' ? false : state.settings.omitOptionalTags\n  let selfClosing =\n    schema.space === 'svg'\n      ? state.settings.closeEmptyElements\n      : state.settings.voids.includes(node.tagName.toLowerCase())\n  /** @type {Array<string>} */\n  const parts = []\n  /** @type {string} */\n  let last\n\n  if (schema.space === 'html' && node.tagName === 'svg') {\n    state.schema = svg\n  }\n\n  const attrs = serializeAttributes(state, node.properties)\n\n  const content = state.all(\n    schema.space === 'html' && node.tagName === 'template' ? node.content : node\n  )\n\n  state.schema = schema\n\n  // If the node is categorised as void, but it has children, remove the\n  // categorisation.\n  // This enables for example `menuitem`s, which are void in W3C HTML but not\n  // void in WHATWG HTML, to be stringified properly.\n  if (content) selfClosing = false\n\n  if (attrs || !omit || !opening(node, index, parent)) {\n    parts.push('<', node.tagName, attrs ? ' ' + attrs : '')\n\n    if (\n      selfClosing &&\n      (schema.space === 'svg' || state.settings.closeSelfClosing)\n    ) {\n      last = attrs.charAt(attrs.length - 1)\n      if (\n        !state.settings.tightSelfClosing ||\n        last === '/' ||\n        (last && last !== '\"' && last !== \"'\")\n      ) {\n        parts.push(' ')\n      }\n\n      parts.push('/')\n    }\n\n    parts.push('>')\n  }\n\n  parts.push(content)\n\n  if (!selfClosing && (!omit || !closing(node, index, parent))) {\n    parts.push('</' + node.tagName + '>')\n  }\n\n  return parts.join('')\n}\n\n/**\n * @param {State} state\n * @param {Properties | null | undefined} props\n * @returns {string}\n */\nfunction serializeAttributes(state, props) {\n  /** @type {Array<string>} */\n  const values = []\n  let index = -1\n  /** @type {string} */\n  let key\n\n  if (props) {\n    for (key in props) {\n      if (props[key] !== undefined && props[key] !== null) {\n        const value = serializeAttribute(state, key, props[key])\n        if (value) values.push(value)\n      }\n    }\n  }\n\n  while (++index < values.length) {\n    const last = state.settings.tightAttributes\n      ? values[index].charAt(values[index].length - 1)\n      : null\n\n    // In tight mode, don’t add a space after quoted attributes.\n    if (index !== values.length - 1 && last !== '\"' && last !== \"'\") {\n      values[index] += ' '\n    }\n  }\n\n  return values.join('')\n}\n\n/**\n * @param {State} state\n * @param {string} key\n * @param {PropertyValue} value\n * @returns {string}\n */\n// eslint-disable-next-line complexity\nfunction serializeAttribute(state, key, value) {\n  const info = find(state.schema, key)\n  const x =\n    state.settings.allowParseErrors && state.schema.space === 'html' ? 0 : 1\n  const y = state.settings.allowDangerousCharacters ? 0 : 1\n  let quote = state.quote\n  /** @type {string | undefined} */\n  let result\n\n  if (info.overloadedBoolean && (value === info.attribute || value === '')) {\n    value = true\n  } else if (\n    info.boolean ||\n    (info.overloadedBoolean && typeof value !== 'string')\n  ) {\n    value = Boolean(value)\n  }\n\n  if (\n    value === undefined ||\n    value === null ||\n    value === false ||\n    (typeof value === 'number' && Number.isNaN(value))\n  ) {\n    return ''\n  }\n\n  const name = stringifyEntities(\n    info.attribute,\n    Object.assign({}, state.settings.characterReferences, {\n      // Always encode without parse errors in non-HTML.\n      subset: constants.name[x][y]\n    })\n  )\n\n  // No value.\n  // There is currently only one boolean property in SVG: `[download]` on\n  // `<a>`.\n  // This property does not seem to work in browsers (Firefox, Safari, Chrome),\n  // so I can’t test if dropping the value works.\n  // But I assume that it should:\n  //\n  // ```html\n  // <!doctype html>\n  // <svg viewBox=\"0 0 100 100\">\n  //   <a href=https://example.com download>\n  //     <circle cx=50 cy=40 r=35 />\n  //   </a>\n  // </svg>\n  // ```\n  //\n  // See: <https://github.com/wooorm/property-information/blob/main/lib/svg.js>\n  if (value === true) return name\n\n  // `spaces` doesn’t accept a second argument, but it’s given here just to\n  // keep the code cleaner.\n  value = Array.isArray(value)\n    ? (info.commaSeparated ? commas : spaces)(value, {\n        padLeft: !state.settings.tightCommaSeparatedLists\n      })\n    : String(value)\n\n  if (state.settings.collapseEmptyAttributes && !value) return name\n\n  // Check unquoted value.\n  if (state.settings.preferUnquoted) {\n    result = stringifyEntities(\n      value,\n      Object.assign({}, state.settings.characterReferences, {\n        subset: constants.unquoted[x][y],\n        attribute: true\n      })\n    )\n  }\n\n  // If we don’t want unquoted, or if `value` contains character references when\n  // unquoted…\n  if (result !== value) {\n    // If the alternative is less common than `quote`, switch.\n    if (\n      state.settings.quoteSmart &&\n      ccount(value, quote) > ccount(value, state.alternative)\n    ) {\n      quote = state.alternative\n    }\n\n    result =\n      quote +\n      stringifyEntities(\n        value,\n        Object.assign({}, state.settings.characterReferences, {\n          // Always encode without parse errors in non-HTML.\n          subset: (quote === \"'\" ? constants.single : constants.double)[x][y],\n          attribute: true\n        })\n      ) +\n      quote\n  }\n\n  // Don’t add a `=` for unquoted empties.\n  return name + (result ? '=' + result : result)\n}\n", "/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').Raw} Raw\n * @typedef {import('../types.js').Text} Text\n */\n\nimport {stringifyEntities} from 'stringify-entities'\n\n/**\n * Serialize a text node.\n *\n * @param {Text | Raw} node\n *   Node to handle.\n * @param {number | undefined} _\n *   Index of `node` in `parent.\n * @param {Parent | undefined} parent\n *   Parent of `node`.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {string}\n *   Serialized node.\n */\nexport function text(node, _, parent, state) {\n  // Check if content of `node` should be escaped.\n  return parent &&\n    parent.type === 'element' &&\n    (parent.tagName === 'script' || parent.tagName === 'style')\n    ? node.value\n    : stringifyEntities(\n        node.value,\n        Object.assign({}, state.settings.characterReferences, {\n          subset: ['<', '&']\n        })\n      )\n}\n", "/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').Raw} Raw\n */\n\nimport {text} from './text.js'\n\n/**\n * Serialize a raw node.\n *\n * @param {Raw} node\n *   Node to handle.\n * @param {number | undefined} index\n *   Index of `node` in `parent.\n * @param {Parent | undefined} parent\n *   Parent of `node`.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {string}\n *   Serialized node.\n */\nexport function raw(node, index, parent, state) {\n  return state.settings.allowDangerousHtml\n    ? node.value\n    : text(node, index, parent, state)\n}\n", "/**\n * @typedef {import('../types.js').Root} Root\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * Serialize a root.\n *\n * @param {Root} node\n *   Node to handle.\n * @param {number | undefined} _1\n *   Index of `node` in `parent.\n * @param {Parent | undefined} _2\n *   Parent of `node`.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {string}\n *   Serialized node.\n */\nexport function root(node, _1, _2, state) {\n  return state.all(node)\n}\n", "/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Node} Node\n * @typedef {import('../types.js').Parent} Parent\n */\n\nimport {zwitch} from 'zwitch'\nimport {comment} from './comment.js'\nimport {doctype} from './doctype.js'\nimport {element} from './element.js'\nimport {raw} from './raw.js'\nimport {root} from './root.js'\nimport {text} from './text.js'\n\n/**\n * @type {(node: Node, index: number | undefined, parent: Parent | undefined, state: State) => string}\n */\nexport const handle = zwitch('type', {\n  invalid,\n  unknown,\n  handlers: {comment, doctype, element, raw, root, text}\n})\n\n/**\n * Fail when a non-node is found in the tree.\n *\n * @param {unknown} node\n *   Unknown value.\n * @returns {never}\n *   Never.\n */\nfunction invalid(node) {\n  throw new Error('Expected node, not `' + node + '`')\n}\n\n/**\n * Fail when a node with an unknown type is found in the tree.\n *\n * @param {unknown} node\n *  Unknown node.\n * @returns {never}\n *   Never.\n */\nfunction unknown(node) {\n  // @ts-expect-error: `type` is defined.\n  throw new Error('Cannot compile unknown node `' + node.type + '`')\n}\n", "/**\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').Parent} Parent\n * @typedef {import('./types.js').Content} Content\n * @typedef {import('./types.js').Options} Options\n * @typedef {import('./types.js').State} State\n */\n\nimport {html, svg} from 'property-information'\nimport {htmlVoidElements} from 'html-void-elements'\nimport {handle} from './handle/index.js'\n\n/**\n * Serialize hast as HTML.\n *\n * @param {Node | Array<Content>} tree\n *   Tree to serialize.\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {string}\n *   Serialized HTML.\n */\n// eslint-disable-next-line complexity\nexport function toHtml(tree, options) {\n  const options_ = options || {}\n  const quote = options_.quote || '\"'\n  const alternative = quote === '\"' ? \"'\" : '\"'\n\n  if (quote !== '\"' && quote !== \"'\") {\n    throw new Error('Invalid quote `' + quote + '`, expected `\\'` or `\"`')\n  }\n\n  /** @type {State} */\n  const state = {\n    one,\n    all,\n    settings: {\n      omitOptionalTags: options_.omitOptionalTags || false,\n      allowParseErrors: options_.allowParseErrors || false,\n      allowDangerousCharacters: options_.allowDangerousCharacters || false,\n      quoteSmart: options_.quoteSmart || false,\n      preferUnquoted: options_.preferUnquoted || false,\n      tightAttributes: options_.tightAttributes || false,\n      upperDoctype: options_.upperDoctype || false,\n      tightDoctype: options_.tightDoctype || false,\n      bogusComments: options_.bogusComments || false,\n      tightCommaSeparatedLists: options_.tightCommaSeparatedLists || false,\n      tightSelfClosing: options_.tightSelfClosing || false,\n      collapseEmptyAttributes: options_.collapseEmptyAttributes || false,\n      allowDangerousHtml: options_.allowDangerousHtml || false,\n      voids: options_.voids || htmlVoidElements,\n      characterReferences:\n        options_.characterReferences || options_.entities || {},\n      closeSelfClosing: options_.closeSelfClosing || false,\n      closeEmptyElements: options_.closeEmptyElements || false\n    },\n    schema: options_.space === 'svg' ? svg : html,\n    quote,\n    alternative\n  }\n\n  return state.one(\n    Array.isArray(tree) ? {type: 'root', children: tree} : tree,\n    undefined,\n    undefined\n  )\n}\n\n/**\n * Serialize a node.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {Node} node\n *   Node to handle.\n * @param {number | undefined} index\n *   Index of `node` in `parent.\n * @param {Parent | undefined} parent\n *   Parent of `node`.\n * @returns {string}\n *   Serialized node.\n */\nfunction one(node, index, parent) {\n  return handle(node, index, parent, this)\n}\n\n/**\n * Serialize all children of `parent`.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {Parent | undefined} parent\n *   Parent whose children to serialize.\n * @returns {string}\n */\nexport function all(parent) {\n  /** @type {Array<string>} */\n  const results = []\n  const children = (parent && parent.children) || []\n  let index = -1\n\n  while (++index < children.length) {\n    results[index] = this.one(children[index], index, parent)\n  }\n\n  return results.join('')\n}\n", "import {toHtml} from 'hast-util-to-html'\n\nimport type {SvgElement} from '@tracespace/renderer'\n\nexport function stringifySvg(element: SvgElement): string {\n  return toHtml(element, {space: 'svg'})\n}\n", "import {s} from 'hastscript'\n\nimport * as parser from '@tracespace/parser'\nimport * as plotter from '@tracespace/plotter'\nimport * as renderer from '@tracespace/renderer'\nimport {random as randomId} from '@tracespace/xml-id'\nimport {SIDE_TOP, SIDE_BOTTOM} from '@tracespace/identify-layers'\n\nimport type {GerberTree} from '@tracespace/parser'\nimport type {ImageTree} from '@tracespace/plotter'\nimport type {GerberType, GerberSide} from '@tracespace/identify-layers'\nimport type {SvgElement, ViewBox} from '@tracespace/renderer'\n\nimport {readFile} from './read-file'\nimport {determineLayerTypes} from './determine-layer-types'\nimport {plotBoardShape, renderBoardShape} from './board-shape'\nimport {getDrillLayers, getSideLayers} from './sort-layers'\nimport {stringifySvg} from './stringify-svg'\n\nimport type {ParsedLayer} from './determine-layer-types'\nimport type {BoardShape, BoardShapeRender} from './board-shape'\nimport type {Side, SideLayers} from './sort-layers'\n\nexport {stringifySvg} from './stringify-svg'\n\nexport interface Layer {\n  id: string\n  filename: string\n  type: GerberType\n  side: GerberSide\n}\n\nexport interface ReadResult {\n  layers: Layer[]\n  parseTreesById: Record<string, GerberTree>\n}\n\nexport interface PlotResult {\n  layers: Layer[]\n  plotTreesById: Record<string, ImageTree>\n  boardShape: BoardShape\n}\n\nexport interface RenderLayersResult {\n  layers: Layer[]\n  rendersById: Record<string, SvgElement>\n  boardShapeRender: BoardShapeRender\n}\n\nexport interface RenderBoardResult extends Record<Side, SvgElement> {}\n\nexport interface BoardShapeRenderFragment {\n  viewBox: ViewBox\n  svgFragment?: string\n}\n\nexport interface RenderFragmentsResult {\n  layers: Layer[]\n  topLayers: SideLayers\n  bottomLayers: SideLayers\n  drillLayers: string[]\n  boardShapeRenderFragment: BoardShapeRenderFragment\n  svgFragmentsById: Record<string, string>\n}\n\nexport async function read(files: File[] | string[]): Promise<ReadResult> {\n  const readTasks = files.map(readAndParseFile)\n  const parsedLayers = await Promise.all(readTasks)\n  const layerTypesById = determineLayerTypes(parsedLayers)\n  const layers: Layer[] = []\n  const parseTreesById: Record<string, GerberTree> = {}\n\n  for (const {id, filename, parseTree} of parsedLayers) {\n    const {type, side} = layerTypesById[id]\n\n    layers.push({id, filename, type, side})\n    parseTreesById[id] = parseTree\n  }\n\n  return {layers, parseTreesById}\n}\n\nasync function readAndParseFile(file: File | string): Promise<ParsedLayer> {\n  const id = randomId()\n  const {filename, contents} = await readFile(file)\n  const parseTree = parser.parse(contents)\n\n  return {id, filename, parseTree}\n}\n\nexport function plot(readResult: ReadResult): PlotResult {\n  const {layers, parseTreesById} = readResult\n  const plotTreesById: Record<string, ImageTree> = {}\n\n  for (const {id} of layers) {\n    plotTreesById[id] = plotter.plot(parseTreesById[id])\n  }\n\n  const boardShape = plotBoardShape(layers, plotTreesById, 0.02)\n\n  return {layers, plotTreesById, boardShape}\n}\n\nexport function renderLayers(plotResult: PlotResult): RenderLayersResult {\n  const {layers, boardShape, plotTreesById} = plotResult\n  const boardShapeRender = renderBoardShape(boardShape)\n  const rendersById: Record<string, SvgElement> = {}\n\n  for (const {id} of layers) {\n    rendersById[id] = renderer.render(\n      plotTreesById[id],\n      boardShapeRender.viewBox\n    )\n  }\n\n  return {layers, rendersById, boardShapeRender}\n}\n\nexport function renderBoard(\n  renderLayersResult: RenderLayersResult\n): RenderBoardResult {\n  const {layers, rendersById, boardShapeRender} = renderLayersResult\n  const {viewBox, path: shapeRender} = boardShapeRender\n  const drillLayers = getDrillLayers(layers)\n\n  const [x, y, width, height] = viewBox\n  const result: Partial<RenderBoardResult> = {}\n\n  const getRenderChildren = (id: string) => rendersById[id].children\n\n  for (const side of [SIDE_TOP, SIDE_BOTTOM] as const) {\n    const {\n      copper: copperLayers,\n      solderMask: resistLayers,\n      silkScreen: silkLayers,\n      solderPaste: pasteLayers,\n    } = getSideLayers(side, layers)\n\n    const id = randomId()\n    const drillMaskId = `drill-${id}`\n    const resistMaskId = `resist-${id}`\n    const shapeClipId = `shape-${id}`\n\n    const clipPath = shapeRender ? `url(#${shapeClipId})` : undefined\n    const transform =\n      side === SIDE_BOTTOM\n        ? `translate(${2 * x + width},0) scale(-1,1)`\n        : undefined\n\n    result[side] = s(\n      'svg',\n      {\n        ...renderer.BASE_SVG_PROPS,\n        ...renderer.BASE_IMAGE_PROPS,\n        viewBox: `${x} ${y} ${width} ${height}`,\n      },\n      [\n        s('defs', [\n          s('mask', {id: drillMaskId}, [\n            s('rect', {x, y, width, height, fill: '#fff'}),\n            s('g', {color: '#000'}, drillLayers.flatMap(getRenderChildren)),\n          ]),\n          s('mask', {id: resistMaskId}, [\n            s('rect', {x, y, width, height, fill: '#fff'}),\n            s('g', {color: '#000'}, resistLayers.flatMap(getRenderChildren)),\n          ]),\n          shapeRender\n            ? s('clipPath', {id: shapeClipId}, shapeRender)\n            : undefined,\n        ]),\n        s('g', {transform, 'clip-path': clipPath}, [\n          s('g', {mask: `url(#${drillMaskId})`}, [\n            s('rect', {fill: '#666', x, y, width, height}),\n            s('g', {color: '#c93'}, copperLayers.flatMap(getRenderChildren)),\n          ]),\n          s('g', {mask: `url(#${resistMaskId})`}, [\n            s('rect', {fill: '#004200', opacity: '0.8', x, y, width, height}),\n            s('g', {color: '#fff'}, silkLayers.flatMap(getRenderChildren)),\n          ]),\n          s('g', {color: '#999'}, pasteLayers.flatMap(getRenderChildren)),\n        ]),\n      ]\n    )\n  }\n\n  return result as RenderBoardResult\n}\n\nexport function renderFragments(plotResult: PlotResult): RenderFragmentsResult {\n  const {layers, plotTreesById, boardShape} = plotResult\n  const {viewBox, path: boardShapePath} = renderBoardShape(boardShape)\n  const topLayers = getSideLayers(SIDE_TOP, layers)\n  const bottomLayers = getSideLayers(SIDE_BOTTOM, layers)\n  const drillLayers = getDrillLayers(layers)\n  const boardShapeRenderFragment = {\n    viewBox,\n    svgFragment: boardShapePath ? stringifySvg(boardShapePath) : undefined,\n  }\n\n  const svgFragmentsById: Record<string, string> = {}\n\n  for (const {id} of layers) {\n    svgFragmentsById[id] = stringifySvg(\n      renderer.renderFragment(plotTreesById[id])\n    )\n  }\n\n  return {\n    layers,\n    topLayers,\n    bottomLayers,\n    drillLayers,\n    boardShapeRenderFragment,\n    svgFragmentsById,\n  }\n}\n"],
  "mappings": "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AAO,aAAaA,EAAI,CAAC,IACvDhN,KACAA,KAAQ;AACd;ACRO,IAAMmN,KAA0B;EACrC;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACF;AA3GO,ICAMC,KAAyB;EACpC,MAAM;EACN,OAAO;EACP,MAAM;EACN,OAAO;EACP,QAAQ;EACR,KAAK;EACL,QAAQ;EACR,MAAM;EACN,KAAK;EACL,MAAM;EACN,MAAM;EACN,OAAO;EACP,KAAK;EACL,KAAK;EACL,KAAK;EACL,MAAM;EACN,KAAK;EACL,QAAQ;EACR,MAAM;EACN,MAAM;EACN,OAAO;EACP,OAAO;EACP,MAAM;EACN,QAAQ;EACR,OAAO;EACP,MAAM;EACN,MAAM;EACN,OAAO;EACP,QAAQ;EACR,QAAQ;EACR,QAAQ;EACR,QAAQ;EACR,QAAQ;EACR,QAAQ;EACR,OAAO;EACP,QAAQ;EACR,MAAM;EACN,OAAO;EACP,OAAO;EACP,QAAQ;EACR,QAAQ;EACR,QAAQ;EACR,OAAO;EACP,MAAM;EACN,QAAQ;EACR,QAAQ;EACR,OAAO;EACP,MAAM;EACN,KAAK;EACL,QAAQ;EACR,QAAQ;EACR,QAAQ;EACR,OAAO;EACP,QAAQ;EACR,MAAM;EACN,OAAO;EACP,QAAQ;EACR,QAAQ;EAC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",
  "names": ["root", "factory", "module", "this", "hasOwnProperty", "toString", "hasSticky", "isRegExp", "o", "isObject", "reEscape", "s", "reGroups", "re", "reCapture", "reUnion", "regexps", "source", "regexpOrLiteral", "obj", "pad", "length", "lastNLines", "string", "numLines", "position", "lineBreaks", "idx", "startPosition", "objectToRules", "object", "keys", "result", "i", "key", "thing", "rules", "j", "match", "rule", "ruleOptions", "arrayToRules", "array", "include", "type", "options", "a", "b", "toRules", "spec", "defaultErrorRule", "compileRules", "hasStates", "errorRule", "fast", "fastAllowed", "unicodeFlag", "groups", "parts", "word", "pat", "regexp", "groupCount", "fallbackRule", "flags", "suffix", "combined", "compile", "Lexer", "checkStateGroup", "g", "name", "map", "state", "compileStates", "states", "start", "all", "ruleMap", "included", "splice", "newRules", "k", "newRule", "fastKeys", "keywordTransform", "isMap", "reverseMap", "types", "tokenType", "item", "keywordList", "keyword", "data", "info", "eat", "buffer", "tokenToString", "index", "token", "group", "error", "text", "offset", "matchNL", "nl", "size", "err", "LexerIterator", "lexer", "message", "numLinesAround", "firstDisplayedLine", "lastDisplayedLine", "lastLineDigits", "displayedLines", "errorLines", "line", "lineNo", "T_CODE", "G_CODE", "M_CODE", "D_CODE", "ASTERISK", "PERCENT", "EQUALS", "COMMA", "OPERATOR", "GERBER_FORMAT", "GERBER_UNITS", "GERBER_TOOL_MACRO", "GERBER_TOOL_DEF", "GERBER_LOAD_POLARITY", "GERBER_STEP_REPEAT", "GERBER_MACRO_VARIABLE", "SEMICOLON", "DRILL_UNITS", "DRILL_ZERO_INCLUSION", "COORD_CHAR", "NUMBER", "WORD", "WHITESPACE", "NEWLINE", "CATCHALL", "ERROR", "RE_STRIP_LEADING_ZEROS", "stripLeadingZeros", "getCodeValue", "Tokens.T_CODE", "Tokens.G_CODE", "Tokens.M_CODE", "Tokens.D_CODE", "Tokens.ASTERISK", "Tokens.PERCENT", "Tokens.EQUALS", "Tokens.GERBER_FORMAT", "Tokens.GERBER_UNITS", "Tokens.GERBER_TOOL_MACRO", "Tokens.GERBER_TOOL_DEF", "Tokens.GERBER_LOAD_POLARITY", "Tokens.GERBER_STEP_REPEAT", "Tokens.GERBER_MACRO_VARIABLE", "Tokens.SEMICOLON", "Tokens.DRILL_UNITS", "Tokens.DRILL_ZERO_INCLUSION", "Tokens.COORD_CHAR", "Tokens.NUMBER", "Tokens.OPERATOR", "Tokens.COMMA", "Tokens.WORD", "Tokens.WHITESPACE", "Tokens.NEWLINE", "Tokens.CATCHALL", "Tokens.ERROR", "Moo", "createLexer", "mooLexer", "feed", "chunk", "tokenIterator", "nextToken", "nextState", "GERBER", "DRILL", "MM", "IN", "LEADING", "TRAILING", "ABSOLUTE", "INCREMENTAL", "CIRCLE", "RECTANGLE", "OBROUND", "POLYGON", "MACRO_SHAPE", "MACRO_CIRCLE", "MACRO_VECTOR_LINE_DEPRECATED", "MACRO_VECTOR_LINE", "MACRO_CENTER_LINE", "MACRO_LOWER_LEFT_LINE_DEPRECATED", "MACRO_OUTLINE", "MACRO_POLYGON", "MACRO_MOIRE_DEPRECATED", "MACRO_THERMAL", "SHAPE", "MOVE", "SEGMENT", "SLOT", "LINE", "CW_ARC", "CCW_ARC", "SINGLE", "MULTI", "DARK", "CLEAR", "SINGLE_TOKEN", "MIN_TO_MAX", "value", "notToken", "one", "zeroOrOne", "zeroOrMore", "oneOrMore", "minToMax", "min", "max", "findSyntaxMatch", "tokens", "candidates", "remainingCandidates", "candidate", "matchType", "tokenListMatches", "PARTIAL_MATCH", "FULL_MATCH", "NO_MATCH", "multiMatchCount", "tokenMatches", "typeResult", "valueResult", "r", "ROOT", "COMMENT", "DRILL_HEADER", "DONE", "UNITS", "COORDINATE_FORMAT", "TOOL_DEFINITION", "TOOL_MACRO", "TOOL_CHANGE", "LOAD_POLARITY", "STEP_REPEAT", "GRAPHIC", "INTERPOLATE_MODE", "REGION_MODE", "QUADRANT_MODE", "UNIMPLEMENTED", "MACRO_COMMENT", "MACRO_VARIABLE", "MACRO_PRIMITIVE", "tokensToCoordinates", "previousToken", "tokensToMode", "t", "tokensToGraphic", "tokensToString", "tokensToPosition", "head", "tail", "units", "Lexer.DRILL_UNITS", "Lexer.M_CODE", "Lexer.COMMA", "Lexer.DRILL_ZERO_INCLUSION", "Lexer.NUMBER", "Lexer.NEWLINE", "Constants.IN", "Constants.MM", "zeroSuppression", "Constants.TRAILING", "Constants.LEADING", "format", "integer", "decimal", "nodes", "Tree.UNITS", "Tree.COORDINATE_FORMAT", "tool", "Lexer.T_CODE", "Lexer.COORD_CHAR", "code", "c", "shape", "Constants.CIRCLE", "Tree.TOOL_DEFINITION", "Tree.TOOL_CHANGE", "mode", "Lexer.G_CODE", "Tree.INTERPOLATE_MODE", "operation", "graphicTokens", "P", "modeToken", "toolToken", "coordinates", "graphicPosition", "modePosition", "toolPosition", "Tree.GRAPHIC", "slot", "gCode", "splitIdx", "axis", "end", "Constants.SLOT", "done", "Tree.DONE", "header", "Lexer.PERCENT", "Tree.DRILL_HEADER", "comment", "Lexer.SEMICOLON", "Tree.COMMENT", "drillGrammar", "e", "Constants.DRILL", "macroComment", "Lexer.ASTERISK", "createMacroComment", "macroVariable", "Lexer.GERBER_MACRO_VARIABLE", "Lexer.EQUALS", "Lexer.OPERATOR", "createMacroVariable", "macroPrimitive", "createMacroPrimitive", "Tree.MACRO_COMMENT", "commaDelimitedTokens", "currentGroup", "parameters", "parseMacroExpression", "Tree.MACRO_PRIMITIVE", "Tree.MACRO_VARIABLE", "toParse", "parseAddition", "peekNextToken", "parsePrimary", "expression", "parseMultiplication", "operator", "right", "MACRO_GRAMMAR", "parseMacroBlocks", "matchedCandidates", "matchedTokens", "blocks", "holeShape", "diameter", "xSize", "ySize", "Constants.RECTANGLE", "Lexer.GERBER_FORMAT", "Lexer.GERBER_UNITS", "coords", "formatEndIdx", "O", "unitsToken", "Constants.INCREMENTAL", "Constants.ABSOLUTE", "_a", "integers", "decimals", "toolMacro", "Lexer.GERBER_TOOL_MACRO", "blockTokens", "Tree.TOOL_MACRO", "toolDefinition", "Lexer.GERBER_TOOL_DEF", "hole", "toolProps", "p", "holeParameters", "Constants.OBROUND", "vertices", "rotation", "Constants.POLYGON", "Constants.MACRO_SHAPE", "toolChange", "Lexer.D_CODE", "createOperationNodes", "graphic", "operationWithoutCoords", "interpolationMode", "regionMode", "Tree.REGION_MODE", "quadrantMode", "Tree.QUADRANT_MODE", "Constants.SINGLE", "Constants.MULTI", "loadPolarity", "Lexer.GERBER_LOAD_POLARITY", "Tree.LOAD_POLARITY", "Constants.DARK", "Constants.CLEAR", "stepRepeat", "Lexer.GERBER_STEP_REPEAT", "coordinateString", "Tree.STEP_REPEAT", "unimplementedExtendedCommand", "Tree.UNIMPLEMENTED", "gerberGrammar", "Constants.GERBER", "grammar", "matchSyntax", "filetype", "getGrammar", "nextLexerState", "unmatched", "lexerState", "createParser", "children", "parser", "parse", "contents", "IMAGE", "IMAGE_SHAPE", "IMAGE_PATH", "IMAGE_REGION", "LINE", "ARC", "CIRCLE", "RECTANGLE", "POLYGON", "OUTLINE", "LAYERED_SHAPE", "PI", "HALF_PI", "THREE_HALF_PI", "TWO_PI", "limitAngle", "theta", "rotateQuadrant", "degreesToRadians", "degrees", "rotateAndShift", "point", "shift", "rotation", "sin", "cos", "x", "y", "nextX", "nextY", "positionsEqual", "a", "b", "isEmpty", "box", "empty", "add", "sum", "boxes", "fromGraphics", "graphics", "fromGraphic", "graphic", "Tree.IMAGE_SHAPE", "fromShape", "fromPath", "Tree.IMAGE_PATH", "shape", "Tree.CIRCLE", "cx", "cy", "r", "fromPosition", "Tree.RECTANGLE", "xSize", "ySize", "Tree.POLYGON", "e", "p", "Tree.OUTLINE", "Tree.LAYERED_SHAPE", "erase", "segments", "width", "rTool", "keyPoints", "segment", "Tree.ARC", "start", "end", "center", "radius", "sweep", "thetaStart", "thetaEnd", "axisPoints", "position", "FORMAT_COMMENT_RE", "getPlotOptions", "tree", "treeNodes", "units", "coordinateFormat", "zeroSuppression", "index", "node", "UNITS", "COORDINATE_FORMAT", "GRAPHIC", "coordinates", "coordinate", "LEADING", "TRAILING", "COMMENT", "comment", "formatMatch", "IN", "SIMPLE_TOOL", "MACRO_TOOL", "createToolStore", "ToolStorePrototype", "TOOL_MACRO", "TOOL_DEFINITION", "hole", "tool", "MACRO_SHAPE", "TOOL_CHANGE", "createLocationStore", "LocationStorePrototype", "options", "arcOffsets", "startPoint", "endPoint", "x0", "parseCoordinate", "y0", "i", "j", "defaultValue", "integerPlaces", "decimalPlaces", "sign", "signlessCoordinate", "digits", "paddedCoordinate", "leading", "trailing", "createShape", "diameter", "OBROUND", "xHalf", "yHalf", "rectangle", "vertices", "offset", "step", "points", "_", "pointX", "pointY", "shapeToSegments", "Tree.LINE", "endIndex", "plotShape", "location", "toolShape", "toolHole", "holeShape", "plotRectPath", "shapes", "s", "plotRectPathSegment", "sx", "sy", "ex", "ey", "xOffset", "yOffset", "sxMin", "sxMax", "syMin", "syMax", "exMin", "exMax", "eyMin", "eyMax", "CW", "CCW", "plotSegment", "arcDirection", "ambiguousArcCenter", "createLineSegment", "createArcSegment", "plotPath", "region", "Tree.IMAGE_REGION", "findCenterCandidates", "centerPoint", "getArcPositions", "startA", "endA", "startB", "endB", "absSweepA", "absSweepB", "startAngle", "endAngle", "x1", "y1", "x2", "y2", "dx", "dy", "distance", "factor", "xBase", "yBase", "xAddend", "yAddend", "plotMacro", "variableValues", "value", "block", "MACRO_VARIABLE", "solveExpression", "MACRO_PRIMITIVE", "origin", "parameters", "plotPrimitive", "expression", "variables", "left", "right", "code", "MACRO_CIRCLE", "plotCircle", "MACRO_VECTOR_LINE", "MACRO_VECTOR_LINE_DEPRECATED", "plotVectorLine", "MACRO_CENTER_LINE", "plotCenterLine", "MACRO_LOWER_LEFT_LINE_DEPRECATED", "plotLowerLeftLine", "MACRO_OUTLINE", "plotOutline", "MACRO_POLYGON", "plotPolygon", "MACRO_MOIRE_DEPRECATED", "plotMoire", "MACRO_THERMAL", "plotThermal", "exposure", "cx0", "cy0", "halfWid", "dist", "xOff", "yOff", "height", "halfWidth", "halfHeight", "coords", "rotate", "d", "ringThx", "ringGap", "ringN", "lineThx", "lineLength", "halfLineThx", "halfLineLength", "radii", "count", "dRemain", "rHole", "od", "id", "gap", "or", "ir", "halfGap", "oIntSquare", "iIntSquare", "oInt", "iInt", "positions", "rot", "os", "oe", "oc", "is", "ie", "ic", "createGraphicPlotter", "filetype", "plotter", "GraphicPlotterPrototype", "DRILL", "DrillGraphicPlotterTrait", "nextGraphicType", "pathGraphic", "SHAPE", "SEGMENT", "SLOT", "INTERPOLATE_MODE", "arcDirectionFromMode", "QUADRANT_MODE", "SINGLE", "REGION_MODE", "nextTool", "DONE", "MOVE", "mode", "CW_ARC", "CCW_ARC", "plot", "plotOptions", "toolStore", "locationStore", "graphicPlotter", "children", "sizeFromGraphics", "START_CHAR", "CHAR", "REPLACE_RE", "DEFAULT_RANDOM_LENGTH", "random", "length", "_getRandomString", "_getRandomString", "length", "alphabet", "abLength", "result", "Schema", "property", "normal", "space", "merge", "definitions", "index", "normalize", "value", "Info", "attribute", "powers", "boolean", "increment", "booleanish", "overloadedBoolean", "number", "spaceSeparated", "commaSeparated", "commaOrSpaceSeparated", "checks", "types", "DefinedInfo", "mask", "mark", "check", "values", "key", "own", "create", "definition", "prop", "info", "xlink", "_", "xml", "caseSensitiveTransform", "attributes", "caseInsensitiveTransform", "xmlns", "aria", "html", "svg", "valid", "dash", "cap", "find", "schema", "Type", "rest", "camelcase", "dashes", "kebab", "$0", "htmlBase", "svgBase", "search", "parseSelector", "selector", "defaultTagName", "props", "start", "previous", "tagName", "match", "subvalue", "parse", "input", "tokens", "end", "token", "buttonTypes", "core", "caseSensitive", "adjust", "createAdjustMap", "properties", "children", "node", "isProperties", "addProperty", "addChild", "name", "result", "spaces", "commas", "parsePrimitive", "style", "finalResult", "nodes", "svgCaseSensitiveTagNames", "s", "renderGraphic", "IMAGE_SHAPE", "renderShape", "renderPath", "shape", "shapeToElement", "CIRCLE", "cx", "cy", "r", "RECTANGLE", "x", "y", "width", "height", "POLYGON", "points", "OUTLINE", "segmentsToPathData", "LAYERED_SHAPE", "boundingBox", "BoundingBox", "clipIdBase", "createId", "defs", "i", "layerShape", "clipId", "pathData", "IMAGE_PATH", "segments", "pathCommands", "next", "positionsEqual", "LINE", "ARC", "sweep", "absSweep", "center", "radius", "sweepFlag", "largeFlag", "mx", "my", "BASE_SVG_PROPS", "BASE_IMAGE_PROPS", "render", "image", "viewBox", "units", "size", "sizeToViewBox", "renderFragment", "getCommonCad", "matches", "mode", "modeCount", "countsByCad", "match", "cad", "count", "TYPE_COPPER", "TYPE_SOLDERMASK", "TYPE_SILKSCREEN", "TYPE_SOLDERPASTE", "TYPE_DRILL", "TYPE_OUTLINE", "TYPE_DRAWING", "SIDE_TOP", "SIDE_BOTTOM", "SIDE_INNER", "SIDE_ALL", "CAD_KICAD", "CAD_ALTIUM", "CAD_ALLEGRO", "CAD_EAGLE", "CAD_EAGLE_LEGACY", "CAD_EAGLE_OSHPARK", "CAD_EAGLE_PCBNG", "CAD_GEDA_PCB", "CAD_ORCAD", "CAD_DIPTRACE", "layerTypes", "matchers", "layer", "matcher", "cadList", "getMatches", "filename", "m", "identifyLayers", "filenames", "f", "commonCad", "_selectMatch", "layerId", "_selectMatch", "matches", "filename", "cad", "filenameMatches", "match", "Schema", "property", "normal", "space", "merge", "definitions", "index", "normalize", "value", "Info", "attribute", "powers", "boolean", "increment", "booleanish", "overloadedBoolean", "number", "spaceSeparated", "commaSeparated", "commaOrSpaceSeparated", "checks", "types", "DefinedInfo", "mask", "mark", "check", "values", "key", "own", "create", "definition", "prop", "info", "xlink", "_", "xml", "caseSensitiveTransform", "attributes", "caseInsensitiveTransform", "xmlns", "aria", "html", "svg", "valid", "dash", "cap", "find", "schema", "Type", "rest", "camelcase", "dashes", "kebab", "$0", "htmlBase", "svgBase", "search", "parseSelector", "selector", "defaultTagName", "props", "start", "previous", "tagName", "match", "subvalue", "parse", "input", "stringify", "tokens", "end", "token", "options", "settings", "buttonTypes", "core", "caseSensitive", "adjust", "createAdjustMap", "properties", "children", "node", "isProperties", "addProperty", "addChild", "name", "result", "spaces", "commas", "parsePrimitive", "style", "finalResult", "nodes", "svgCaseSensitiveTagNames", "s", "readFile", "file", "readNodeFile", "readBrowserFile", "resolve", "reject", "reader", "handleLoad", "handleError", "contents", "fs", "path", "filename", "determineLayerTypes", "layers", "gerberFilenames", "layer", "GERBER", "identitiesByFilename", "identifyLayers", "id", "parseTree", "layerIdentity", "DRILL", "TYPE_DRILL", "SIDE_ALL", "toId", "isType", "type", "side", "getOutlineLayer", "TYPE_OUTLINE", "getDrillLayers", "getSideLayers", "TYPE_COPPER", "TYPE_SOLDERMASK", "TYPE_SILKSCREEN", "TYPE_SOLDERPASTE", "walkPaths", "segments", "segmentsById", "segmentIdsByPointId", "segment", "segmentId", "hashSegment", "point", "pointId", "hashPoint", "pointSegmentIds", "PointMapPrototype", "results", "firstSegment", "lastSegment", "startId", "endId", "nextPointId", "reverseSegment", "segmentIds", "nextId", "sortPoints", "a", "b", "segmentsToRegion", "IMAGE_REGION", "segmentsToPath", "IMAGE_PATH", "fillGaps", "pathWalks", "maximumGap", "maximumSquareGap", "walksToCheck", "closedPaths", "openPaths", "pathWalk", "smallestGap", "squareDistance", "nearestPathWalk", "nearestEndPoint", "otherWalk", "otherEndPoint", "gap", "gapFill", "LINE", "nearestPathWalkIndex", "nearestPathSegments", "nearestPathEnd", "MISSING_OUTLINE_LAYER", "NO_PATHS_IN_OUTLINE_LAYER", "NO_CLOSED_REGIONS_FOUND", "plotBoardShape", "plotTreesById", "outlineId", "outlinePlot", "size", "BoundingBox", "inputSegments", "allPaths", "regions", "renderBoardShape", "boardShape", "failureReason", "viewBox", "sizeToViewBox", "r", "renderGraphic", "htmlVoidElements", "zwitch", "one", "parameters", "fn", "handlers", "charactersToExpression", "basic", "surrogate", "pair", "all", "character", "subset", "groups", "toHexadecimal", "code", "next", "omit", "toDecimal", "characterEntitiesLegacy", "characterEntitiesHtml4", "dangerous", "characters", "toNamed", "formatSmart", "numeric", "named", "decimal", "stringifyEntities", "comment", "_1", "_2", "state", "encode", "doctype", "_3", "ccount", "source", "count", "whitespace", "thing", "siblingAfter", "siblings", "siblingBefore", "sibling", "parent", "includeWhitespace", "offset", "omission", "closing", "headOrColgroupOrCaption", "body", "p", "li", "dt", "dd", "rubyElement", "optgroup", "option", "menuitem", "thead", "tbody", "tfoot", "tr", "cells", "opening", "head", "colgroup", "seen", "child", "constants", "element", "selfClosing", "parts", "last", "attrs", "serializeAttributes", "content", "serializeAttribute", "x", "y", "quote", "text", "raw", "root", "handle", "invalid", "unknown", "toHtml", "tree", "options_", "alternative", "stringifySvg", "read", "files", "readTasks", "readAndParseFile", "parsedLayers", "layerTypesById", "parseTreesById", "randomId", "plot", "readResult", "Pe", "renderLayers", "plotResult", "boardShapeRender", "rendersById", "Tn", "renderBoard", "renderLayersResult", "shapeRender", "drillLayers", "width", "height", "getRenderChildren", "SIDE_TOP", "SIDE_BOTTOM", "copperLayers", "resistLayers", "silkLayers", "pasteLayers", "drillMaskId", "resistMaskId", "shapeClipId", "clipPath", "transform", "On", "renderFragments", "boardShapePath", "topLayers", "bottomLayers", "boardShapeRenderFragment", "svgFragmentsById", "In"]
}
