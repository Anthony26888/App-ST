import {
  propsFactory
} from "./chunk-L7BCP7WI.js";
import {
  computed
} from "./chunk-3AID4HRN.js";

// node_modules/vuetify/lib/composables/fileDrop.js
function useFileDrop() {
  function hasFilesOrFolders(e) {
    var _a, _b;
    const entries = [...((_a = e.dataTransfer) == null ? void 0 : _a.items) ?? []].filter((x) => x.kind === "file").map((x) => x.webkitGetAsEntry()).filter(Boolean);
    return entries.length > 0 || [...((_b = e.dataTransfer) == null ? void 0 : _b.files) ?? []].length > 0;
  }
  async function handleDrop(e) {
    var _a, _b;
    const result = [];
    const entries = [...((_a = e.dataTransfer) == null ? void 0 : _a.items) ?? []].filter((x) => x.kind === "file").map((x) => x.webkitGetAsEntry()).filter(Boolean);
    if (entries.length) {
      for (const entry of entries) {
        const files = await traverseFileTree(entry, appendIfDirectory(".", entry));
        result.push(...files.map((x) => x.file));
      }
    } else {
      result.push(...[...((_b = e.dataTransfer) == null ? void 0 : _b.files) ?? []]);
    }
    return result;
  }
  return {
    handleDrop,
    hasFilesOrFolders
  };
}
function traverseFileTree(item) {
  let path = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  return new Promise((resolve, reject) => {
    if (item.isFile) {
      const fileEntry = item;
      fileEntry.file((file) => resolve([{
        file,
        path
      }]), reject);
    } else if (item.isDirectory) {
      const directoryReader = item.createReader();
      directoryReader.readEntries(async (entries) => {
        const files = [];
        for (const entry of entries) {
          files.push(...await traverseFileTree(entry, appendIfDirectory(path, entry)));
        }
        resolve(files);
      });
    }
  });
}
function appendIfDirectory(path, item) {
  return item.isDirectory ? `${path}/${item.name}` : path;
}

// node_modules/vuetify/lib/composables/fileFilter.js
var makeFileFilterProps = propsFactory({
  filterByType: String
}, "file-accept");
function useFileFilter(props) {
  const fileFilter = computed(() => props.filterByType ? createFilter(props.filterByType) : null);
  function filterAccepted(files) {
    if (fileFilter.value) {
      const accepted = files.filter(fileFilter.value);
      return {
        accepted,
        rejected: files.filter((f) => !accepted.includes(f))
      };
    }
    return {
      accepted: files,
      rejected: []
    };
  }
  return {
    filterAccepted
  };
}
function createFilter(v) {
  const types = v.split(",").map((x) => x.trim().toLowerCase());
  const extensionsToMatch = types.filter((x) => x.startsWith("."));
  const wildcards = types.filter((x) => x.endsWith("/*"));
  const typesToMatch = types.filter((x) => !extensionsToMatch.includes(x) && !wildcards.includes(x));
  return (file) => {
    var _a, _b;
    const extension = ((_a = file.name.split(".").at(-1)) == null ? void 0 : _a.toLowerCase()) ?? "";
    const typeGroup = ((_b = file.type.split("/").at(0)) == null ? void 0 : _b.toLowerCase()) ?? "";
    return typesToMatch.includes(file.type) || extensionsToMatch.includes(`.${extension}`) || wildcards.includes(`${typeGroup}/*`);
  };
}

export {
  useFileDrop,
  makeFileFilterProps,
  useFileFilter
};
//# sourceMappingURL=chunk-7VXUX5MQ.js.map
