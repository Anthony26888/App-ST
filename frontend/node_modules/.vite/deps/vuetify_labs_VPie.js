import "./chunk-VYFZB4Q5.js";
import {
  VChip,
  VChipGroup
} from "./chunk-OHWNHECU.js";
import "./chunk-QAGZVBFL.js";
import "./chunk-M3HAA6O2.js";
import "./chunk-I4P65TBE.js";
import {
  VListItem
} from "./chunk-34F733P3.js";
import {
  VAvatar
} from "./chunk-C23MKR52.js";
import "./chunk-UWKTDH47.js";
import "./chunk-3CISPLSG.js";
import "./chunk-M2N6KY2A.js";
import "./chunk-CQSR7BOX.js";
import "./chunk-QLJO3M3V.js";
import {
  makeDensityProps
} from "./chunk-XQWCU3HW.js";
import {
  VDefaultsProvider
} from "./chunk-5UQO3VC6.js";
import "./chunk-OMML3Y46.js";
import "./chunk-HPLLAY7P.js";
import "./chunk-LL63OEC5.js";
import "./chunk-P7NDENUQ.js";
import "./chunk-6ORG55J4.js";
import "./chunk-NZ736MDQ.js";
import {
  VTooltip,
  makeVTooltipProps
} from "./chunk-5I3SAU5F.js";
import "./chunk-XENYZ5JW.js";
import "./chunk-BKGZARYA.js";
import {
  click_outside_default
} from "./chunk-QQRM4QT4.js";
import "./chunk-UAF5KOYB.js";
import "./chunk-4EYNSNEF.js";
import "./chunk-K3TN6V6M.js";
import "./chunk-WCY2OBQG.js";
import {
  MaybeTransition,
  makeTransitionProps
} from "./chunk-C46MMJ2L.js";
import "./chunk-S53BDZRL.js";
import "./chunk-TXJGLU6Y.js";
import {
  useColor
} from "./chunk-4OY3DU3L.js";
import "./chunk-Q6AHXGRR.js";
import "./chunk-P6CIPOTL.js";
import "./chunk-6G5TKWIH.js";
import {
  useProxiedModel
} from "./chunk-ROWYW5VW.js";
import "./chunk-OGAEBNJK.js";
import {
  clamp,
  convertToUnit,
  easingPatterns,
  genericComponent,
  pick,
  propsFactory,
  useTransition
} from "./chunk-L7BCP7WI.js";
import {
  computed,
  createBaseVNode,
  createVNode,
  mergeProps,
  normalizeClass,
  normalizeStyle,
  onMounted,
  shallowRef,
  toRef,
  toValue,
  watch,
  withDirectives
} from "./chunk-3AID4HRN.js";
import "./chunk-FM7WUVZV.js";

// node_modules/vuetify/lib/labs/VPie/VPie.js
import "/Users/anthony/Desktop/code/App-ST/frontend/node_modules/vuetify/lib/labs/VPie/VPie.css";

// node_modules/vuetify/lib/composables/reveal.js
var makeRevealProps = propsFactory({
  reveal: {
    type: [Boolean, Object],
    default: false
  }
}, "reveal");
function useReveal(props) {
  const defaultDuration = 900;
  const duration = toRef(() => typeof props.reveal === "object" ? Math.max(0, Number(props.reveal.duration ?? defaultDuration)) : defaultDuration);
  const state = shallowRef(props.reveal ? "initial" : "disabled");
  onMounted(async () => {
    if (props.reveal) {
      state.value = "initial";
      await new Promise((resolve) => requestAnimationFrame(resolve));
      state.value = "pending";
      await new Promise((resolve) => setTimeout(resolve, duration.value));
      state.value = "done";
    }
  });
  return {
    duration,
    state
  };
}

// node_modules/vuetify/lib/util/svg-arc-corners.js
function pointOnArc(center, radius, angle) {
  const radians = (angle - 90) * Math.PI / 180;
  return [center[0] + radius * Math.cos(radians), center[1] + radius * Math.sin(radians)];
}
function drawCircle(_ref, r, width) {
  let [x, y] = _ref;
  const innerRadius = r - width;
  return ["M", x - r, y, "A", r, r, 0, 1, 0, x + r, y, "A", r, r, 0, 1, 0, x - r, y, "M", x - innerRadius, y, "A", innerRadius, innerRadius, 0, 1, 0, x + innerRadius, y, "A", innerRadius, innerRadius, 0, 1, 0, x - innerRadius, y, "Z"];
}
function simpleArc(center, r, startAngle, endAngle) {
  const start = pointOnArc(center, r, startAngle);
  const end = pointOnArc(center, r, endAngle);
  const sweep = endAngle - startAngle > 180 ? 1 : 0;
  return [`M${start[0]} ${start[1]}`, `A${r} ${r} 0 ${sweep} 1 ${end[0]} ${end[1]}`, `L${center[0]} ${center[1]}Z`].join(" ");
}
function roundedArc(center, radius, startAngle, endAngle, width, rounding) {
  width = Math.min(radius, width);
  if (Math.abs(endAngle - startAngle) === 360) {
    return drawCircle(center, radius, width).join(" ");
  }
  if (rounding === 0 && radius === width) {
    return simpleArc(center, radius, startAngle, endAngle);
  }
  const innerR = radius - width;
  const circumference = Math.abs(endAngle - startAngle);
  rounding = Math.min(width / 2, rounding);
  if (360 * (rounding / (Math.PI * (radius - width))) > Math.abs(startAngle - endAngle)) {
    rounding = circumference / 360 * innerR * Math.PI;
  }
  const innerR2 = innerR + rounding;
  const outerRadius = radius - rounding;
  const oStart = pointOnArc(center, outerRadius, startAngle);
  const oEnd = pointOnArc(center, outerRadius, endAngle);
  const iStart = pointOnArc(center, innerR2, startAngle);
  const iEnd = pointOnArc(center, innerR2, endAngle);
  const iSection = innerR ? 360 * (rounding / (2 * Math.PI * innerR)) : 0;
  const oSection = 360 * (rounding / (2 * Math.PI * radius));
  const iArcStart = pointOnArc(center, innerR, startAngle + iSection);
  const iArcEnd = pointOnArc(center, innerR, endAngle - iSection);
  const oArcStart = pointOnArc(center, radius, startAngle + oSection);
  const oArcEnd = pointOnArc(center, radius, endAngle - oSection);
  const arcSweep1 = circumference > 180 + 2 * oSection ? 1 : 0;
  const arcSweep2 = circumference > 180 + 2 * iSection ? 1 : 0;
  return [
    // begin path
    "M",
    oStart[0],
    oStart[1],
    // outer start corner
    "A",
    rounding,
    rounding,
    0,
    0,
    1,
    oArcStart[0],
    oArcStart[1],
    // outer main arc
    "A",
    radius,
    radius,
    0,
    arcSweep1,
    1,
    oArcEnd[0],
    oArcEnd[1],
    // outer end corner
    "A",
    rounding,
    rounding,
    0,
    0,
    1,
    oEnd[0],
    oEnd[1],
    // end butt
    "L",
    iEnd[0],
    iEnd[1],
    // inner end corner
    "A",
    rounding,
    rounding,
    0,
    0,
    1,
    iArcEnd[0],
    iArcEnd[1],
    // inner arc
    "A",
    innerR,
    innerR,
    0,
    arcSweep2,
    0,
    iArcStart[0],
    iArcStart[1],
    // inner start corner
    "A",
    rounding,
    rounding,
    0,
    0,
    1,
    iStart[0],
    iStart[1],
    "Z"
    // end path
  ].join(" ");
}

// node_modules/vuetify/lib/labs/VPie/utils.js
function formatTextTemplate(template, item) {
  return item ? template.replaceAll("[title]", item.title).replaceAll("[value]", String(item.value)) : void 0;
}
function usePieArc(props, isHovering) {
  const hoverZoomRatio = toRef(() => clamp(Number(props.hoverScale ?? 0), 0, 0.25));
  const normalizedValue = toRef(() => clamp(props.value - 100 * Number(props.gap ?? 0) / 360, 0.01, 99.99));
  const normalizedInnerCut = toRef(() => {
    const min = Number(props.rounded ?? 0) > 0 ? 0.2 : 0;
    return clamp(Number(props.innerCut ?? 0) / 100, min, 1);
  });
  const radians = computed(() => (360 * (-normalizedValue.value / 100) + 90) * (Math.PI / 180));
  const arcWidth = computed(() => 50 * (1 - normalizedInnerCut.value) * (isHovering.value ? 1 : 1 - hoverZoomRatio.value));
  const outerX = toRef(() => 50 + 50 * Math.cos(radians.value));
  const outerY = toRef(() => 50 - 50 * Math.sin(radians.value));
  return {
    hoverZoomRatio,
    normalizedValue,
    normalizedInnerCut,
    outerX,
    outerY,
    arcWidth
  };
}
function useOuterSlicePath(_ref) {
  let {
    angle,
    radius,
    size,
    width,
    rounded
  } = _ref;
  return computed(() => roundedArc(
    [50, 50],
    toValue(radius),
    toValue(angle),
    toValue(angle) + 360 * toValue(size) / 100,
    // angle end,
    toValue(width),
    toValue(rounded)
  ));
}
function useInnerSlicePath(_ref2) {
  let {
    angle,
    radius,
    size
  } = _ref2;
  return computed(() => simpleArc(
    [50, 50],
    toValue(radius),
    toValue(angle),
    toValue(angle) + 360 * toValue(size) / 100
    // angle end,
  ));
}

// node_modules/vuetify/lib/labs/VPie/VPieSegment.js
var makeVPieSegmentProps = propsFactory({
  active: Boolean,
  rotate: [Number, String],
  value: {
    type: Number,
    default: 0
  },
  color: String,
  innerCut: [Number, String],
  hoverScale: {
    type: [Number, String],
    default: 0.05
  },
  gap: [Number, String],
  rounded: [Number, String],
  animation: {
    type: [Boolean, Object],
    default: false
  },
  pattern: String,
  hideSlice: Boolean,
  ...makeRevealProps()
}, "VPieSegment");
var VPieSegment = genericComponent()({
  name: "VPieSegment",
  props: makeVPieSegmentProps(),
  emits: {
    "update:active": (val) => true
  },
  setup(props) {
    const isActive = useProxiedModel(props, "active");
    const {
      state: revealState,
      duration: revealDuration
    } = useReveal(props);
    const transitionConfig = computed(() => {
      const defaultEasing = "easeInOutCubic";
      const defaultDuration = 400;
      const easingName = typeof props.animation === "object" ? props.animation.easing ?? defaultEasing : defaultEasing;
      return {
        duration: ["initial", "pending"].includes(revealState.value) ? revealDuration.value : typeof props.animation === "object" ? props.animation.duration : props.animation ? defaultDuration : 0,
        transition: easingPatterns[easingName]
      };
    });
    const {
      hoverZoomRatio,
      normalizedValue,
      normalizedInnerCut,
      outerX,
      outerY,
      arcWidth
    } = usePieArc(props, isActive);
    const arcSize = toRef(() => revealState.value === "initial" ? 0 : normalizedValue.value);
    const currentArcSize = useTransition(arcSize, transitionConfig);
    const angle = toRef(() => revealState.value === "initial" ? 0 : Number(props.rotate ?? 0) + Number(props.gap ?? 0) / 2);
    const currentAngle = useTransition(angle, transitionConfig);
    const arcRadius = toRef(() => 50 * (isActive.value ? 1 : 1 - hoverZoomRatio.value));
    const currentArcRadius = useTransition(arcRadius, transitionConfig);
    const currentArcWidth = useTransition(arcWidth, transitionConfig);
    const outerSlicePath = useOuterSlicePath({
      angle: currentAngle,
      radius: currentArcRadius,
      size: currentArcSize,
      width: currentArcWidth,
      rounded: () => Number(props.rounded ?? 0)
    });
    const innerSlicePath = useInnerSlicePath({
      angle: currentAngle,
      radius: () => currentArcRadius.value - currentArcWidth.value,
      size: currentArcSize
    });
    const overlayPath = toRef(() => `M 50 0 A 50 50 0 ${normalizedValue.value > 50 ? 1 : 0} 1 ${outerX.value} ${outerY.value} L 50 50`);
    return () => createBaseVNode("g", {
      "class": "v-pie-segment",
      "style": {
        color: props.color
      }
    }, [createBaseVNode("path", {
      "key": "outer-slice",
      "fill": "currentColor",
      "shape-rendering": "geometricPrecision",
      "d": outerSlicePath.value
    }, null), props.pattern && createBaseVNode("path", {
      "key": "pattern-overlay",
      "shape-rendering": "geometricPrecision",
      "fill": props.pattern,
      "d": outerSlicePath.value
    }, null), !props.hideSlice && normalizedInnerCut.value > 0 && createBaseVNode("path", {
      "key": "inner-slice",
      "fill": "oklch(from currentColor l c h / calc(alpha / 2))",
      "d": innerSlicePath.value
    }, null), ["disabled", "done"].includes(revealState.value) && createBaseVNode("path", {
      "transform": `rotate(${currentAngle.value} 50 50)`,
      "class": "v-pie-segment__overlay",
      "d": overlayPath.value,
      "onMouseenter": () => isActive.value = true,
      "onMouseleave": () => isActive.value = false
    }, null)]);
  }
});

// node_modules/vuetify/lib/labs/VPie/VPieTooltip.js
var makeVPieTooltipProps = propsFactory({
  modelValue: Boolean,
  target: Object,
  item: {
    type: Object,
    default: null
  },
  titleFormat: {
    type: [String, Function],
    default: "[title]"
  },
  subtitleFormat: {
    type: [String, Function],
    default: "[value]"
  },
  ...makeTransitionProps(),
  ...pick(makeVTooltipProps(), ["offset"])
}, "VPieTooltip");
var VPieTooltip = genericComponent()({
  name: "VPieTooltip",
  props: makeVPieTooltipProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const tooltipTitleFormatFunction = toRef(() => (segment) => {
      return typeof props.titleFormat === "function" ? props.titleFormat(segment) : formatTextTemplate(props.titleFormat, segment);
    });
    const tooltipSubtitleFormatFunction = toRef(() => (segment) => {
      return typeof props.subtitleFormat === "function" ? props.subtitleFormat(segment) : formatTextTemplate(props.subtitleFormat, segment);
    });
    return () => createVNode(VTooltip, {
      "offset": props.offset,
      "modelValue": props.modelValue,
      "target": props.target,
      "contentClass": "v-pie__tooltip-content"
    }, {
      default: () => {
        var _a;
        return [!!props.item && (((_a = slots.default) == null ? void 0 : _a.call(slots, {
          item: props.item
        })) ?? createVNode(MaybeTransition, {
          "transition": props.transition,
          "mode": "out-in"
        }, {
          default: () => [createVNode(VListItem, {
            "key": props.item.key,
            "density": "compact",
            "title": tooltipTitleFormatFunction.value(props.item),
            "subtitle": tooltipSubtitleFormatFunction.value(props.item)
          }, {
            prepend: slots.prepend ? () => slots.prepend({
              item: props.item
            }) : void 0
          })]
        }))];
      }
    });
  }
});

// node_modules/vuetify/lib/labs/VPie/VPie.js
var makeVPieProps = propsFactory({
  title: String,
  bgColor: String,
  items: {
    type: Array,
    default: () => []
  },
  palette: {
    type: Array,
    default: () => []
  },
  itemKey: {
    type: String,
    default: "key"
  },
  itemValue: {
    type: String,
    default: "value"
  },
  itemTitle: {
    type: String,
    default: "title"
  },
  size: {
    type: [Number, String],
    default: 250
  },
  rotate: [Number, String],
  gaugeCut: [Number, String],
  legend: {
    type: [Boolean, Object],
    default: false
  },
  tooltip: {
    type: [Boolean, Object],
    default: false
  },
  ...makeDensityProps(),
  ...pick(makeVPieSegmentProps(), ["animation", "gap", "rounded", "innerCut", "hoverScale", "hideSlice", "reveal"])
}, "VPie");
var VPie = genericComponent()({
  name: "VPie",
  directives: {
    vClickOutside: click_outside_default
  },
  props: makeVPieProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const legendConfig = computed(() => ({
      visible: !!props.legend,
      position: "bottom",
      textFormat: "[title]",
      ...typeof props.legend === "object" ? props.legend : {}
    }));
    const {
      colorClasses,
      colorStyles
    } = useColor(() => ({
      background: props.bgColor
    }));
    const textColorStyles = toRef(() => pick(colorStyles.value, ["color", "caretColor"]));
    const legendAvatarSize = toRef(() => ({
      default: 20,
      comfortable: 18,
      compact: 16
    })[props.density ?? "default"]);
    const legendDirection = toRef(() => ["left", "right"].includes(legendConfig.value.position) ? "vertical" : "horizontal");
    const legendMode = toRef(() => !legendConfig.value.visible ? "hidden" : legendConfig.value.position);
    const legendTextFormatFunction = toRef(() => (item) => {
      return typeof legendConfig.value.textFormat === "function" ? legendConfig.value.textFormat(item) : formatTextTemplate(legendConfig.value.textFormat, item);
    });
    const arcs = computed(() => {
      return props.items.filter(Boolean).map((item, index) => {
        return {
          key: item[props.itemKey],
          color: item.color ?? colorFromPalette(index),
          value: item[props.itemValue],
          title: String(item[props.itemTitle]),
          pattern: item.pattern ?? patternFromPalette(index),
          raw: item
        };
      });
    });
    const visibleItemsKeys = shallowRef([]);
    watch(() => arcs.value.length, () => {
      visibleItemsKeys.value = arcs.value.map((a) => a.key);
    }, {
      immediate: true
    });
    const visibleItems = computed(() => {
      return arcs.value.map((item) => {
        return isVisible(item) ? item : {
          ...item,
          value: 0
        };
      });
    });
    const total = computed(() => visibleItems.value.reduce((sum, item) => sum + item.value, 0));
    const gaugeCut = toRef(() => Number(props.gaugeCut ?? 0));
    const gaugeOffset = computed(() => (1 - Math.cos(Math.PI * Math.min(90, gaugeCut.value / 2) / 180)) / 2);
    const rotateDeg = computed(() => `${gaugeCut.value ? 180 + gaugeCut.value / 2 : props.rotate ?? 0}deg`);
    function arcOffset(index) {
      return visibleItems.value.slice(0, index).reduce((acc, s) => acc + (total.value > 0 ? s.value / total.value : 0) * (360 - gaugeCut.value), 0);
    }
    function arcSize(v) {
      return v / total.value * (100 - gaugeCut.value / 3.6);
    }
    function colorFromPalette(index) {
      if (props.palette.length === 0) return void 0;
      const paletteItem = props.palette[index % props.palette.length];
      return typeof paletteItem === "object" ? paletteItem.color : paletteItem;
    }
    function patternFromPalette(index) {
      if (props.palette.length === 0) return void 0;
      const paletteItem = props.palette[index % props.palette.length];
      return typeof paletteItem === "object" ? paletteItem.pattern : void 0;
    }
    function isVisible(item) {
      return visibleItemsKeys.value.includes(item.key);
    }
    function toggle(item) {
      if (isVisible(item)) {
        visibleItemsKeys.value = visibleItemsKeys.value.filter((x) => x !== item.key);
      } else {
        visibleItemsKeys.value = [...visibleItemsKeys.value, item.key];
      }
    }
    const tooltipItem = shallowRef(null);
    const tooltipVisible = shallowRef(false);
    const tooltipTarget = shallowRef([0, 0]);
    let mouseLeaveTimeout = null;
    function setItemActive(item, active) {
      arcs.value.forEach((a) => a.isActive = a.key === item.key && active);
      if (props.tooltip) {
        setTooltip(item, active);
      }
    }
    function setTooltip(item, active) {
      clearTimeout(mouseLeaveTimeout);
      if (active) {
        tooltipVisible.value = true;
        tooltipItem.value = item;
      } else {
        mouseLeaveTimeout = setTimeout(() => {
          tooltipVisible.value = false;
          mouseLeaveTimeout = setTimeout(() => {
            tooltipItem.value = null;
          }, 500);
        }, 100);
      }
    }
    let frame = -1;
    function onSvgMousemove(_ref2) {
      let {
        clientX,
        clientY
      } = _ref2;
      cancelAnimationFrame(frame);
      frame = requestAnimationFrame(() => {
        tooltipTarget.value = [clientX, clientY];
      });
    }
    function onSvgTouchstart(_ref3) {
      let {
        touches
      } = _ref3;
      if (!touches) return;
      const {
        clientX,
        clientY
      } = touches[0];
      tooltipTarget.value = [clientX, clientY];
    }
    function onSvgClickOutside() {
      arcs.value.forEach((a) => a.isActive = false);
      tooltipVisible.value = false;
    }
    return () => {
      var _a, _b;
      const segmentProps = pick(props, ["animation", "gap", "rounded", "hideSlice", "reveal", "innerCut", "hoverScale"]);
      const defaultTooltipTransition = {
        name: "fade-transition",
        duration: 150
      };
      const tooltipProps = {
        item: tooltipItem.value,
        modelValue: tooltipVisible.value,
        titleFormat: typeof props.tooltip === "object" ? props.tooltip.titleFormat : "[title]",
        subtitleFormat: typeof props.tooltip === "object" ? props.tooltip.subtitleFormat : "[value]",
        transition: typeof props.tooltip === "object" ? props.tooltip.transition : defaultTooltipTransition,
        offset: typeof props.tooltip === "object" ? props.tooltip.offset : 16,
        target: tooltipTarget.value
      };
      const legendDefaults = {
        VChipGroup: {
          direction: legendDirection.value
        },
        VChip: {
          density: props.density
        },
        VAvatar: {
          size: legendAvatarSize.value
        }
      };
      const tooltipDefaults = {
        VAvatar: {
          size: typeof props.tooltip === "object" ? props.tooltip.avatarSize ?? 28 : 28
        }
      };
      const avatarSlot = (_ref4) => {
        let {
          item
        } = _ref4;
        return createVNode(VAvatar, {
          "color": item.color,
          "start": true
        }, {
          default: () => [item.pattern && createBaseVNode("svg", {
            "height": "40",
            "width": "40"
          }, [createBaseVNode("rect", {
            "width": "40",
            "height": "40",
            "fill": item.pattern
          }, null)])]
        });
      };
      return createBaseVNode("div", {
        "class": normalizeClass(["v-pie", `v-pie--legend-${legendMode.value}`]),
        "style": {
          "--v-pie-size": convertToUnit(props.size)
        }
      }, [((_a = slots.title) == null ? void 0 : _a.call(slots)) ?? (props.title && createBaseVNode("div", {
        "class": "v-pie__title"
      }, [props.title])), createBaseVNode("div", {
        "class": normalizeClass(["v-pie__content", colorClasses.value]),
        "style": normalizeStyle([{
          transform: `rotate(${rotateDeg.value})`,
          marginBottom: `calc(-1 * ${convertToUnit(props.size)} * ${gaugeOffset.value})`
        }, textColorStyles.value])
      }, [createBaseVNode("div", {
        "class": normalizeClass(["v-pie__content-underlay", colorClasses.value]),
        "style": normalizeStyle(colorStyles.value)
      }, null), withDirectives(createBaseVNode("svg", {
        "xmlns": "http://www.w3.org/2000/svg",
        "viewBox": "0 0 100 100",
        "class": "v-pie__segments",
        "onMousemove": onSvgMousemove,
        "onTouchstart": onSvgTouchstart
      }, [arcs.value.map((item, index) => createVNode(VPieSegment, mergeProps(segmentProps, {
        "key": item.key,
        "active": item.isActive,
        "color": item.color,
        "value": isVisible(item) ? arcSize(item.value) : 0,
        "rotate": arcOffset(index),
        "pattern": item.pattern,
        "onUpdate:active": (val) => setItemActive(item, val),
        "onTouchend": () => setItemActive(item, true)
      }), null))]), [[click_outside_default, {
        handler: onSvgClickOutside
      }]]), createBaseVNode("div", {
        "class": "v-pie__center-content",
        "style": {
          transform: `translate(-50%, -50%)
                  rotate(-${rotateDeg.value})
                  translateY(calc(-100% * ${gaugeOffset.value}))`
        }
      }, [createBaseVNode("div", null, [(_b = slots.center) == null ? void 0 : _b.call(slots, {
        total: total.value
      })])])]), legendConfig.value.visible && createVNode(VDefaultsProvider, {
        "key": "legend",
        "defaults": legendDefaults
      }, {
        default: () => {
          var _a2;
          return [createBaseVNode("div", {
            "class": "v-pie__legend"
          }, [((_a2 = slots.legend) == null ? void 0 : _a2.call(slots, {
            isActive: isVisible,
            toggle,
            items: arcs.value,
            total: total.value
          })) ?? createVNode(VChipGroup, {
            "column": true,
            "multiple": true,
            "modelValue": visibleItemsKeys.value,
            "onUpdate:modelValue": ($event) => visibleItemsKeys.value = $event
          }, {
            default: () => [arcs.value.map((item) => createVNode(VChip, {
              "value": item.key
            }, {
              prepend: () => avatarSlot({
                item
              }),
              default: () => {
                var _a3;
                return createBaseVNode("div", {
                  "class": "v-pie__legend__text"
                }, [((_a3 = slots["legend-text"]) == null ? void 0 : _a3.call(slots, {
                  item,
                  total: total.value
                })) ?? legendTextFormatFunction.value(item)]);
              }
            }))]
          })])];
        }
      }), !!props.tooltip && createVNode(VDefaultsProvider, {
        "defaults": tooltipDefaults
      }, {
        default: () => [createVNode(VPieTooltip, tooltipProps, {
          default: slots.tooltip ? (slotProps) => {
            var _a2;
            return (_a2 = slots.tooltip) == null ? void 0 : _a2.call(slots, {
              ...slotProps,
              total: total.value
            });
          } : void 0,
          prepend: avatarSlot
        })]
      })]);
    };
  }
});
export {
  VPie,
  VPieSegment,
  VPieTooltip
};
//# sourceMappingURL=vuetify_labs_VPie.js.map
