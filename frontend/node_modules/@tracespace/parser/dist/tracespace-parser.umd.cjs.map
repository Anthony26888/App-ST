{"version":3,"file":"tracespace-parser.umd.cjs","sources":["../../../node_modules/.pnpm/moo@0.5.2/node_modules/moo/moo.js","../src/lexer/tokens.ts","../src/lexer/rules.ts","../src/lexer/index.ts","../src/constants.ts","../src/syntax/rules.ts","../src/tree.ts","../src/syntax/map-tokens.ts","../src/syntax/drill.ts","../src/syntax/macro.ts","../src/syntax/gerber.ts","../src/syntax/index.ts","../src/index.ts"],"sourcesContent":["(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], factory) /* global define */\n  } else if (typeof module === 'object' && module.exports) {\n    module.exports = factory()\n  } else {\n    root.moo = factory()\n  }\n}(this, function() {\n  'use strict';\n\n  var hasOwnProperty = Object.prototype.hasOwnProperty\n  var toString = Object.prototype.toString\n  var hasSticky = typeof new RegExp().sticky === 'boolean'\n\n  /***************************************************************************/\n\n  function isRegExp(o) { return o && toString.call(o) === '[object RegExp]' }\n  function isObject(o) { return o && typeof o === 'object' && !isRegExp(o) && !Array.isArray(o) }\n\n  function reEscape(s) {\n    return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\n  }\n  function reGroups(s) {\n    var re = new RegExp('|' + s)\n    return re.exec('').length - 1\n  }\n  function reCapture(s) {\n    return '(' + s + ')'\n  }\n  function reUnion(regexps) {\n    if (!regexps.length) return '(?!)'\n    var source =  regexps.map(function(s) {\n      return \"(?:\" + s + \")\"\n    }).join('|')\n    return \"(?:\" + source + \")\"\n  }\n\n  function regexpOrLiteral(obj) {\n    if (typeof obj === 'string') {\n      return '(?:' + reEscape(obj) + ')'\n\n    } else if (isRegExp(obj)) {\n      // TODO: consider /u support\n      if (obj.ignoreCase) throw new Error('RegExp /i flag not allowed')\n      if (obj.global) throw new Error('RegExp /g flag is implied')\n      if (obj.sticky) throw new Error('RegExp /y flag is implied')\n      if (obj.multiline) throw new Error('RegExp /m flag is implied')\n      return obj.source\n\n    } else {\n      throw new Error('Not a pattern: ' + obj)\n    }\n  }\n\n  function pad(s, length) {\n    if (s.length > length) {\n      return s\n    }\n    return Array(length - s.length + 1).join(\" \") + s\n  }\n\n  function lastNLines(string, numLines) {\n    var position = string.length\n    var lineBreaks = 0;\n    while (true) {\n      var idx = string.lastIndexOf(\"\\n\", position - 1)\n      if (idx === -1) {\n        break;\n      } else {\n        lineBreaks++\n      }\n      position = idx\n      if (lineBreaks === numLines) {\n        break;\n      }\n      if (position === 0) {\n        break;\n      }\n    }\n    var startPosition = \n      lineBreaks < numLines ?\n      0 : \n      position + 1\n    return string.substring(startPosition).split(\"\\n\")\n  }\n\n  function objectToRules(object) {\n    var keys = Object.getOwnPropertyNames(object)\n    var result = []\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      var thing = object[key]\n      var rules = [].concat(thing)\n      if (key === 'include') {\n        for (var j = 0; j < rules.length; j++) {\n          result.push({include: rules[j]})\n        }\n        continue\n      }\n      var match = []\n      rules.forEach(function(rule) {\n        if (isObject(rule)) {\n          if (match.length) result.push(ruleOptions(key, match))\n          result.push(ruleOptions(key, rule))\n          match = []\n        } else {\n          match.push(rule)\n        }\n      })\n      if (match.length) result.push(ruleOptions(key, match))\n    }\n    return result\n  }\n\n  function arrayToRules(array) {\n    var result = []\n    for (var i = 0; i < array.length; i++) {\n      var obj = array[i]\n      if (obj.include) {\n        var include = [].concat(obj.include)\n        for (var j = 0; j < include.length; j++) {\n          result.push({include: include[j]})\n        }\n        continue\n      }\n      if (!obj.type) {\n        throw new Error('Rule has no type: ' + JSON.stringify(obj))\n      }\n      result.push(ruleOptions(obj.type, obj))\n    }\n    return result\n  }\n\n  function ruleOptions(type, obj) {\n    if (!isObject(obj)) {\n      obj = { match: obj }\n    }\n    if (obj.include) {\n      throw new Error('Matching rules cannot also include states')\n    }\n\n    // nb. error and fallback imply lineBreaks\n    var options = {\n      defaultType: type,\n      lineBreaks: !!obj.error || !!obj.fallback,\n      pop: false,\n      next: null,\n      push: null,\n      error: false,\n      fallback: false,\n      value: null,\n      type: null,\n      shouldThrow: false,\n    }\n\n    // Avoid Object.assign(), so we support IE9+\n    for (var key in obj) {\n      if (hasOwnProperty.call(obj, key)) {\n        options[key] = obj[key]\n      }\n    }\n\n    // type transform cannot be a string\n    if (typeof options.type === 'string' && type !== options.type) {\n      throw new Error(\"Type transform cannot be a string (type '\" + options.type + \"' for token '\" + type + \"')\")\n    }\n\n    // convert to array\n    var match = options.match\n    options.match = Array.isArray(match) ? match : match ? [match] : []\n    options.match.sort(function(a, b) {\n      return isRegExp(a) && isRegExp(b) ? 0\n           : isRegExp(b) ? -1 : isRegExp(a) ? +1 : b.length - a.length\n    })\n    return options\n  }\n\n  function toRules(spec) {\n    return Array.isArray(spec) ? arrayToRules(spec) : objectToRules(spec)\n  }\n\n  var defaultErrorRule = ruleOptions('error', {lineBreaks: true, shouldThrow: true})\n  function compileRules(rules, hasStates) {\n    var errorRule = null\n    var fast = Object.create(null)\n    var fastAllowed = true\n    var unicodeFlag = null\n    var groups = []\n    var parts = []\n\n    // If there is a fallback rule, then disable fast matching\n    for (var i = 0; i < rules.length; i++) {\n      if (rules[i].fallback) {\n        fastAllowed = false\n      }\n    }\n\n    for (var i = 0; i < rules.length; i++) {\n      var options = rules[i]\n\n      if (options.include) {\n        // all valid inclusions are removed by states() preprocessor\n        throw new Error('Inheritance is not allowed in stateless lexers')\n      }\n\n      if (options.error || options.fallback) {\n        // errorRule can only be set once\n        if (errorRule) {\n          if (!options.fallback === !errorRule.fallback) {\n            throw new Error(\"Multiple \" + (options.fallback ? \"fallback\" : \"error\") + \" rules not allowed (for token '\" + options.defaultType + \"')\")\n          } else {\n            throw new Error(\"fallback and error are mutually exclusive (for token '\" + options.defaultType + \"')\")\n          }\n        }\n        errorRule = options\n      }\n\n      var match = options.match.slice()\n      if (fastAllowed) {\n        while (match.length && typeof match[0] === 'string' && match[0].length === 1) {\n          var word = match.shift()\n          fast[word.charCodeAt(0)] = options\n        }\n      }\n\n      // Warn about inappropriate state-switching options\n      if (options.pop || options.push || options.next) {\n        if (!hasStates) {\n          throw new Error(\"State-switching options are not allowed in stateless lexers (for token '\" + options.defaultType + \"')\")\n        }\n        if (options.fallback) {\n          throw new Error(\"State-switching options are not allowed on fallback tokens (for token '\" + options.defaultType + \"')\")\n        }\n      }\n\n      // Only rules with a .match are included in the RegExp\n      if (match.length === 0) {\n        continue\n      }\n      fastAllowed = false\n\n      groups.push(options)\n\n      // Check unicode flag is used everywhere or nowhere\n      for (var j = 0; j < match.length; j++) {\n        var obj = match[j]\n        if (!isRegExp(obj)) {\n          continue\n        }\n\n        if (unicodeFlag === null) {\n          unicodeFlag = obj.unicode\n        } else if (unicodeFlag !== obj.unicode && options.fallback === false) {\n          throw new Error('If one rule is /u then all must be')\n        }\n      }\n\n      // convert to RegExp\n      var pat = reUnion(match.map(regexpOrLiteral))\n\n      // validate\n      var regexp = new RegExp(pat)\n      if (regexp.test(\"\")) {\n        throw new Error(\"RegExp matches empty string: \" + regexp)\n      }\n      var groupCount = reGroups(pat)\n      if (groupCount > 0) {\n        throw new Error(\"RegExp has capture groups: \" + regexp + \"\\nUse (?: â€¦ ) instead\")\n      }\n\n      // try and detect rules matching newlines\n      if (!options.lineBreaks && regexp.test('\\n')) {\n        throw new Error('Rule should declare lineBreaks: ' + regexp)\n      }\n\n      // store regex\n      parts.push(reCapture(pat))\n    }\n\n\n    // If there's no fallback rule, use the sticky flag so we only look for\n    // matches at the current index.\n    //\n    // If we don't support the sticky flag, then fake it using an irrefutable\n    // match (i.e. an empty pattern).\n    var fallbackRule = errorRule && errorRule.fallback\n    var flags = hasSticky && !fallbackRule ? 'ym' : 'gm'\n    var suffix = hasSticky || fallbackRule ? '' : '|'\n\n    if (unicodeFlag === true) flags += \"u\"\n    var combined = new RegExp(reUnion(parts) + suffix, flags)\n    return {regexp: combined, groups: groups, fast: fast, error: errorRule || defaultErrorRule}\n  }\n\n  function compile(rules) {\n    var result = compileRules(toRules(rules))\n    return new Lexer({start: result}, 'start')\n  }\n\n  function checkStateGroup(g, name, map) {\n    var state = g && (g.push || g.next)\n    if (state && !map[state]) {\n      throw new Error(\"Missing state '\" + state + \"' (in token '\" + g.defaultType + \"' of state '\" + name + \"')\")\n    }\n    if (g && g.pop && +g.pop !== 1) {\n      throw new Error(\"pop must be 1 (in token '\" + g.defaultType + \"' of state '\" + name + \"')\")\n    }\n  }\n  function compileStates(states, start) {\n    var all = states.$all ? toRules(states.$all) : []\n    delete states.$all\n\n    var keys = Object.getOwnPropertyNames(states)\n    if (!start) start = keys[0]\n\n    var ruleMap = Object.create(null)\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      ruleMap[key] = toRules(states[key]).concat(all)\n    }\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      var rules = ruleMap[key]\n      var included = Object.create(null)\n      for (var j = 0; j < rules.length; j++) {\n        var rule = rules[j]\n        if (!rule.include) continue\n        var splice = [j, 1]\n        if (rule.include !== key && !included[rule.include]) {\n          included[rule.include] = true\n          var newRules = ruleMap[rule.include]\n          if (!newRules) {\n            throw new Error(\"Cannot include nonexistent state '\" + rule.include + \"' (in state '\" + key + \"')\")\n          }\n          for (var k = 0; k < newRules.length; k++) {\n            var newRule = newRules[k]\n            if (rules.indexOf(newRule) !== -1) continue\n            splice.push(newRule)\n          }\n        }\n        rules.splice.apply(rules, splice)\n        j--\n      }\n    }\n\n    var map = Object.create(null)\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      map[key] = compileRules(ruleMap[key], true)\n    }\n\n    for (var i = 0; i < keys.length; i++) {\n      var name = keys[i]\n      var state = map[name]\n      var groups = state.groups\n      for (var j = 0; j < groups.length; j++) {\n        checkStateGroup(groups[j], name, map)\n      }\n      var fastKeys = Object.getOwnPropertyNames(state.fast)\n      for (var j = 0; j < fastKeys.length; j++) {\n        checkStateGroup(state.fast[fastKeys[j]], name, map)\n      }\n    }\n\n    return new Lexer(map, start)\n  }\n\n  function keywordTransform(map) {\n\n    // Use a JavaScript Map to map keywords to their corresponding token type\n    // unless Map is unsupported, then fall back to using an Object:\n    var isMap = typeof Map !== 'undefined'\n    var reverseMap = isMap ? new Map : Object.create(null)\n\n    var types = Object.getOwnPropertyNames(map)\n    for (var i = 0; i < types.length; i++) {\n      var tokenType = types[i]\n      var item = map[tokenType]\n      var keywordList = Array.isArray(item) ? item : [item]\n      keywordList.forEach(function(keyword) {\n        if (typeof keyword !== 'string') {\n          throw new Error(\"keyword must be string (in keyword '\" + tokenType + \"')\")\n        }\n        if (isMap) {\n          reverseMap.set(keyword, tokenType)\n        } else {\n          reverseMap[keyword] = tokenType\n        }\n      })\n    }\n    return function(k) {\n      return isMap ? reverseMap.get(k) : reverseMap[k]\n    }\n  }\n\n  /***************************************************************************/\n\n  var Lexer = function(states, state) {\n    this.startState = state\n    this.states = states\n    this.buffer = ''\n    this.stack = []\n    this.reset()\n  }\n\n  Lexer.prototype.reset = function(data, info) {\n    this.buffer = data || ''\n    this.index = 0\n    this.line = info ? info.line : 1\n    this.col = info ? info.col : 1\n    this.queuedToken = info ? info.queuedToken : null\n    this.queuedText = info ? info.queuedText: \"\";\n    this.queuedThrow = info ? info.queuedThrow : null\n    this.setState(info ? info.state : this.startState)\n    this.stack = info && info.stack ? info.stack.slice() : []\n    return this\n  }\n\n  Lexer.prototype.save = function() {\n    return {\n      line: this.line,\n      col: this.col,\n      state: this.state,\n      stack: this.stack.slice(),\n      queuedToken: this.queuedToken,\n      queuedText: this.queuedText,\n      queuedThrow: this.queuedThrow,\n    }\n  }\n\n  Lexer.prototype.setState = function(state) {\n    if (!state || this.state === state) return\n    this.state = state\n    var info = this.states[state]\n    this.groups = info.groups\n    this.error = info.error\n    this.re = info.regexp\n    this.fast = info.fast\n  }\n\n  Lexer.prototype.popState = function() {\n    this.setState(this.stack.pop())\n  }\n\n  Lexer.prototype.pushState = function(state) {\n    this.stack.push(this.state)\n    this.setState(state)\n  }\n\n  var eat = hasSticky ? function(re, buffer) { // assume re is /y\n    return re.exec(buffer)\n  } : function(re, buffer) { // assume re is /g\n    var match = re.exec(buffer)\n    // will always match, since we used the |(?:) trick\n    if (match[0].length === 0) {\n      return null\n    }\n    return match\n  }\n\n  Lexer.prototype._getGroup = function(match) {\n    var groupCount = this.groups.length\n    for (var i = 0; i < groupCount; i++) {\n      if (match[i + 1] !== undefined) {\n        return this.groups[i]\n      }\n    }\n    throw new Error('Cannot find token type for matched text')\n  }\n\n  function tokenToString() {\n    return this.value\n  }\n\n  Lexer.prototype.next = function() {\n    var index = this.index\n\n    // If a fallback token matched, we don't need to re-run the RegExp\n    if (this.queuedGroup) {\n      var token = this._token(this.queuedGroup, this.queuedText, index)\n      this.queuedGroup = null\n      this.queuedText = \"\"\n      return token\n    }\n\n    var buffer = this.buffer\n    if (index === buffer.length) {\n      return // EOF\n    }\n\n    // Fast matching for single characters\n    var group = this.fast[buffer.charCodeAt(index)]\n    if (group) {\n      return this._token(group, buffer.charAt(index), index)\n    }\n\n    // Execute RegExp\n    var re = this.re\n    re.lastIndex = index\n    var match = eat(re, buffer)\n\n    // Error tokens match the remaining buffer\n    var error = this.error\n    if (match == null) {\n      return this._token(error, buffer.slice(index, buffer.length), index)\n    }\n\n    var group = this._getGroup(match)\n    var text = match[0]\n\n    if (error.fallback && match.index !== index) {\n      this.queuedGroup = group\n      this.queuedText = text\n\n      // Fallback tokens contain the unmatched portion of the buffer\n      return this._token(error, buffer.slice(index, match.index), index)\n    }\n\n    return this._token(group, text, index)\n  }\n\n  Lexer.prototype._token = function(group, text, offset) {\n    // count line breaks\n    var lineBreaks = 0\n    if (group.lineBreaks) {\n      var matchNL = /\\n/g\n      var nl = 1\n      if (text === '\\n') {\n        lineBreaks = 1\n      } else {\n        while (matchNL.exec(text)) { lineBreaks++; nl = matchNL.lastIndex }\n      }\n    }\n\n    var token = {\n      type: (typeof group.type === 'function' && group.type(text)) || group.defaultType,\n      value: typeof group.value === 'function' ? group.value(text) : text,\n      text: text,\n      toString: tokenToString,\n      offset: offset,\n      lineBreaks: lineBreaks,\n      line: this.line,\n      col: this.col,\n    }\n    // nb. adding more props to token object will make V8 sad!\n\n    var size = text.length\n    this.index += size\n    this.line += lineBreaks\n    if (lineBreaks !== 0) {\n      this.col = size - nl + 1\n    } else {\n      this.col += size\n    }\n\n    // throw, if no rule with {error: true}\n    if (group.shouldThrow) {\n      var err = new Error(this.formatError(token, \"invalid syntax\"))\n      throw err;\n    }\n\n    if (group.pop) this.popState()\n    else if (group.push) this.pushState(group.push)\n    else if (group.next) this.setState(group.next)\n\n    return token\n  }\n\n  if (typeof Symbol !== 'undefined' && Symbol.iterator) {\n    var LexerIterator = function(lexer) {\n      this.lexer = lexer\n    }\n\n    LexerIterator.prototype.next = function() {\n      var token = this.lexer.next()\n      return {value: token, done: !token}\n    }\n\n    LexerIterator.prototype[Symbol.iterator] = function() {\n      return this\n    }\n\n    Lexer.prototype[Symbol.iterator] = function() {\n      return new LexerIterator(this)\n    }\n  }\n\n  Lexer.prototype.formatError = function(token, message) {\n    if (token == null) {\n      // An undefined token indicates EOF\n      var text = this.buffer.slice(this.index)\n      var token = {\n        text: text,\n        offset: this.index,\n        lineBreaks: text.indexOf('\\n') === -1 ? 0 : 1,\n        line: this.line,\n        col: this.col,\n      }\n    }\n    \n    var numLinesAround = 2\n    var firstDisplayedLine = Math.max(token.line - numLinesAround, 1)\n    var lastDisplayedLine = token.line + numLinesAround\n    var lastLineDigits = String(lastDisplayedLine).length\n    var displayedLines = lastNLines(\n        this.buffer, \n        (this.line - token.line) + numLinesAround + 1\n      )\n      .slice(0, 5)\n    var errorLines = []\n    errorLines.push(message + \" at line \" + token.line + \" col \" + token.col + \":\")\n    errorLines.push(\"\")\n    for (var i = 0; i < displayedLines.length; i++) {\n      var line = displayedLines[i]\n      var lineNo = firstDisplayedLine + i\n      errorLines.push(pad(String(lineNo), lastLineDigits) + \"  \" + line);\n      if (lineNo === token.line) {\n        errorLines.push(pad(\"\", lastLineDigits + token.col + 1) + \"^\")\n      }\n    }\n    return errorLines.join(\"\\n\")\n  }\n\n  Lexer.prototype.clone = function() {\n    return new Lexer(this.states, this.state)\n  }\n\n  Lexer.prototype.has = function(tokenType) {\n    return true\n  }\n\n\n  return {\n    compile: compile,\n    states: compileStates,\n    error: Object.freeze({error: true}),\n    fallback: Object.freeze({fallback: true}),\n    keywords: keywordTransform,\n  }\n\n}));\n","import type {Token as MooToken} from 'moo'\n\n/**\n * T-code token type\n *\n * @category Lexer\n */\nexport const T_CODE = 'T_CODE'\n\n/**\n * G-code token type\n *\n * @category Lexer\n */\nexport const G_CODE = 'G_CODE'\n\n/**\n * M-code token type\n *\n * @category Lexer\n */\nexport const M_CODE = 'M_CODE'\n\n/**\n * D-code token type\n *\n * @category Lexer\n */\nexport const D_CODE = 'D_CODE'\n\n/**\n * Asterisk token type\n *\n * @category Lexer\n */\nexport const ASTERISK = 'ASTERISK'\n\n/**\n * Percent sign token type\n *\n * @category Lexer\n */\nexport const PERCENT = 'PERCENT'\n\n/**\n * Equals sign token type\n *\n * @category Lexer\n */\nexport const EQUALS = 'EQUALS'\n\n/**\n * Comma token type\n *\n * @category Lexer\n */\nexport const COMMA = 'COMMA'\n\n/**\n * Arithmatic operator token type\n *\n * @category Lexer\n */\nexport const OPERATOR = 'OPERATOR'\n\n/**\n * Gerber format specification token type\n *\n * @category Lexer\n */\nexport const GERBER_FORMAT = 'GERBER_FORMAT'\n\n/**\n * Gerber units specification token type\n *\n * @category Lexer\n */\nexport const GERBER_UNITS = 'GERBER_UNITS'\n\n/**\n * Gerber tool macro token type\n *\n * @category Lexer\n */\nexport const GERBER_TOOL_MACRO = 'GERBER_TOOL_MACRO'\n\n/**\n * Gerber tool definition token type\n *\n * @category Lexer\n */\nexport const GERBER_TOOL_DEF = 'GERBER_TOOL_DEF'\n\n/**\n * Gerber load polarity token type\n *\n * @category Lexer\n */\nexport const GERBER_LOAD_POLARITY = 'GERBER_LOAD_POLARITY'\n\n/**\n * Gerber step repear token type\n *\n * @category Lexer\n */\nexport const GERBER_STEP_REPEAT = 'GERBER_STEP_REPEAT'\n\n/**\n * Gerber macro variable token type\n *\n * @category Lexer\n */\nexport const GERBER_MACRO_VARIABLE = 'GERBER_MACRO_VARIABLE'\n\n/**\n * Semicolor token type\n *\n * @category Lexer\n */\nexport const SEMICOLON = 'SEMICOLON'\n\n/**\n * Drill file units token type\n *\n * @category Lexer\n */\nexport const DRILL_UNITS = 'DRILL_UNITS'\n\n/**\n * Drill zero-inclusion token type\n *\n * @category Lexer\n */\nexport const DRILL_ZERO_INCLUSION = 'DRILL_ZERO_INCLUSION'\n\n/**\n * Coordinate axis character token type\n *\n * @category Lexer\n */\nexport const COORD_CHAR = 'COORD_CHAR'\n\n/**\n * Number token type\n *\n * @category Lexer\n */\nexport const NUMBER = 'NUMBER'\n\n/**\n * Word token type\n *\n * @category Lexer\n */\nexport const WORD = 'WORD'\n\n/**\n * Whitespace token type\n *\n * @category Lexer\n */\nexport const WHITESPACE = 'WHITESPACE'\n\n/**\n * Newline token type\n *\n * @category Lexer\n */\nexport const NEWLINE = 'NEWLINE'\n\n/**\n * Catchall token type\n *\n * @category Lexer\n */\nexport const CATCHALL = 'CATCHALL'\n\n/**\n * Error token type\n *\n * @category Lexer\n */\nexport const ERROR = 'ERROR'\n\n/**\n * Union of all available token types\n *\n * @category Lexer\n */\nexport type TokenType =\n  | typeof T_CODE\n  | typeof G_CODE\n  | typeof M_CODE\n  | typeof D_CODE\n  | typeof ASTERISK\n  | typeof PERCENT\n  | typeof EQUALS\n  | typeof COMMA\n  | typeof OPERATOR\n  | typeof GERBER_FORMAT\n  | typeof GERBER_UNITS\n  | typeof GERBER_TOOL_MACRO\n  | typeof GERBER_TOOL_DEF\n  | typeof GERBER_LOAD_POLARITY\n  | typeof GERBER_STEP_REPEAT\n  | typeof GERBER_MACRO_VARIABLE\n  | typeof SEMICOLON\n  | typeof DRILL_UNITS\n  | typeof DRILL_ZERO_INCLUSION\n  | typeof COORD_CHAR\n  | typeof NUMBER\n  | typeof WORD\n  | typeof WHITESPACE\n  | typeof NEWLINE\n  | typeof CATCHALL\n  | typeof ERROR\n\n/**\n * {@linkcode Lexer} token\n *\n * @category Lexer\n */\nexport interface Token extends MooToken {\n  /** Token identifier */\n  type: TokenType\n}\n","import Moo from 'moo'\nimport * as Tokens from './tokens'\n\nexport type Rules = {\n  [t in Tokens.TokenType]: RegExp | string | string[] | Moo.Rule | Moo.Rule[]\n}\n\nconst RE_STRIP_LEADING_ZEROS = /^0*/\n\nconst stripLeadingZeros = (text: string): string => {\n  return text.replace(RE_STRIP_LEADING_ZEROS, '')\n}\n\nconst getCodeValue = (text: string): string => {\n  return stripLeadingZeros(text.slice(1)) || '0'\n}\n\nexport const rules: Rules = {\n  [Tokens.T_CODE]: {\n    match: /T\\d+/,\n    value: getCodeValue,\n  },\n  [Tokens.G_CODE]: {\n    match: /G\\d+/,\n    value: getCodeValue,\n  },\n  [Tokens.M_CODE]: {\n    match: /M\\d+/,\n    value: getCodeValue,\n  },\n  [Tokens.D_CODE]: {\n    match: /D\\d+/,\n    value: getCodeValue,\n  },\n  [Tokens.ASTERISK]: '*',\n  [Tokens.PERCENT]: '%',\n  [Tokens.EQUALS]: '=',\n  [Tokens.GERBER_FORMAT]: {\n    match: /FS[LTDAI]+/,\n    value: (text: string): string => text.slice(2),\n  },\n  [Tokens.GERBER_UNITS]: {\n    match: /MO(?:IN|MM)/,\n    value: (text: string): string => text.slice(2),\n  },\n  [Tokens.GERBER_TOOL_MACRO]: {\n    // \"-\" in a tool name is illegal, but some gerber writers misbehave\n    // https://github.com/mcous/gerber-parser/pull/13\n    match: /AM[a-zA-Z_.$][\\w.-]*/,\n    value: (text: string): string => text.slice(2),\n  },\n  [Tokens.GERBER_TOOL_DEF]: {\n    match: /ADD\\d+[a-zA-Z_.$][\\w.-]*/,\n    value: (text: string): string => stripLeadingZeros(text.slice(3)),\n  },\n  [Tokens.GERBER_LOAD_POLARITY]: {\n    match: /LP[DC]/,\n    value: (text: string): string => text.slice(2),\n  },\n  [Tokens.GERBER_STEP_REPEAT]: 'SR',\n  [Tokens.GERBER_MACRO_VARIABLE]: /\\$\\d+/,\n  [Tokens.SEMICOLON]: ';',\n  [Tokens.DRILL_UNITS]: /^(?:METRIC|INCH)/,\n  [Tokens.DRILL_ZERO_INCLUSION]: {\n    match: /,(?:TZ|LZ)/,\n    value: (text: string): string => text.slice(1),\n  },\n  [Tokens.COORD_CHAR]: /[XYIJACFSBHZN]/,\n  [Tokens.NUMBER]: /[+-]?[\\d.]+/,\n  [Tokens.OPERATOR]: ['x', '/', '+', '-', '(', ')'],\n  [Tokens.COMMA]: ',',\n  [Tokens.WORD]: /[a-zA-Z]+/,\n  [Tokens.WHITESPACE]: /[ \\t]+/,\n  [Tokens.NEWLINE]: {\n    match: /\\r?\\n/,\n    lineBreaks: true,\n  },\n  [Tokens.CATCHALL]: /\\S/,\n  [Tokens.ERROR]: Moo.error,\n}\n","// Gerber and drill file lexer + tokenizer\nimport Moo from 'moo'\nimport type {Token} from './tokens'\nimport {rules} from './rules'\n\nexport * from './tokens'\n\nexport interface LexerState extends Moo.LexerState {\n  offset: number\n}\n\nexport interface LexerIterable extends Iterable<[Token, LexerState]> {}\n\n/**\n * The lexing module of the parser.\n *\n * @category Lexer\n */\nexport interface Lexer {\n  feed(chunk: string, state?: LexerState | null): LexerIterable\n}\n\n/**\n * {@linkcode Lexer} factory\n *\n * @example\n * ```ts\n * import {createLexer} from '@tracespace/parser'\n *\n * const lexer = createLexer()\n * const tokens = lexer.feed('G04 gerber string*\\nM02*\\n')\n *\n * for (const token of tokens) {\n *   console.log(`${token.type}: ${token.value}`)\n * }\n * ```\n *\n * @category Lexer\n */\nexport function createLexer(): Lexer {\n  const mooLexer = Moo.compile(rules)\n\n  return {feed}\n\n  function feed(chunk: string, state: LexerState | null = null): LexerIterable {\n    mooLexer.reset(chunk, state ?? undefined)\n    return tokenIterator(state?.offset ?? 0)\n  }\n\n  function tokenIterator(\n    offset: number\n  ): LexerIterable & Iterator<[Token, LexerState]> {\n    return {\n      [Symbol.iterator]() {\n        return this\n      },\n\n      next() {\n        const token = mooLexer.next() as Token | undefined\n\n        if (token) {\n          const nextToken = {...token, offset: offset + token.offset}\n          const nextState = {\n            ...mooLexer.save(),\n            offset: offset + (mooLexer.index ?? 0),\n          }\n\n          return {value: [nextToken, nextState]}\n        }\n\n        return {value: undefined, done: true}\n      },\n    }\n  }\n}\n\ndeclare module 'moo' {\n  export interface Lexer {\n    index?: number\n  }\n}\n","// Common constants\n\n// filetype constants\nexport const GERBER = 'gerber'\nexport const DRILL = 'drill'\n\n// Units constants\nexport const MM = 'mm'\nexport const IN = 'in'\n\n// Format constants\nexport const LEADING = 'leading'\nexport const TRAILING = 'trailing'\nexport const ABSOLUTE = 'absolute'\nexport const INCREMENTAL = 'incremental'\n\n// Tool constants\nexport const CIRCLE = 'circle'\nexport const RECTANGLE = 'rectangle'\nexport const OBROUND = 'obround'\nexport const POLYGON = 'polygon'\nexport const MACRO_SHAPE = 'macroShape'\n\n// Macro primitive codes\nexport const MACRO_CIRCLE = '1'\nexport const MACRO_VECTOR_LINE_DEPRECATED = '2'\nexport const MACRO_VECTOR_LINE = '20'\nexport const MACRO_CENTER_LINE = '21'\nexport const MACRO_LOWER_LEFT_LINE_DEPRECATED = '22'\nexport const MACRO_OUTLINE = '4'\nexport const MACRO_POLYGON = '5'\nexport const MACRO_MOIRE_DEPRECATED = '6'\nexport const MACRO_THERMAL = '7'\n\n// Drawing constants\nexport const SHAPE = 'shape'\nexport const MOVE = 'move'\nexport const SEGMENT = 'segment'\nexport const SLOT = 'slot'\n\n// Interpolation / routing constants\nexport const LINE = 'line'\nexport const CW_ARC = 'cwArc'\nexport const CCW_ARC = 'ccwArc'\n\n// Quadrant mode\nexport const SINGLE = 'single'\nexport const MULTI = 'multi'\n\n// Load polarity\nexport const DARK = 'dark'\nexport const CLEAR = 'clear'\n","import type {Token} from '../lexer'\nimport type {Filetype} from '../types'\nimport type {GerberNode} from '../tree'\n\nexport const SINGLE_TOKEN = 'TOKEN'\nexport const MIN_TO_MAX = 'MIN_TO_MAX'\n\nexport interface SyntaxRule<Node = GerberNode> {\n  name: string\n  rules: TokenRule[]\n  createNodes: (tokens: Token[]) => Node[]\n  filetype?: Filetype\n}\n\nexport type TokenRule = SingleTokenRule | MinToMaxRule\n\nexport interface SingleTokenRule {\n  rule: typeof SINGLE_TOKEN\n  type: Token['type']\n  value: Token['value'] | RegExp | null | undefined\n  negate?: boolean\n}\n\nexport interface MinToMaxRule {\n  rule: typeof MIN_TO_MAX\n  min: number\n  max: number\n  match: SingleTokenRule[]\n}\n\nexport function token(\n  type: Token['type'],\n  value?: Token['value'] | RegExp\n): SingleTokenRule {\n  return {rule: SINGLE_TOKEN, type, value}\n}\n\nexport function notToken(\n  type: Token['type'],\n  value?: Token['value']\n): SingleTokenRule {\n  return {rule: SINGLE_TOKEN, type, value, negate: true}\n}\n\nexport function one(match: SingleTokenRule[]): MinToMaxRule {\n  return {rule: MIN_TO_MAX, min: 1, max: 1, match}\n}\n\nexport function zeroOrOne(match: SingleTokenRule[]): MinToMaxRule {\n  return {rule: MIN_TO_MAX, min: 0, max: 1, match}\n}\n\nexport function zeroOrMore(match: SingleTokenRule[]): MinToMaxRule {\n  return {rule: MIN_TO_MAX, min: 0, max: Number.POSITIVE_INFINITY, match}\n}\n\nexport function oneOrMore(match: SingleTokenRule[]): MinToMaxRule {\n  return {rule: MIN_TO_MAX, min: 1, max: Number.POSITIVE_INFINITY, match}\n}\n\nexport function minToMax(\n  min: number,\n  max: number,\n  match: SingleTokenRule[]\n): MinToMaxRule {\n  return {rule: MIN_TO_MAX, min, max, match}\n}\n\nexport interface MatchSearchResult<Node> {\n  filetype?: Filetype\n  nodes?: Node[]\n  tokens?: Token[]\n  candidates?: Array<SyntaxRule<Node>>\n}\n\nexport function findSyntaxMatch<Node>(\n  tokens: Token[],\n  candidates: Array<SyntaxRule<Node>>\n): MatchSearchResult<Node> {\n  const remainingCandidates: Array<SyntaxRule<Node>> = []\n\n  for (const candidate of candidates) {\n    const matchType = tokenListMatches(tokens, candidate.rules)\n\n    if (matchType === PARTIAL_MATCH) {\n      remainingCandidates.push(candidate)\n    } else if (matchType === FULL_MATCH) {\n      return {\n        filetype: candidate.filetype,\n        nodes: candidate.createNodes(tokens),\n      }\n    }\n  }\n\n  return remainingCandidates.length > 0\n    ? {candidates: remainingCandidates, tokens}\n    : {}\n}\n\nconst FULL_MATCH = 'FULL_MATCH'\nconst PARTIAL_MATCH = 'PARTIAL_MATCH'\nconst NO_MATCH = 'NO_MATCH'\n\ntype TokenMatchType = typeof FULL_MATCH | typeof PARTIAL_MATCH | typeof NO_MATCH\n\nfunction tokenListMatches(tokens: Token[], rules: TokenRule[]): TokenMatchType {\n  let i = 0\n  let j = 0\n  let multiMatchCount = 0\n\n  while (i < rules.length && j < tokens.length) {\n    const rule = rules[i]\n    const token = tokens[j]\n    const match = tokenMatches(rule, token)\n\n    if (match) {\n      if (\n        rule.rule === SINGLE_TOKEN ||\n        (rule.rule === MIN_TO_MAX && multiMatchCount >= rule.max - 1)\n      ) {\n        i++\n        j++\n        multiMatchCount = 0\n      } else if (rule.rule === MIN_TO_MAX) {\n        j++\n        multiMatchCount++\n      }\n    } else if (rule.rule === MIN_TO_MAX && multiMatchCount >= rule.min) {\n      multiMatchCount = 0\n      i++\n    } else {\n      return NO_MATCH\n    }\n  }\n\n  if (i < rules.length) return PARTIAL_MATCH\n  return FULL_MATCH\n}\n\nfunction tokenMatches(rule: TokenRule, token: Token): boolean {\n  if (rule.rule === SINGLE_TOKEN) {\n    const typeResult = rule.type === token.type\n    const valueResult =\n      rule.value === null ||\n      typeof rule.value === 'undefined' ||\n      (typeof rule.value === 'string' && rule.value === token.value) ||\n      (rule.value instanceof RegExp && rule.value.test(token.value))\n\n    const result = typeResult && valueResult\n\n    return rule.negate ? !result : result\n  }\n\n  if (Array.isArray(rule.match)) {\n    return rule.match.some(match => tokenMatches(match, token))\n  }\n\n  return false\n}\n","import type {Position} from 'unist'\n\nimport type * as Types from './types'\n\n/**\n * {@linkcode Root} node type\n *\n * @category Node\n */\nexport const ROOT = 'root'\n\n/**\n * {@linkcode Comment} node type\n *\n * @category Node\n */\nexport const COMMENT = 'comment'\n\n/**\n * {@linkcode DrillHeader} node type\n *\n * @category Node\n */\nexport const DRILL_HEADER = 'drillHeader'\n\n/**\n * {@linkcode Done} node type\n *\n * @category Node\n */\nexport const DONE = 'done'\n\n/**\n * {@linkcode Units} node type\n *\n * @category Node\n */\nexport const UNITS = 'units'\n\n/**\n * {@linkcode CoordinateFormat} node type\n *\n * @category Node\n */\nexport const COORDINATE_FORMAT = 'coordinateFormat'\n\n/**\n * {@linkcode ToolDefinition} node type\n *\n * @category Node\n */\nexport const TOOL_DEFINITION = 'toolDefinition'\n\n/**\n * {@linkcode ToolMacro} node type\n *\n * @category Node\n */\nexport const TOOL_MACRO = 'toolMacro'\n\n/**\n * {@linkcode ToolChange} node type\n *\n * @category Node\n */\nexport const TOOL_CHANGE = 'toolChange'\n\n/**\n * {@linkcode LoadPolarity} node type\n *\n * @category Node\n */\nexport const LOAD_POLARITY = 'loadPolarity'\n\n/**\n * {@linkcode StepRepeat} node type\n *\n * @category Node\n */\nexport const STEP_REPEAT = 'stepRepeat'\n\n/**\n * {@linkcode Graphic} node type\n *\n * @category Node\n */\nexport const GRAPHIC = 'graphic'\n\n/**\n * {@linkcode InterpolateMode} node type\n *\n * @category Node\n */\nexport const INTERPOLATE_MODE = 'interpolateMode'\n\n/**\n * {@linkcode RegionMode} node type\n *\n * @category Node\n */\nexport const REGION_MODE = 'regionMode'\n\n/**\n * {@linkcode QuadrantMode} node type\n *\n * @category Node\n */\nexport const QUADRANT_MODE = 'quadrantMode'\n\n/**\n * {@linkcode Unimplemented} node type\n *\n * @category Node\n */\nexport const UNIMPLEMENTED = 'unimplemented'\n\n/**\n * {@linkcode MacroComment} node type\n *\n * @category Macro\n */\nexport const MACRO_COMMENT = 'macroComment'\n\n/**\n * {@linkcode MacroVariable} node type\n *\n * @category Macro\n */\nexport const MACRO_VARIABLE = 'macroVariable'\n\n/**\n * {@linkcode MacroPrimitive} node type\n *\n * @category Macro\n */\nexport const MACRO_PRIMITIVE = 'macroPrimitive'\n\ninterface BaseNode {\n  type: string\n  /** Location in the source file the node was parsed from */\n  position?: Position\n}\n\ninterface BaseParent extends BaseNode {\n  children: BaseNode[]\n}\n\n/**\n * Syntax tree node\n *\n * @category Node\n */\nexport type Node = Root | ChildNode\n\n/**\n * Child of the tree's {@linkcode Root} node\n *\n * @category Node\n */\nexport type ChildNode =\n  | Comment\n  | DrillHeader\n  | Done\n  | Units\n  | CoordinateFormat\n  | ToolDefinition\n  | ToolMacro\n  | ToolChange\n  | InterpolateMode\n  | RegionMode\n  | QuadrantMode\n  | LoadPolarity\n  | StepRepeat\n  | Graphic\n  | Unimplemented\n\n/**\n * Child of a {@linkcode ToolMacro} node\n *\n * @category Macro\n */\nexport type MacroBlock = MacroComment | MacroVariable | MacroPrimitive\n\n/**\n * Root node of the syntax tree, identifying the filetype and whether or not\n * the entire file seems to have been read. Filetype, if known, will be\n * either {@linkcode GERBER | gerber} or {@linkcode DRILL | drill}.\n *\n * If `filetype` is `null` or `done` is `false`, this may be a sign that\n *\n * 1. the parser has not finished parsing the file or\n * 2. the file is invalid and/or not a Gerber or drill file.\n *\n * @category Node\n */\nexport interface Root extends BaseParent {\n  /** Node type */\n  type: typeof ROOT\n  /** The parsed file's type (Gerber or NC drill), if known */\n  filetype: Types.Filetype\n\n  /** Parse results */\n  children: ChildNode[]\n}\n\n/**\n * Node representing a comment in the file. Usually, comment nodes can be\n * ignored, but in NC drill files, they may contain important format\n * specifications that are not able to be expressed in the file itself.\n *\n *  @category Node\n */\nexport interface Comment extends BaseNode {\n  /** Node type */\n  type: typeof COMMENT\n  /** Contents of the comment as a string */\n  comment: string\n}\n\n/**\n * Node representing drill file's header start or end.\n *\n *  @category Node\n */\nexport interface DrillHeader extends BaseNode {\n  /** Node type */\n  type: typeof DRILL_HEADER\n}\n\n/**\n * Node representing a done command. This represents an `M02` or `M00` command\n * in a Gerber file or an `M00` or `M30` in an NC drill file. Its presence in a\n * tree means the full source file was parsed.\n *\n * @category Node\n */\nexport interface Done extends BaseNode {\n  /** Node type */\n  type: typeof DONE\n}\n\n/**\n * A `Units` node specifies the units used for the file. Units may be\n * {@linkcode IN | in} or {@linkcode MM | mm}.\n *\n * @category Node\n */\nexport interface Units extends BaseNode {\n  /** Node type */\n  type: typeof UNITS\n  /** Inches or millimeters */\n  units: Types.UnitsType\n}\n\n/**\n * A `CoordinateFormat` node specifies the format of coordinate value strings.\n *\n * In Gerber and drill files, coordinates are (almost always) specified as\n * strings of digits without decimal points. `format` is a tuple where the\n * first element is the number of integer places in the string and the second\n * is the number of decimal places. Leading or trailing zeros may also be\n * omitted from the coordinate strings.\n *\n * For example, with `format` set to `[2, 4]`, some (intermediate) coordinate\n * strings could be:\n *\n * - `0.012` > `000120`\n * - `3.45` > `034500`\n * - `67` > `670000`\n *\n * With those same numbers, either {@linkcode LEADING | leading} or\n * {@linkcode TRAILING | trailing} zeros may be omitted depending on the\n * `zeroSuppression` setting:\n *\n * - `0.012` > `000120` > leading omitted: `120`, trailing omitted: `00012`\n * - `3.45` > `024500` > leading omitted: `24500`, trailing omitted: `0245`\n * - `67` > `670000` > leading omitted: `670000`, trailing omitted: `67`\n *\n * Some important things to keep in mind when processing coordinate strings\n * according to the `CoordinateFormat` node:\n *\n * - `format`, `zeroSuppression`, and/or `mode` could be left unspecified\n *     - In this case, `format` and `zeroSuppression` should be assumed or\n *       inferred, if possible\n *     - It's very safe to assume `mode` is always {@linkcode ABSOLUTE | absolute};\n *       {@linkcode INCREMENTAL | incremental} mode is deprecated and very rare\n * - Just because `zeroSuppression` is set doesn't mean zeros are dropped\n *     - It's common to see Gerber writers keep all zeros to ensure there is no\n *       ambiguity, but `zeroSuppression` still needs to be set to _something_\n * - A Gerber or NC drill file may choose to include decimal points! This is\n *   not necessarily \"in spec\", but it is unambiguous and easy to parse\n *\n * @category Node\n */\nexport interface CoordinateFormat extends BaseNode {\n  /** Node type */\n  type: typeof COORDINATE_FORMAT\n  /** Integer/decimal format setting, if known */\n  format: Types.Format | null\n  /** Zero suppression setting, if known */\n  zeroSuppression: Types.ZeroSuppression | null\n  /** Absolute or incremental coordinate system, if known */\n  mode: Types.Mode | null\n}\n\n/**\n * A `ToolDefinition` node defines a \"tool\" that may be used to either create a\n * shape (\"pad\" or \"drill hit\") or a stroke (\"trace\" or \"route\") in a later\n * graphic command.\n *\n * A tool shape may be one of:\n *\n * - {@linkcode Types.Circle} - A circle defined by a diameter\n * - {@linkcode Types.Rectangle} - A rectangle defined by sizes in the x and y axis\n * - {@linkcode Types.Obround} - A \"pill\" rectangle, with a border-radius equal to half of its shorter side\n * - {@linkcode Types.Polygon} - A regular polygon defined by its diameter, number of vertices, and rotation\n * - {@linkcode Types.MacroShape} - A shape defined by a previous {@linkcode ToolMacro}\n *\n * A tool may have a hole in its center; the `hole`, if not `null`, may be a:\n *\n * - {@linkcode Types.Circle}\n * - {@linkcode Types.Rectangle} (deprecated by the Gerber specification)\n *\n * Only `Circle` or `Rectangle` tools without a `hole` may create strokes.\n * `MacroShape` tools may not have a `hole` defined.\n *\n * @category Node\n */\nexport interface ToolDefinition extends BaseNode {\n  /** Node type */\n  type: typeof TOOL_DEFINITION\n  /** Unique tool identifier */\n  code: string\n  /** Tool shape */\n  shape: Types.ToolShape\n  /** Hole shape, if applicable */\n  hole: Types.HoleShape | null\n}\n\n/**\n * A `ToolMacro` node describes a complex shape in a Gerber file that can use a\n * variety of \"primitives\", simple arithmetic, and differing polarities to lay\n * out an image that will later be repeated.\n *\n * See the {@link https://www.ucamco.com/gerber | Gerber file specification}\n * for an in-depth description of how macros function.\n *\n * @category Node\n */\nexport interface ToolMacro extends BaseNode {\n  /** Node type */\n  type: typeof TOOL_MACRO\n  /** Unique macro identifier */\n  name: string\n  /** Macro definition blocks */\n  children: MacroBlock[]\n}\n\n/**\n * A `MacroComment` represents a comment in a macro and can be safely ignored\n *\n * @category Macro\n */\nexport interface MacroComment extends BaseNode {\n  /** Node type */\n  type: typeof MACRO_COMMENT\n  /** Comment string */\n  comment: string\n}\n\n/**\n * A `MacroVariable` node assigns a value to the `name` variable in a macro,\n * where that value may be a number or an arithmetic expression.\n *\n * @category Macro\n */\nexport interface MacroVariable extends BaseNode {\n  /** Node type */\n  type: typeof MACRO_VARIABLE\n  /** Variable name */\n  name: string\n  /** Concrete value or expression to assign to variable */\n  value: Types.MacroValue\n}\n\n/**\n * A `MacroPrimitive` node describes a shape to add to the overall macro shape.\n *\n * @category Macro\n */\nexport interface MacroPrimitive extends BaseNode {\n  /** Node type */\n  type: typeof MACRO_PRIMITIVE\n  /** Primitive shape type */\n  code: Types.MacroPrimitiveCode\n  /** Shape parameter values or expressions */\n  parameters: Types.MacroValue[]\n}\n\n/**\n * A `ToolChange` node sets the current active \"tool\". At a given point in the\n * file, the active tool determines the image that graphical operations produce.\n *\n * @category Node\n */\nexport interface ToolChange extends BaseNode {\n  /** Node type */\n  type: typeof TOOL_CHANGE\n  /** Tool identifier */\n  code: string\n}\n\n/**\n * A `LoadPolarity` node sets the current polarity to {@linkcode DARK | dark}\n * or {@linkcode CLEAR | clear}. Subsequent {@linkcode Graphic} operations\n * add to the overall image if the polarity is \"dark\", or remove from the image\n * if the polarity is \"clear\".\n *\n * @category Node\n */\nexport interface LoadPolarity extends BaseNode {\n  /** Node type */\n  type: typeof LOAD_POLARITY\n  /** Polarity */\n  polarity: Types.Polarity\n}\n\n/**\n * A `StepRepeat` node starts or ends a step repeat block.\n *\n * See the {@link https://www.ucamco.com/gerber | Gerber file specification}\n * for an in-depth description of step repeat blocks.\n *\n * @category Node\n */\nexport interface StepRepeat extends BaseNode {\n  /** Node type */\n  type: typeof STEP_REPEAT\n  /** Step repeat parameters */\n  stepRepeat: Types.StepRepeatParameters\n}\n\n/**\n * A `Graphic` node that represents an image being draw to the active layer.\n * The type of image \"drawn\" is dependent on the value of `graphic`:\n *\n * - {@linkcode SHAPE | shape} - the shape of the current tool is added to the\n *   image at `coordinates`\n * - {@linkcode MOVE | move} - the plotter is \"moved\" to `coordinates` **without\n *   drawing anything to the image**\n * - {@linkcode SEGMENT | segment} - the tool is \"stroked\" from the plotter's\n *   current location to `coordinates`\n *     - The path the tool takes is determined by the current {@linkcode InterpolateMode}\n *     - The segment may be a standalone path, or it may be a part of a region\n *       fill set by a {@linkcode RegionMode}\n *     - Only {@linkcode Circle} or {@linkcode Rectangle} tools may create\n *       standalone paths\n * - {@linkcode SLOT | slot} - a drill-file-specific graphic that creates a\n *   slot from `(coordinates.x1, coordinates.y1)` to `(coordinates.x2, coordinates.y2)`\n * - `null` - The graphic type was not explicitly specified in the source file\n *     - This is deprecated syntax in Gerber files, but if present the last\n *       used graphic type should be repeated\n *     - In a drill file, this means `shape` if in `drill` mode (default),\n *       `move` if in `move` mode, or `segment` if in a routing mode\n *\n * @category Node\n */\nexport interface Graphic extends BaseNode {\n  /** Node type */\n  type: typeof GRAPHIC\n  /** Graphical operation */\n  graphic: Types.GraphicType\n  /** Coordinates where the graphic will be applied */\n  coordinates: Types.Coordinates\n}\n\n/**\n * An `InterpolateMode` node is a command to define how subsequent `segment`\n * (or `null`, if you're processing a drill file) graphic nodes are rendered.\n * The `mode` may be one of:\n *\n * - {@linkcode LINE | line} - Draw a straight line segment\n * - {@linkcode CW_ARC | cwArc} - Draw a clockwise arc segment\n * - {@linkcode CCW_ARC | ccwArc} - Draw a counterclockwise arc segment\n * - {@linkcode MOVE | move } - (Drill file only) Move the current coordinate without drawing\n * - {@linkcode DRILL | drill} - (Drill file only) Draw a shape with the current tool\n *\n * @category Node\n */\nexport interface InterpolateMode extends BaseNode {\n  type: typeof INTERPOLATE_MODE\n  mode: Types.InterpolateModeType\n}\n\n/**\n * A `RegionMode` node is a command to treat subsequent graphics as part of a\n * region definition. Regions are typically used to describe things like\n * copper fills, and only occur in Gerber files. In region mode:\n *\n * - `segment` graphics define the edges of the region\n * - `move` graphics end the current region and start a new one\n * - Other graphics are disallowed\n *\n * @category Node\n */\nexport interface RegionMode extends BaseNode {\n  type: typeof REGION_MODE\n  region: boolean\n}\n\n/**\n * A `QuadrantMode` node determines how subsequent arc segments are drawn.\n *\n * See the {@link https://www.ucamco.com/gerber | Gerber file specification}\n * for an in-depth description of arc plotting.\n *\n * @category Node\n */\nexport interface QuadrantMode extends BaseNode {\n  type: typeof QUADRANT_MODE\n  quadrant: Types.QuadrantModeType\n}\n\n/**\n * An `Unimplemented` node is a chunk that the parser recognizes as part of a\n * Gerber file, but that it doesn't know how to process. These Nodes may be\n * implemented in a future minor release of the parser and should be used with\n * caution.\n *\n * Most unimplemented nodes will either be deprecated commands or valid\n * commands in the {@link https://www.ucamco.com/gerber | Gerber specification}\n * that we don't yet support.\n *\n * @category Node\n */\nexport interface Unimplemented extends BaseNode {\n  /** Node type */\n  type: typeof UNIMPLEMENTED\n  /** String value of chunk */\n  value: string\n}\n\nexport type GerberTree = Root\n\nexport type GerberNode = ChildNode\n","import type {Position} from 'unist'\nimport type {Token} from '../lexer'\nimport {NUMBER, COORD_CHAR, G_CODE, D_CODE} from '../lexer'\nimport type {Coordinates, InterpolateModeType, GraphicType} from '../types'\nimport {SEGMENT, MOVE, SHAPE, LINE, CW_ARC, CCW_ARC, DRILL} from '../constants'\n\nexport function tokensToCoordinates(tokens: Token[]): Coordinates {\n  return Object.fromEntries(\n    tokens\n      .map((token, i) => [token, tokens[i - 1]])\n      .filter(([token, previousToken]) => {\n        return token.type === NUMBER && previousToken?.type === COORD_CHAR\n      })\n      .map(([token, previousToken]) => {\n        return [previousToken.value.toLowerCase(), token.value]\n      })\n  )\n}\n\nexport function tokensToMode(tokens: Token[]): InterpolateModeType {\n  const maybeMode = tokens\n    .filter(t => t.type === G_CODE)\n    .map(t => {\n      if (t.value === '0') return MOVE\n      if (t.value === '1') return LINE\n      if (t.value === '2') return CW_ARC\n      if (t.value === '3') return CCW_ARC\n      if (t.value === '5') return DRILL\n      return null\n    })\n\n  return maybeMode[0] ?? null\n}\n\nexport function tokensToGraphic(tokens: Token[]): GraphicType {\n  const maybeGraphic = tokens\n    .filter(t => t.type === D_CODE)\n    .map(t => {\n      if (t.value === '1') return SEGMENT\n      if (t.value === '2') return MOVE\n      if (t.value === '3') return SHAPE\n      return null\n    })\n\n  return maybeGraphic[0] ?? null\n}\n\nexport function tokensToString(tokens: Token[]): string {\n  return tokens\n    .map(t => t.value)\n    .join('')\n    .trim()\n}\n\nexport function tokensToPosition(\n  tokens: Token[],\n  options: Partial<{head: Token; length: number}> = {}\n): Position {\n  const {head = tokens[0], length = 0} = options\n  const tail =\n    length > 0\n      ? tokens[tokens.indexOf(head) + length - 1]\n      : tokens[tokens.length - 1]\n\n  return {\n    start: {line: head.line, column: head.col, offset: head.offset},\n    end: {line: tail.line, column: tail.col, offset: tail.offset},\n  }\n}\n","// Drill file grammar\nimport * as Lexer from '../lexer'\nimport * as Tree from '../tree'\nimport * as Constants from '../constants'\nimport type * as Types from '../types'\nimport type {SyntaxRule} from './rules'\nimport {token, notToken, one, zeroOrOne, zeroOrMore, minToMax} from './rules'\n\nimport {\n  tokensToCoordinates,\n  tokensToMode,\n  tokensToString,\n  tokensToPosition,\n} from './map-tokens'\n\nconst units: SyntaxRule = {\n  name: 'units',\n  rules: [\n    one([\n      token(Lexer.DRILL_UNITS),\n      token(Lexer.M_CODE, '71'),\n      token(Lexer.M_CODE, '72'),\n    ]),\n    zeroOrMore([\n      token(Lexer.COMMA),\n      token(Lexer.DRILL_ZERO_INCLUSION),\n      token(Lexer.NUMBER, /^0{1,8}\\.0{1,8}$/),\n    ]),\n    token(Lexer.NEWLINE),\n  ],\n  createNodes(tokens) {\n    const units =\n      tokens[0].value === 'INCH' || tokens[0].value === '72'\n        ? Constants.IN\n        : Constants.MM\n\n    const zeroSuppression = tokens\n      .filter(t => t.type === Lexer.DRILL_ZERO_INCLUSION)\n      .map(t => {\n        if (t.value === 'LZ') return Constants.TRAILING\n        if (t.value === 'TZ') return Constants.LEADING\n        return null\n      })\n\n    const format = tokens\n      .filter(t => t.type === Lexer.NUMBER)\n      .map<Types.Format>(t => {\n        const [integer = '', decimal = ''] = t.value.split('.')\n        return [integer.length, decimal.length]\n      })\n\n    const nodes: Tree.ChildNode[] = [\n      {type: Tree.UNITS, position: tokensToPosition(tokens.slice(0, 2)), units},\n    ]\n\n    if (zeroSuppression.length > 0 || format.length > 0) {\n      nodes.push({\n        type: Tree.COORDINATE_FORMAT,\n        position: tokensToPosition(tokens.slice(1)),\n        mode: null,\n        format: format[0] ?? null,\n        zeroSuppression: zeroSuppression[0] ?? null,\n      })\n    }\n\n    return nodes\n  },\n}\n\nconst tool: SyntaxRule = {\n  name: 'tool',\n  rules: [\n    token(Lexer.T_CODE),\n    minToMax(0, 12, [\n      token(Lexer.COORD_CHAR, 'C'),\n      token(Lexer.COORD_CHAR, 'F'),\n      token(Lexer.COORD_CHAR, 'S'),\n      token(Lexer.COORD_CHAR, 'B'),\n      token(Lexer.COORD_CHAR, 'H'),\n      token(Lexer.COORD_CHAR, 'Z'),\n      token(Lexer.NUMBER),\n    ]),\n    token(Lexer.NEWLINE),\n  ],\n  createNodes(tokens) {\n    const code = tokens[0].value\n    const position = tokensToPosition(tokens)\n    const {c = null} = tokensToCoordinates(tokens.slice(1, -1))\n    const shape: Types.ToolShape | null =\n      c === null ? null : {type: Constants.CIRCLE, diameter: Number(c)}\n\n    return shape\n      ? [{type: Tree.TOOL_DEFINITION, hole: null, position, shape, code}]\n      : [{type: Tree.TOOL_CHANGE, position, code}]\n  },\n}\n\nconst mode: SyntaxRule = {\n  name: 'operationMode',\n  rules: [\n    one([\n      token(Lexer.G_CODE, '0'),\n      token(Lexer.G_CODE, '1'),\n      token(Lexer.G_CODE, '2'),\n      token(Lexer.G_CODE, '3'),\n      token(Lexer.G_CODE, '5'),\n    ]),\n    token(Lexer.NEWLINE),\n  ],\n  createNodes: tokens => [\n    {\n      type: Tree.INTERPOLATE_MODE,\n      position: tokensToPosition(tokens),\n      mode: tokensToMode(tokens),\n    },\n  ],\n}\n\nconst operation: SyntaxRule = {\n  name: 'operation',\n  rules: [\n    minToMax(0, 2, [\n      token(Lexer.T_CODE),\n      token(Lexer.G_CODE, '0'),\n      token(Lexer.G_CODE, '1'),\n      token(Lexer.G_CODE, '2'),\n      token(Lexer.G_CODE, '3'),\n      token(Lexer.G_CODE, '5'),\n    ]),\n    minToMax(2, 8, [token(Lexer.COORD_CHAR), token(Lexer.NUMBER)]),\n    zeroOrOne([token(Lexer.T_CODE)]),\n    token(Lexer.NEWLINE),\n  ],\n  createNodes(tokens) {\n    const graphicTokens = tokens.filter(\n      t => t.type === Lexer.COORD_CHAR || t.type === Lexer.NUMBER\n    )\n    const modeToken = tokens.find(t => t.type === Lexer.G_CODE)\n    const toolToken = tokens.find(t => t.type === Lexer.T_CODE)\n    const coordinates = tokensToCoordinates(graphicTokens)\n    const code = toolToken ? toolToken.value : null\n    const mode = tokensToMode(tokens)\n\n    const graphicPosition = tokensToPosition(tokens, {\n      head: graphicTokens[0],\n      length: graphicTokens.length + 1,\n    })\n    const modePosition = tokensToPosition(tokens, {head: modeToken, length: 2})\n    const toolPosition = tokensToPosition(tokens, {head: toolToken, length: 2})\n\n    const nodes: Tree.ChildNode[] = [\n      {\n        type: Tree.GRAPHIC,\n        position: graphicPosition,\n        graphic: null,\n        coordinates,\n      },\n    ]\n\n    if (mode) {\n      nodes.unshift({type: Tree.INTERPOLATE_MODE, position: modePosition, mode})\n    }\n\n    if (code) {\n      nodes.unshift({type: Tree.TOOL_CHANGE, position: toolPosition, code})\n    }\n\n    return nodes\n  },\n}\n\nconst slot: SyntaxRule = {\n  name: 'slot',\n  rules: [\n    minToMax(2, 4, [token(Lexer.COORD_CHAR), token(Lexer.NUMBER)]),\n    token(Lexer.G_CODE, '85'),\n    minToMax(2, 4, [token(Lexer.COORD_CHAR), token(Lexer.NUMBER)]),\n    token(Lexer.NEWLINE),\n  ],\n  createNodes(tokens) {\n    const gCode = tokens.find(t => t.type === Lexer.G_CODE)\n    const splitIdx = gCode ? tokens.indexOf(gCode) : -1\n    const start = Object.fromEntries(\n      Object.entries(tokensToCoordinates(tokens.slice(0, splitIdx))).map(\n        ([axis, value]) => [`${axis}0`, value]\n      )\n    )\n    const end = tokensToCoordinates(tokens.slice(splitIdx))\n\n    return [\n      {\n        type: Tree.GRAPHIC,\n        position: tokensToPosition(tokens),\n        graphic: Constants.SLOT,\n        coordinates: {...start, ...end},\n      },\n    ]\n  },\n}\n\nconst done: SyntaxRule = {\n  name: 'done',\n  rules: [\n    one([token(Lexer.M_CODE, '30'), token(Lexer.M_CODE, '0')]),\n    token(Lexer.NEWLINE),\n  ],\n  createNodes: tokens => [\n    {type: Tree.DONE, position: tokensToPosition(tokens)},\n  ],\n}\n\nconst header: SyntaxRule = {\n  name: 'header',\n  rules: [\n    one([token(Lexer.M_CODE, '48'), token(Lexer.PERCENT)]),\n    token(Lexer.NEWLINE),\n  ],\n  createNodes: tokens => [\n    {type: Tree.DRILL_HEADER, position: tokensToPosition(tokens)},\n  ],\n}\n\nconst comment: SyntaxRule = {\n  name: 'comment',\n  rules: [\n    token(Lexer.SEMICOLON),\n    zeroOrMore([notToken(Lexer.NEWLINE)]),\n    token(Lexer.NEWLINE),\n  ],\n  createNodes: tokens => [\n    {\n      type: Tree.COMMENT,\n      comment: tokensToString(tokens.slice(1, -1)),\n      position: tokensToPosition(tokens),\n    },\n  ],\n}\n\nexport const drillGrammar: SyntaxRule[] = [\n  tool,\n  mode,\n  operation,\n  slot,\n  comment,\n  units,\n  done,\n  header,\n].map(r => ({...r, filetype: Constants.DRILL}))\n","// Gerber aperture macro syntax\nimport * as Lexer from '../lexer'\nimport * as Tree from '../tree'\nimport type {MacroValue, MacroPrimitiveCode} from '../types'\n\nimport {tokensToPosition} from './map-tokens'\nimport type {SyntaxRule} from './rules'\nimport {token, notToken, zeroOrMore, oneOrMore, findSyntaxMatch} from './rules'\n\nconst macroComment: SyntaxRule<Tree.MacroBlock> = {\n  name: 'macroComment',\n  rules: [\n    token(Lexer.NUMBER, '0'),\n    zeroOrMore([notToken(Lexer.ASTERISK)]),\n    token(Lexer.ASTERISK),\n  ],\n  createNodes: createMacroComment,\n}\n\nconst macroVariable: SyntaxRule<Tree.MacroBlock> = {\n  name: 'macroVariable',\n  rules: [\n    token(Lexer.GERBER_MACRO_VARIABLE),\n    token(Lexer.EQUALS),\n    oneOrMore([\n      token(Lexer.NUMBER),\n      token(Lexer.OPERATOR),\n      token(Lexer.GERBER_MACRO_VARIABLE),\n      token(Lexer.COORD_CHAR, 'X'),\n    ]),\n    token(Lexer.ASTERISK),\n  ],\n  createNodes: createMacroVariable,\n}\n\nconst macroPrimitive: SyntaxRule<Tree.MacroBlock> = {\n  name: 'macroPrimitive',\n  rules: [\n    token(Lexer.NUMBER),\n    token(Lexer.COMMA),\n    oneOrMore([\n      token(Lexer.COMMA),\n      token(Lexer.NUMBER),\n      token(Lexer.OPERATOR),\n      token(Lexer.GERBER_MACRO_VARIABLE),\n      token(Lexer.COORD_CHAR, 'X'),\n    ]),\n    token(Lexer.ASTERISK),\n  ],\n  createNodes: createMacroPrimitive,\n}\n\nfunction createMacroComment(tokens: Lexer.Token[]): Tree.MacroComment[] {\n  const comment = tokens\n    .slice(1, -1)\n    .map(t => t.text)\n    .join('')\n    .trim()\n\n  return [\n    {type: Tree.MACRO_COMMENT, position: tokensToPosition(tokens), comment},\n  ]\n}\n\nfunction createMacroPrimitive(tokens: Lexer.Token[]): Tree.MacroPrimitive[] {\n  const code = tokens[0].value as MacroPrimitiveCode\n  const commaDelimitedTokens: Lexer.Token[][] = [[]]\n  let currentGroup = commaDelimitedTokens[0]\n\n  for (const token of tokens.slice(2, -1)) {\n    if (token.type === Lexer.COMMA) {\n      currentGroup = []\n      commaDelimitedTokens.push(currentGroup)\n    } else {\n      currentGroup.push(token)\n    }\n  }\n\n  const parameters = commaDelimitedTokens.map(tokens =>\n    parseMacroExpression(tokens)\n  )\n\n  return [\n    {\n      type: Tree.MACRO_PRIMITIVE,\n      position: tokensToPosition(tokens),\n      code,\n      parameters,\n    },\n  ]\n}\n\nfunction createMacroVariable(tokens: Lexer.Token[]): Tree.MacroVariable[] {\n  const name = tokens[0].value\n  const value = parseMacroExpression(tokens.slice(2, -1))\n\n  return [\n    {\n      type: Tree.MACRO_VARIABLE,\n      position: tokensToPosition(tokens),\n      name,\n      value,\n    },\n  ]\n}\n\nfunction parseMacroExpression(tokens: Lexer.Token[]): MacroValue {\n  const toParse = tokens.map<Lexer.Token>(token => {\n    return token.type === Lexer.COORD_CHAR\n      ? {...token, type: Lexer.OPERATOR, value: 'x'}\n      : token\n  })\n\n  return parseAddition()\n\n  function peekNextToken(): Lexer.Token | null {\n    return toParse[0] ?? null\n  }\n\n  // Parse numbers, variables, and parenthesis\n  function parsePrimary(): MacroValue {\n    const token = toParse.shift()!\n\n    if (token.type === Lexer.NUMBER) return Number(token.value)\n    if (token.type === Lexer.GERBER_MACRO_VARIABLE) return token.value\n\n    // Else, we've got a parentheses group, so parse it and consume the \")\"\n    const expression = parseAddition()\n    toParse.shift()\n    return expression\n  }\n\n  // Parse multiplication and division operations\n  function parseMultiplication(): MacroValue {\n    let expression = parsePrimary()\n    let nextToken = peekNextToken()\n\n    while (\n      nextToken?.type === Lexer.OPERATOR &&\n      (nextToken.value === 'x' || nextToken.value === '/')\n    ) {\n      toParse.shift()\n      expression = {\n        left: expression,\n        right: parsePrimary(),\n        operator: nextToken.value,\n      }\n      nextToken = peekNextToken()\n    }\n\n    return expression\n  }\n\n  function parseAddition(): MacroValue {\n    let expression = parseMultiplication()\n    let nextToken = peekNextToken()\n\n    while (\n      (nextToken?.type === Lexer.OPERATOR &&\n        (nextToken.value === '+' || nextToken.value === '-')) ||\n      nextToken?.type === Lexer.NUMBER\n    ) {\n      let operator: '+' | '-' = '+'\n      if (nextToken.type === Lexer.OPERATOR) {\n        toParse.shift()\n        operator = nextToken.value as '+' | '-'\n      }\n\n      const right = parseMultiplication()\n      expression = {left: expression, right, operator}\n      nextToken = peekNextToken()\n    }\n\n    return expression\n  }\n}\n\nconst MACRO_GRAMMAR = [macroPrimitive, macroVariable, macroComment]\n\nexport function parseMacroBlocks(tokens: Lexer.Token[]): Tree.MacroBlock[] {\n  let matchedCandidates = MACRO_GRAMMAR\n  let matchedTokens: Lexer.Token[] = []\n  const blocks: Tree.MacroBlock[] = []\n\n  for (const token of tokens) {\n    const result = findSyntaxMatch([...matchedTokens, token], matchedCandidates)\n\n    if (result.nodes) blocks.push(...result.nodes)\n    matchedTokens = result.tokens ?? []\n    matchedCandidates = result.candidates ?? MACRO_GRAMMAR\n  }\n\n  return blocks\n}\n","// Gerber file syntax\nimport * as Lexer from '../lexer'\nimport * as Constants from '../constants'\nimport type * as Types from '../types'\nimport * as Tree from '../tree'\nimport {parseMacroBlocks} from './macro'\nimport type {SyntaxRule} from './rules'\nimport {token, notToken, one, zeroOrMore, zeroOrOne, minToMax} from './rules'\n\nimport {\n  tokensToCoordinates,\n  tokensToMode,\n  tokensToGraphic,\n  tokensToString,\n  tokensToPosition,\n} from './map-tokens'\n\nconst holeShape = (parameters: number[]): Types.HoleShape | null => {\n  if (parameters.length === 1) {\n    const [diameter] = parameters\n    return {type: Constants.CIRCLE, diameter}\n  }\n\n  if (parameters.length === 2) {\n    const [xSize, ySize] = parameters\n    return {type: Constants.RECTANGLE, xSize, ySize}\n  }\n\n  return null\n}\n\nconst done: SyntaxRule = {\n  name: 'done',\n  rules: [\n    one([token(Lexer.M_CODE, '0'), token(Lexer.M_CODE, '2')]),\n    token(Lexer.ASTERISK),\n  ],\n  createNodes: tokens => [\n    {type: Tree.DONE, position: tokensToPosition(tokens)},\n  ],\n}\n\nconst comment: SyntaxRule = {\n  name: 'comment',\n  rules: [\n    token(Lexer.G_CODE, '4'),\n    zeroOrMore([notToken(Lexer.ASTERISK)]),\n    token(Lexer.ASTERISK),\n  ],\n  createNodes: tokens => [\n    {\n      type: Tree.COMMENT,\n      position: tokensToPosition(tokens),\n      comment: tokensToString(tokens.slice(1, -1)),\n    },\n  ],\n}\n\nconst format: SyntaxRule = {\n  name: 'format',\n  rules: [\n    token(Lexer.PERCENT),\n    token(Lexer.GERBER_FORMAT),\n    zeroOrMore([notToken(Lexer.COORD_CHAR, 'X')]),\n    token(Lexer.COORD_CHAR, 'X'),\n    token(Lexer.NUMBER),\n    token(Lexer.COORD_CHAR, 'Y'),\n    token(Lexer.NUMBER),\n    zeroOrMore([notToken(Lexer.ASTERISK)]),\n    token(Lexer.ASTERISK),\n    // Including units here is invalid syntax, but Cadence Allegro does it\n    // https://github.com/tracespace/tracespace/issues/234\n    minToMax(0, 2, [token(Lexer.GERBER_UNITS), token(Lexer.ASTERISK)]),\n    token(Lexer.PERCENT),\n  ],\n  createNodes(tokens) {\n    let format: Types.Format | null = null\n    let zeroSuppression: Types.ZeroSuppression | null = null\n    let mode: Types.Mode | null = null\n    const coords = tokensToCoordinates(tokens)\n    const formatEndIdx = tokens.findIndex(t => t.type === Lexer.ASTERISK)\n    const unitsToken = tokens.find(t => t.type === Lexer.GERBER_UNITS)\n\n    for (const t of tokens.filter(t => t.type === Lexer.GERBER_FORMAT)) {\n      if (t.value.includes('T')) zeroSuppression = Constants.TRAILING\n      if (t.value.includes('L')) zeroSuppression = Constants.LEADING\n      if (t.value.includes('I')) mode = Constants.INCREMENTAL\n      if (t.value.includes('A')) mode = Constants.ABSOLUTE\n    }\n\n    if (coords.x === coords.y && coords.x?.length === 2) {\n      const integers = Number(coords.x[0])\n      const decimals = Number(coords.x[1])\n      if (integers && decimals) format = [integers, decimals]\n    }\n\n    const nodes: Tree.ChildNode[] = [\n      {\n        type: Tree.COORDINATE_FORMAT,\n        position: tokensToPosition(tokens.slice(1, formatEndIdx + 1)),\n        zeroSuppression,\n        format,\n        mode,\n      },\n    ]\n\n    if (unitsToken) {\n      nodes.push({\n        type: Tree.UNITS,\n        position: tokensToPosition(tokens.slice(1, -1), {head: unitsToken}),\n        units: unitsToken.value === 'MM' ? Constants.MM : Constants.IN,\n      })\n    }\n\n    return nodes\n  },\n}\n\nconst units: SyntaxRule = {\n  name: 'units',\n  rules: [\n    token(Lexer.PERCENT),\n    token(Lexer.GERBER_UNITS),\n    token(Lexer.ASTERISK),\n    token(Lexer.PERCENT),\n  ],\n  createNodes: tokens => [\n    {\n      type: Tree.UNITS,\n      position: tokensToPosition(tokens.slice(1, -1)),\n      units: tokens[1].value === 'MM' ? Constants.MM : Constants.IN,\n    },\n  ],\n}\n\nconst toolMacro: SyntaxRule = {\n  name: 'toolMacro',\n  rules: [\n    token(Lexer.PERCENT),\n    token(Lexer.GERBER_TOOL_MACRO),\n    token(Lexer.ASTERISK),\n    zeroOrMore([notToken(Lexer.PERCENT)]),\n    token(Lexer.PERCENT),\n  ],\n  createNodes(tokens) {\n    const name = tokens[1].value\n    const position = tokensToPosition(tokens.slice(1, -1))\n    const blockTokens = tokens.slice(3, -1)\n\n    return [\n      {\n        type: Tree.TOOL_MACRO,\n        position,\n        children: parseMacroBlocks(blockTokens),\n        name,\n      },\n    ]\n  },\n}\n\nconst toolDefinition: SyntaxRule = {\n  name: 'toolDefinition',\n  rules: [\n    token(Lexer.PERCENT),\n    token(Lexer.GERBER_TOOL_DEF),\n    zeroOrMore([\n      token(Lexer.COMMA),\n      token(Lexer.NUMBER),\n      token(Lexer.COORD_CHAR, 'X'),\n    ]),\n    token(Lexer.ASTERISK),\n    token(Lexer.PERCENT),\n  ],\n  createNodes(tokens) {\n    let shape: Types.ToolShape\n    let hole: Types.HoleShape | null = null\n\n    const toolProps = /(\\d+)(.+)/.exec(tokens[1].value)\n    const [, code = '', name = ''] = toolProps ?? []\n    const parameters: number[] = tokens\n      .slice(3, -2)\n      .filter(t => t.type === Lexer.NUMBER)\n      .map(t => Number(t.value))\n\n    switch (name) {\n      case 'C': {\n        const [diameter, ...holeParameters] = parameters\n        shape = {type: Constants.CIRCLE, diameter}\n        hole = holeShape(holeParameters)\n        break\n      }\n\n      case 'R':\n      case 'O': {\n        const [xSize, ySize, ...holeParameters] = parameters\n        const type = name === 'R' ? Constants.RECTANGLE : Constants.OBROUND\n        shape = {type, xSize, ySize}\n        hole = holeShape(holeParameters)\n        break\n      }\n\n      case 'P': {\n        const [diameter, vertices, rotation = null, ...holeParameters] =\n          parameters\n        shape = {type: Constants.POLYGON, diameter, vertices, rotation}\n        hole = holeShape(holeParameters)\n        break\n      }\n\n      default: {\n        shape = {type: Constants.MACRO_SHAPE, name, variableValues: parameters}\n      }\n    }\n\n    return [\n      {\n        type: Tree.TOOL_DEFINITION,\n        position: tokensToPosition(tokens.slice(1, -1)),\n        code,\n        shape,\n        hole,\n      },\n    ]\n  },\n}\n\nconst toolChange: SyntaxRule = {\n  name: 'toolChange',\n  rules: [\n    zeroOrOne([token(Lexer.G_CODE, '54')]),\n    token(Lexer.D_CODE),\n    token(Lexer.ASTERISK),\n  ],\n  createNodes: tokens => [\n    {\n      type: Tree.TOOL_CHANGE,\n      position: tokensToPosition(tokens),\n      code: tokens.find(t => t.type === Lexer.D_CODE)!.value,\n    },\n  ],\n}\n\nconst createOperationNodes = (tokens: Lexer.Token[]): Tree.ChildNode[] => {\n  const graphic = tokensToGraphic(tokens)\n  const coordinates = tokensToCoordinates(tokens)\n  const mode = tokensToMode(tokens)\n  const position = tokensToPosition(tokens, {\n    head: mode ? tokens[1] : tokens[0],\n  })\n  const nodes: Tree.ChildNode[] = [\n    {type: Tree.GRAPHIC, position, graphic, coordinates},\n  ]\n  if (mode) {\n    const modePosition = tokensToPosition(tokens, {head: tokens[0], length: 2})\n    nodes.unshift({type: Tree.INTERPOLATE_MODE, position: modePosition, mode})\n  }\n\n  return nodes\n}\n\nconst operation: SyntaxRule = {\n  name: 'operation',\n  rules: [\n    zeroOrOne([\n      token(Lexer.G_CODE, '1'),\n      token(Lexer.G_CODE, '2'),\n      token(Lexer.G_CODE, '3'),\n    ]),\n    minToMax(2, 8, [token(Lexer.COORD_CHAR), token(Lexer.NUMBER)]),\n    zeroOrOne([\n      token(Lexer.D_CODE, '1'),\n      token(Lexer.D_CODE, '2'),\n      token(Lexer.D_CODE, '3'),\n    ]),\n    token(Lexer.ASTERISK),\n  ],\n  createNodes: createOperationNodes,\n}\n\nconst operationWithoutCoords: SyntaxRule = {\n  name: 'operationWithoutCoords',\n  rules: [\n    zeroOrOne([\n      token(Lexer.G_CODE, '1'),\n      token(Lexer.G_CODE, '2'),\n      token(Lexer.G_CODE, '3'),\n    ]),\n    one([\n      token(Lexer.D_CODE, '1'),\n      token(Lexer.D_CODE, '2'),\n      token(Lexer.D_CODE, '3'),\n    ]),\n    token(Lexer.ASTERISK),\n  ],\n  createNodes: createOperationNodes,\n}\n\nconst interpolationMode: SyntaxRule = {\n  name: 'interpolationMode',\n  rules: [\n    one([\n      token(Lexer.G_CODE, '1'),\n      token(Lexer.G_CODE, '2'),\n      token(Lexer.G_CODE, '3'),\n    ]),\n    token(Lexer.ASTERISK),\n  ],\n  createNodes: tokens => [\n    {\n      type: Tree.INTERPOLATE_MODE,\n      position: tokensToPosition(tokens),\n      mode: tokensToMode(tokens),\n    },\n  ],\n}\n\nconst regionMode: SyntaxRule = {\n  name: 'regionMode',\n  rules: [\n    one([token(Lexer.G_CODE, '36'), token(Lexer.G_CODE, '37')]),\n    token(Lexer.ASTERISK),\n  ],\n  createNodes: tokens => [\n    {\n      type: Tree.REGION_MODE,\n      position: tokensToPosition(tokens),\n      region: tokens[0].value === '36',\n    },\n  ],\n}\n\nconst quadrantMode: SyntaxRule = {\n  name: 'quadrantMode',\n  rules: [\n    one([token(Lexer.G_CODE, '74'), token(Lexer.G_CODE, '75')]),\n    token(Lexer.ASTERISK),\n  ],\n  createNodes: tokens => [\n    {\n      type: Tree.QUADRANT_MODE,\n      position: tokensToPosition(tokens),\n      quadrant: tokens[0].value === '74' ? Constants.SINGLE : Constants.MULTI,\n    },\n  ],\n}\n\nconst loadPolarity: SyntaxRule = {\n  name: 'loadPolarity',\n  rules: [\n    token(Lexer.PERCENT),\n    token(Lexer.GERBER_LOAD_POLARITY),\n    token(Lexer.ASTERISK),\n    token(Lexer.PERCENT),\n  ],\n  createNodes: tokens => [\n    {\n      type: Tree.LOAD_POLARITY,\n      position: tokensToPosition(tokens.slice(1, -1)),\n      polarity: tokens[1].value === 'D' ? Constants.DARK : Constants.CLEAR,\n    },\n  ],\n}\n\nconst stepRepeat: SyntaxRule = {\n  name: 'stepRepeat',\n  rules: [\n    token(Lexer.PERCENT),\n    token(Lexer.GERBER_STEP_REPEAT),\n    zeroOrMore([token(Lexer.COORD_CHAR), token(Lexer.NUMBER)]),\n    token(Lexer.ASTERISK),\n    token(Lexer.PERCENT),\n  ],\n  createNodes(tokens) {\n    const coordinates = tokensToCoordinates(tokens)\n    const parameters = Object.fromEntries(\n      Object.entries(coordinates).map(([axis, coordinateString]) => [\n        axis,\n        Number(coordinateString),\n      ])\n    )\n\n    return [\n      {\n        type: Tree.STEP_REPEAT,\n        position: tokensToPosition(tokens.slice(1, -1)),\n        stepRepeat: parameters,\n      },\n    ]\n  },\n}\n\nconst unimplementedExtendedCommand: SyntaxRule = {\n  name: 'unimplementedExtendedCommand',\n  rules: [\n    token(Lexer.PERCENT),\n    zeroOrMore([notToken(Lexer.ASTERISK)]),\n    token(Lexer.ASTERISK),\n    token(Lexer.PERCENT),\n  ],\n  createNodes: tokens => [\n    {\n      type: Tree.UNIMPLEMENTED,\n      position: tokensToPosition(tokens.slice(1, -1)),\n      value: tokensToString(tokens),\n    },\n  ],\n}\n\nexport const gerberGrammar: SyntaxRule[] = [\n  operation,\n  operationWithoutCoords,\n  interpolationMode,\n  toolChange,\n  toolDefinition,\n  toolMacro,\n  comment,\n  regionMode,\n  quadrantMode,\n  loadPolarity,\n  stepRepeat,\n  format,\n  units,\n  done,\n  unimplementedExtendedCommand,\n].map(r => ({...r, filetype: Constants.GERBER}))\n","import type {Filetype} from '../types'\nimport type {GerberNode} from '../tree'\nimport type {Token, LexerIterable, LexerState} from '../lexer'\nimport {GERBER, DRILL} from '../constants'\nimport type {SyntaxRule} from './rules'\nimport {findSyntaxMatch} from './rules'\nimport {drillGrammar} from './drill'\nimport {gerberGrammar} from './gerber'\n\nconst grammar: SyntaxRule[] = [...gerberGrammar, ...drillGrammar]\n\nexport interface MatchResult {\n  filetype: Filetype | null\n  nodes: GerberNode[]\n  unmatched: string\n  lexerState: LexerState | null\n}\n\nexport function matchSyntax(\n  tokens: LexerIterable,\n  filetype: Filetype | null = null\n): MatchResult {\n  const nodes: GerberNode[] = []\n  let matchedCandidates = getGrammar()\n  let matchedTokens: Token[] = []\n  let nextLexerState: LexerState | null = null\n  let unmatched = ''\n\n  for (const [token, lexerState] of tokens) {\n    const result = findSyntaxMatch([...matchedTokens, token], matchedCandidates)\n\n    if (result.nodes) {\n      nodes.push(...result.nodes)\n      nextLexerState = lexerState\n      unmatched = ''\n    } else {\n      unmatched += token.text\n    }\n\n    filetype = filetype ?? result.filetype ?? null\n    matchedTokens = result.tokens ?? []\n    matchedCandidates = result.candidates ?? getGrammar()\n  }\n\n  return {\n    filetype,\n    unmatched,\n    nodes,\n    lexerState: nextLexerState,\n  }\n\n  function getGrammar() {\n    if (filetype === GERBER) return gerberGrammar\n    if (filetype === DRILL) return drillGrammar\n    return grammar\n  }\n}\n","import type {Lexer, LexerState} from './lexer'\nimport {createLexer} from './lexer'\nimport {matchSyntax} from './syntax'\nimport type {GerberTree, GerberNode} from './tree'\nimport {ROOT} from './tree'\nimport type {Filetype} from './types'\n\nexport * from './constants'\nexport * from './lexer'\nexport * from './tree'\nexport * from './types'\n\n/**\n * Gerber and NC drill file parser.\n *\n * @category Parser\n */\nexport interface Parser {\n  /** Parser's {@linkcode Lexer} instance */\n  lexer: Lexer\n  /** Feed the parser with all or part of the source file */\n  feed(chunk: string): this\n  /** Get the resulting AST when you are done feeding the parser */\n  result(): GerberTree\n}\n\n/**\n * {@linkcode Parser} factory and the primary export of the library.\n *\n * @example\n * ```ts\n * import {createParser} from '@tracespace/parser'\n *\n * // create a parser to parse a single file\n * const parser = createParser()\n *\n * // feed the parser the source file contents\n * parser.feed('G04 gerber file contents*\\nM02*\\n')\n *\n * // get the resulting AST\n * const tree = parser.results()\n * ```\n *\n * @category Parser\n */\nexport function createParser(): Parser {\n  const lexer = createLexer()\n  const children: GerberNode[] = []\n  let filetype: Filetype | null = null\n  let lexerState: LexerState | null = null\n  let unmatched = ''\n\n  const parser = {lexer, feed, result}\n  return parser\n\n  function feed(chunk: string): Parser {\n    const tokens = lexer.feed(`${unmatched}${chunk}`, lexerState)\n    const result = matchSyntax(tokens, filetype)\n\n    filetype = filetype ?? result.filetype\n    unmatched = result.unmatched\n    lexerState = result.lexerState ?? lexerState\n    children.push(...result.nodes)\n\n    return parser\n  }\n\n  function result(): GerberTree {\n    if (filetype === null) {\n      throw new Error('File type not recognized')\n    }\n\n    return {type: ROOT, filetype, children}\n  }\n}\n\nexport function parse(contents: string): GerberTree {\n  return createParser().feed(contents).result()\n}\n"],"names":["root","factory","module","this","hasOwnProperty","toString","hasSticky","isRegExp","o","isObject","reEscape","s","reGroups","re","reCapture","reUnion","regexps","source","regexpOrLiteral","obj","pad","length","lastNLines","string","numLines","position","lineBreaks","idx","startPosition","objectToRules","object","keys","result","i","key","thing","rules","j","match","rule","ruleOptions","arrayToRules","array","include","type","options","a","b","toRules","spec","defaultErrorRule","compileRules","hasStates","errorRule","fast","fastAllowed","unicodeFlag","groups","parts","word","pat","regexp","groupCount","fallbackRule","flags","suffix","combined","compile","Lexer","checkStateGroup","g","name","map","state","compileStates","states","start","all","ruleMap","included","splice","newRules","k","newRule","fastKeys","keywordTransform","isMap","reverseMap","types","tokenType","item","keywordList","keyword","data","info","eat","buffer","tokenToString","index","token","group","error","text","offset","matchNL","nl","size","err","LexerIterator","lexer","message","numLinesAround","firstDisplayedLine","lastDisplayedLine","lastLineDigits","displayedLines","errorLines","line","lineNo","T_CODE","G_CODE","M_CODE","D_CODE","ASTERISK","PERCENT","EQUALS","COMMA","OPERATOR","GERBER_FORMAT","GERBER_UNITS","GERBER_TOOL_MACRO","GERBER_TOOL_DEF","GERBER_LOAD_POLARITY","GERBER_STEP_REPEAT","GERBER_MACRO_VARIABLE","SEMICOLON","DRILL_UNITS","DRILL_ZERO_INCLUSION","COORD_CHAR","NUMBER","WORD","WHITESPACE","NEWLINE","CATCHALL","ERROR","RE_STRIP_LEADING_ZEROS","stripLeadingZeros","getCodeValue","Tokens.T_CODE","Tokens.G_CODE","Tokens.M_CODE","Tokens.D_CODE","Tokens.ASTERISK","Tokens.PERCENT","Tokens.EQUALS","Tokens.GERBER_FORMAT","Tokens.GERBER_UNITS","Tokens.GERBER_TOOL_MACRO","Tokens.GERBER_TOOL_DEF","Tokens.GERBER_LOAD_POLARITY","Tokens.GERBER_STEP_REPEAT","Tokens.GERBER_MACRO_VARIABLE","Tokens.SEMICOLON","Tokens.DRILL_UNITS","Tokens.DRILL_ZERO_INCLUSION","Tokens.COORD_CHAR","Tokens.NUMBER","Tokens.OPERATOR","Tokens.COMMA","Tokens.WORD","Tokens.WHITESPACE","Tokens.NEWLINE","Tokens.CATCHALL","Tokens.ERROR","Moo","createLexer","mooLexer","feed","chunk","tokenIterator","nextToken","nextState","GERBER","DRILL","MM","IN","LEADING","TRAILING","ABSOLUTE","INCREMENTAL","CIRCLE","RECTANGLE","OBROUND","POLYGON","MACRO_SHAPE","MACRO_CIRCLE","MACRO_VECTOR_LINE_DEPRECATED","MACRO_VECTOR_LINE","MACRO_CENTER_LINE","MACRO_LOWER_LEFT_LINE_DEPRECATED","MACRO_OUTLINE","MACRO_POLYGON","MACRO_MOIRE_DEPRECATED","MACRO_THERMAL","SHAPE","MOVE","SEGMENT","SLOT","LINE","CW_ARC","CCW_ARC","SINGLE","MULTI","DARK","CLEAR","SINGLE_TOKEN","MIN_TO_MAX","value","notToken","one","zeroOrOne","zeroOrMore","oneOrMore","minToMax","min","max","findSyntaxMatch","tokens","candidates","remainingCandidates","candidate","matchType","tokenListMatches","PARTIAL_MATCH","FULL_MATCH","NO_MATCH","multiMatchCount","tokenMatches","typeResult","valueResult","ROOT","COMMENT","DRILL_HEADER","DONE","UNITS","COORDINATE_FORMAT","TOOL_DEFINITION","TOOL_MACRO","TOOL_CHANGE","LOAD_POLARITY","STEP_REPEAT","GRAPHIC","INTERPOLATE_MODE","REGION_MODE","QUADRANT_MODE","UNIMPLEMENTED","MACRO_COMMENT","MACRO_VARIABLE","MACRO_PRIMITIVE","tokensToCoordinates","previousToken","tokensToMode","t","tokensToGraphic","tokensToString","tokensToPosition","head","tail","units","Lexer.DRILL_UNITS","Lexer.M_CODE","Lexer.COMMA","Lexer.DRILL_ZERO_INCLUSION","Lexer.NUMBER","Lexer.NEWLINE","Constants.IN","Constants.MM","zeroSuppression","Constants.TRAILING","Constants.LEADING","format","integer","decimal","nodes","Tree.UNITS","Tree.COORDINATE_FORMAT","tool","Lexer.T_CODE","Lexer.COORD_CHAR","code","c","shape","Constants.CIRCLE","Tree.TOOL_DEFINITION","Tree.TOOL_CHANGE","mode","Lexer.G_CODE","Tree.INTERPOLATE_MODE","operation","graphicTokens","modeToken","toolToken","coordinates","graphicPosition","modePosition","toolPosition","Tree.GRAPHIC","slot","gCode","splitIdx","axis","end","Constants.SLOT","done","Tree.DONE","header","Lexer.PERCENT","Tree.DRILL_HEADER","comment","Lexer.SEMICOLON","Tree.COMMENT","drillGrammar","r","Constants.DRILL","macroComment","Lexer.ASTERISK","createMacroComment","macroVariable","Lexer.GERBER_MACRO_VARIABLE","Lexer.EQUALS","Lexer.OPERATOR","createMacroVariable","macroPrimitive","createMacroPrimitive","Tree.MACRO_COMMENT","commaDelimitedTokens","currentGroup","parameters","parseMacroExpression","Tree.MACRO_PRIMITIVE","Tree.MACRO_VARIABLE","toParse","parseAddition","peekNextToken","parsePrimary","expression","parseMultiplication","operator","right","MACRO_GRAMMAR","parseMacroBlocks","matchedCandidates","matchedTokens","blocks","holeShape","diameter","xSize","ySize","Constants.RECTANGLE","Lexer.GERBER_FORMAT","Lexer.GERBER_UNITS","coords","formatEndIdx","unitsToken","Constants.INCREMENTAL","Constants.ABSOLUTE","_a","integers","decimals","toolMacro","Lexer.GERBER_TOOL_MACRO","blockTokens","Tree.TOOL_MACRO","toolDefinition","Lexer.GERBER_TOOL_DEF","hole","toolProps","holeParameters","Constants.OBROUND","vertices","rotation","Constants.POLYGON","Constants.MACRO_SHAPE","toolChange","Lexer.D_CODE","createOperationNodes","graphic","operationWithoutCoords","interpolationMode","regionMode","Tree.REGION_MODE","quadrantMode","Tree.QUADRANT_MODE","Constants.SINGLE","Constants.MULTI","loadPolarity","Lexer.GERBER_LOAD_POLARITY","Tree.LOAD_POLARITY","Constants.DARK","Constants.CLEAR","stepRepeat","Lexer.GERBER_STEP_REPEAT","coordinateString","Tree.STEP_REPEAT","unimplementedExtendedCommand","Tree.UNIMPLEMENTED","gerberGrammar","Constants.GERBER","grammar","matchSyntax","filetype","getGrammar","nextLexerState","unmatched","lexerState","createParser","children","parser","parse","contents"],"mappings":"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"}