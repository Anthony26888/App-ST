{"version":3,"file":"tracespace-plotter.js","sources":["../src/tree.ts","../src/coordinate-math.ts","../src/bounding-box.ts","../src/options.ts","../src/tool-store.ts","../src/location-store.ts","../src/graphic-plotter/shapes.ts","../src/graphic-plotter/plot-shape.ts","../src/graphic-plotter/plot-rect-path.ts","../src/graphic-plotter/plot-path.ts","../src/graphic-plotter/plot-macro.ts","../src/graphic-plotter/index.ts","../src/index.ts"],"sourcesContent":["import type {Node, Parent} from 'unist'\n\nimport type {UnitsType} from '@tracespace/parser'\n\nexport const IMAGE = 'image'\nexport const IMAGE_SHAPE = 'imageShape'\nexport const IMAGE_PATH = 'imagePath'\nexport const IMAGE_REGION = 'imageRegion'\n\nexport const LINE = 'line'\nexport const ARC = 'arc'\n\nexport const CIRCLE = 'circle'\nexport const RECTANGLE = 'rectangle'\nexport const POLYGON = 'polygon'\nexport const OUTLINE = 'outline'\nexport const LAYERED_SHAPE = 'layeredShape'\n\nexport type Position = [x: number, y: number]\n\nexport type ArcPosition = [x: number, y: number, theta: number]\n\nexport type SizeEnvelope = [x1: number, y1: number, x2: number, y2: number] | []\n\nexport type ImageNode = ImageTree | ImageShape | ImagePath | ImageRegion\n\nexport interface CircleShape {\n  type: typeof CIRCLE\n  cx: number\n  cy: number\n  r: number\n}\n\nexport interface RectangleShape {\n  type: typeof RECTANGLE\n  x: number\n  y: number\n  xSize: number\n  ySize: number\n  r?: number\n}\n\nexport interface PolygonShape {\n  type: typeof POLYGON\n  points: Position[]\n}\n\nexport interface OutlineShape {\n  type: typeof OUTLINE\n  segments: PathSegment[]\n}\n\nexport interface LayeredShape {\n  type: typeof LAYERED_SHAPE\n  shapes: ErasableShape[]\n}\n\nexport type HoleShape = CircleShape | RectangleShape\n\nexport type SimpleShape =\n  | CircleShape\n  | RectangleShape\n  | PolygonShape\n  | OutlineShape\n\nexport type Shape = SimpleShape | LayeredShape\n\nexport type ErasableShape = SimpleShape & {erase?: boolean}\n\nexport type ImageGraphic = ImageShape | ImagePath | ImageRegion\n\nexport interface ImageTree extends Parent {\n  type: typeof IMAGE\n  units: UnitsType\n  size: SizeEnvelope\n  children: ImageGraphic[]\n}\n\nexport interface ImageShape extends Node {\n  type: typeof IMAGE_SHAPE\n  shape: Shape\n}\n\nexport interface ImagePath extends Node {\n  type: typeof IMAGE_PATH\n  width: number\n  segments: PathSegment[]\n}\n\nexport interface ImageRegion extends Node {\n  type: typeof IMAGE_REGION\n  segments: PathSegment[]\n}\n\nexport type PathSegment = PathLineSegment | PathArcSegment\n\nexport interface PathLineSegment {\n  type: typeof LINE\n  start: Position\n  end: Position\n}\n\nexport interface PathArcSegment {\n  type: typeof ARC\n  start: ArcPosition\n  end: ArcPosition\n  center: Position\n  radius: number\n}\n","// Mathematical procedures\nimport type {Position} from './tree'\n\nexport const {PI} = Math\nexport const HALF_PI = PI / 2\nexport const THREE_HALF_PI = 3 * HALF_PI\nexport const TWO_PI = 2 * PI\n\nexport function limitAngle(theta: number): number {\n  if (theta >= 0 && theta <= TWO_PI) return theta\n  if (theta < 0) return theta + TWO_PI\n  if (theta > TWO_PI) return theta - TWO_PI\n  return limitAngle(theta)\n}\n\nexport function rotateQuadrant(theta: number): number {\n  return theta >= HALF_PI ? theta - HALF_PI : theta + THREE_HALF_PI\n}\n\nexport function degreesToRadians(degrees: number): number {\n  return (degrees * Math.PI) / 180\n}\n\nexport function rotateAndShift(\n  point: Position,\n  shift: Position,\n  degrees = 0\n): Position {\n  const rotation = degreesToRadians(degrees)\n  const [sin, cos] = [Math.sin(rotation), Math.cos(rotation)]\n  const [x, y] = point\n  const nextX = x * cos - y * sin + shift[0]\n  const nextY = x * sin + y * cos + shift[1]\n\n  return [nextX, nextY]\n}\n\nexport function positionsEqual(a: number[], b: number[]): boolean {\n  return a[0] === b[0] && a[1] === b[1]\n}\n","import * as Tree from './tree'\nimport {TWO_PI, limitAngle, rotateQuadrant} from './coordinate-math'\nimport type {SizeEnvelope as Box, Position, ArcPosition} from './tree'\n\nexport type {SizeEnvelope as Box} from './tree'\n\nexport function isEmpty(box: Box): box is [] {\n  return box.length === 0\n}\n\nexport function empty(): Box {\n  return []\n}\n\nexport function add(a: Box, b: Box): Box {\n  if (isEmpty(a)) return b\n  if (isEmpty(b)) return a\n\n  return [\n    Math.min(a[0], b[0]),\n    Math.min(a[1], b[1]),\n    Math.max(a[2], b[2]),\n    Math.max(a[3], b[3]),\n  ]\n}\n\nexport function sum(boxes: Box[]): Box {\n  return boxes.reduce(add, empty())\n}\n\nexport function fromGraphics(graphics: Tree.ImageGraphic[]): Box {\n  return sum(graphics.map(fromGraphic))\n}\n\nexport function fromGraphic(graphic: Tree.ImageGraphic): Box {\n  return graphic.type === Tree.IMAGE_SHAPE\n    ? fromShape(graphic.shape)\n    : fromPath(\n        graphic.segments,\n        graphic.type === Tree.IMAGE_PATH ? graphic.width : undefined\n      )\n}\n\nexport function fromShape(shape: Tree.Shape): Box {\n  switch (shape.type) {\n    case Tree.CIRCLE: {\n      const {cx, cy, r} = shape\n      return fromPosition([cx, cy], r)\n    }\n\n    case Tree.RECTANGLE: {\n      const {x, y, xSize, ySize} = shape\n      return [x, y, x + xSize, y + ySize]\n    }\n\n    case Tree.POLYGON: {\n      return sum(shape.points.map(p => fromPosition(p)))\n    }\n\n    case Tree.OUTLINE: {\n      return fromPath(shape.segments)\n    }\n\n    case Tree.LAYERED_SHAPE: {\n      return sum(shape.shapes.filter(({erase}) => !erase).map(fromShape))\n    }\n  }\n}\n\nexport function fromPath(segments: Tree.PathSegment[], width = 0): Box {\n  const rTool = width / 2\n  const keyPoints: Array<Tree.Position | Tree.ArcPosition> = []\n\n  for (const segment of segments) {\n    keyPoints.push(segment.start, segment.end)\n\n    if (segment.type === Tree.ARC) {\n      const {start, end, center, radius} = segment\n      const sweep = Math.abs(end[2] - start[2])\n\n      // Normalize direction to counter-clockwise\n      let [thetaStart, thetaEnd] =\n        end[2] > start[2] ? [start[2], end[2]] : [end[2], start[2]]\n\n      thetaStart = limitAngle(thetaStart)\n      thetaEnd = limitAngle(thetaEnd)\n\n      const axisPoints: Tree.Position[] = [\n        [center[0] + radius, center[1]],\n        [center[0], center[1] + radius],\n        [center[0] - radius, center[1]],\n        [center[0], center[1] - radius],\n      ]\n\n      for (const p of axisPoints) {\n        if (thetaStart > thetaEnd || sweep === TWO_PI) {\n          keyPoints.push(p)\n        }\n\n        // Rotate to check for next axis key point\n        thetaStart = rotateQuadrant(thetaStart)\n        thetaEnd = rotateQuadrant(thetaEnd)\n      }\n    }\n  }\n\n  return sum(keyPoints.map(p => fromPosition(p, rTool)))\n}\n\nfunction fromPosition(position: Position | ArcPosition, radius = 0): Box {\n  return [\n    position[0] - radius,\n    position[1] - radius,\n    position[0] + radius,\n    position[1] + radius,\n  ]\n}\n","import type {\n  GerberTree,\n  UnitsType,\n  Format,\n  ZeroSuppression,\n} from '@tracespace/parser'\nimport {\n  UNITS,\n  COORDINATE_FORMAT,\n  GRAPHIC,\n  COMMENT,\n  LEADING,\n  TRAILING,\n  IN,\n} from '@tracespace/parser'\n\nexport interface PlotOptions {\n  units: UnitsType\n  coordinateFormat: Format\n  zeroSuppression: ZeroSuppression\n}\n\nconst FORMAT_COMMENT_RE = /FORMAT={?(\\d):(\\d)/\n\nexport function getPlotOptions(tree: GerberTree): PlotOptions {\n  const {children: treeNodes} = tree\n  let units: UnitsType | null = null\n  let coordinateFormat: Format | null = null\n  let zeroSuppression: ZeroSuppression | null = null\n  let index = 0\n\n  while (\n    index < treeNodes.length &&\n    (units === null || coordinateFormat === null || zeroSuppression === null)\n  ) {\n    const node = treeNodes[index]\n\n    switch (node.type) {\n      case UNITS: {\n        units = node.units\n        break\n      }\n\n      case COORDINATE_FORMAT: {\n        coordinateFormat = node.format\n        zeroSuppression = node.zeroSuppression\n        break\n      }\n\n      case GRAPHIC: {\n        const {coordinates} = node\n\n        for (const coordinate of Object.values(coordinates)) {\n          if (zeroSuppression !== null) break\n\n          if (coordinate!.endsWith('0') || coordinate!.includes('.')) {\n            zeroSuppression = LEADING\n          } else if (coordinate!.startsWith('0')) {\n            zeroSuppression = TRAILING\n          }\n        }\n\n        break\n      }\n\n      case COMMENT: {\n        const {comment} = node\n        const formatMatch = FORMAT_COMMENT_RE.exec(comment)\n\n        if (/suppress trailing/i.test(comment)) {\n          zeroSuppression = TRAILING\n        } else if (/(suppress leading|keep zeros)/i.test(comment)) {\n          zeroSuppression = LEADING\n        }\n\n        if (formatMatch) {\n          coordinateFormat = [Number(formatMatch[1]), Number(formatMatch[2])]\n        }\n\n        break\n      }\n\n      default:\n    }\n\n    index += 1\n  }\n\n  return {\n    units: units ?? IN,\n    coordinateFormat: coordinateFormat ?? [2, 4],\n    zeroSuppression: zeroSuppression ?? LEADING,\n  }\n}\n","// Tool store\n// Keeps track of the defined tools, defined macros, and the current tool\nimport type {\n  GerberNode,\n  SimpleShape,\n  HoleShape,\n  MacroBlock,\n} from '@tracespace/parser'\nimport {\n  MACRO_SHAPE,\n  TOOL_CHANGE,\n  TOOL_DEFINITION,\n  TOOL_MACRO,\n} from '@tracespace/parser'\n\nexport const SIMPLE_TOOL = 'simpleTool'\n\nexport const MACRO_TOOL = 'macroTool'\n\nexport interface SimpleTool {\n  type: typeof SIMPLE_TOOL\n  shape: SimpleShape\n  hole?: HoleShape\n}\n\nexport interface MacroTool {\n  type: typeof MACRO_TOOL\n  macro: MacroBlock[]\n  variableValues: number[]\n}\n\nexport type Tool = SimpleTool | MacroTool\n\nexport interface ToolStore {\n  use(node: GerberNode): Tool | undefined\n}\n\nexport function createToolStore(): ToolStore {\n  return Object.create(ToolStorePrototype)\n}\n\ninterface ToolStoreState {\n  _currentToolCode: string | undefined\n  _toolsByCode: Partial<Record<string, Tool>>\n  _macrosByName: Partial<Record<string, MacroBlock[]>>\n}\n\nconst ToolStorePrototype: ToolStore & ToolStoreState = {\n  _currentToolCode: undefined,\n  _toolsByCode: {},\n  _macrosByName: {},\n\n  use(node: GerberNode): Tool | undefined {\n    if (node.type === TOOL_MACRO) {\n      this._macrosByName[node.name] = node.children\n    }\n\n    if (node.type === TOOL_DEFINITION) {\n      const {shape, hole} = node\n      const tool: Tool =\n        shape.type === MACRO_SHAPE\n          ? {\n              type: MACRO_TOOL,\n              macro: this._macrosByName[shape.name] ?? [],\n              variableValues: shape.variableValues,\n            }\n          : {type: SIMPLE_TOOL, shape, ...(hole && {hole})}\n\n      this._toolsByCode[node.code] = tool\n    }\n\n    if (node.type === TOOL_DEFINITION || node.type === TOOL_CHANGE) {\n      this._currentToolCode = node.code\n    }\n\n    return typeof this._currentToolCode === 'string'\n      ? this._toolsByCode[this._currentToolCode]\n      : undefined\n  },\n}\n","// Track the location of the plotter and parse coordinate strings\nimport type {GerberNode} from '@tracespace/parser'\nimport {GRAPHIC, TRAILING} from '@tracespace/parser'\n\nimport type {PlotOptions} from './options'\n\nexport interface Point {\n  x: number\n  y: number\n}\n\nexport interface ArcOffsets {\n  i: number\n  j: number\n  a: number\n}\n\nexport interface Location {\n  startPoint: Point\n  endPoint: Point\n  arcOffsets: ArcOffsets\n}\n\nexport interface LocationStore {\n  use(node: GerberNode, options: PlotOptions): Location\n}\n\nexport function createLocationStore(): LocationStore {\n  return Object.create(LocationStorePrototype)\n}\n\ninterface LocationStoreState {\n  _DEFAULT_ARC_OFFSETS: ArcOffsets\n  _previousPoint: Point\n}\n\nconst LocationStorePrototype: LocationStore & LocationStoreState = {\n  _DEFAULT_ARC_OFFSETS: {i: 0, j: 0, a: 0},\n  _previousPoint: {x: 0, y: 0},\n\n  use(node: GerberNode, options: PlotOptions): Location {\n    let arcOffsets = this._DEFAULT_ARC_OFFSETS\n    let startPoint = this._previousPoint\n    let endPoint = startPoint\n\n    if (node.type === GRAPHIC) {\n      const {coordinates} = node\n      const x0 = parseCoordinate(coordinates.x0, startPoint.x, options)\n      const y0 = parseCoordinate(coordinates.y0, startPoint.y, options)\n      const x = parseCoordinate(coordinates.x, x0, options)\n      const y = parseCoordinate(coordinates.y, y0, options)\n      const i = parseCoordinate(coordinates.i, 0, options)\n      const j = parseCoordinate(coordinates.j, 0, options)\n      const a = parseCoordinate(coordinates.a, 0, options)\n\n      if (startPoint.x !== x0 || startPoint.y !== y0) {\n        startPoint = {x: x0, y: y0}\n      }\n\n      if (endPoint.x !== x || endPoint.y !== y) {\n        endPoint = {x, y}\n      }\n\n      if (i !== 0 || j !== 0 || a !== 0) {\n        arcOffsets = {i, j, a}\n      }\n    }\n\n    this._previousPoint = endPoint\n    return {startPoint, endPoint, arcOffsets}\n  },\n}\n\nfunction parseCoordinate(\n  coordinate: string | undefined,\n  defaultValue: number,\n  options: PlotOptions\n): number {\n  if (typeof coordinate !== 'string') {\n    return defaultValue\n  }\n\n  if (coordinate.includes('.') || coordinate === '0') {\n    return Number(coordinate)\n  }\n\n  const {coordinateFormat, zeroSuppression} = options\n  const [integerPlaces, decimalPlaces] = coordinateFormat\n\n  const [sign, signlessCoordinate] =\n    coordinate.startsWith('+') || coordinate.startsWith('-')\n      ? [coordinate[0], coordinate.slice(1)]\n      : ['+', coordinate]\n\n  const digits = integerPlaces + decimalPlaces\n  const paddedCoordinate =\n    zeroSuppression === TRAILING\n      ? signlessCoordinate.padEnd(digits, '0')\n      : signlessCoordinate.padStart(digits, '0')\n\n  const leading = paddedCoordinate.slice(0, integerPlaces)\n  const trailing = paddedCoordinate.slice(integerPlaces)\n\n  return Number(`${sign}${leading}.${trailing}`)\n}\n","import type {SimpleShape} from '@tracespace/parser'\nimport {CIRCLE, RECTANGLE, OBROUND, POLYGON} from '@tracespace/parser'\n\nimport {\n  HALF_PI,\n  PI,\n  THREE_HALF_PI,\n  TWO_PI,\n  degreesToRadians,\n} from '../coordinate-math'\n\nimport * as Tree from '../tree'\nimport type {Point} from '../location-store'\n\nexport function createShape(\n  shape: SimpleShape,\n  point: Point\n): Tree.SimpleShape {\n  const {x, y} = point\n\n  switch (shape.type) {\n    case CIRCLE: {\n      const {diameter} = shape\n      return {type: Tree.CIRCLE, cx: x, cy: y, r: diameter / 2}\n    }\n\n    case RECTANGLE:\n    case OBROUND: {\n      const {xSize, ySize} = shape\n      const xHalf = xSize / 2\n      const yHalf = ySize / 2\n      const rectangle: Tree.RectangleShape = {\n        type: Tree.RECTANGLE,\n        x: x - xHalf,\n        y: y - yHalf,\n        xSize,\n        ySize,\n      }\n\n      if (shape.type === OBROUND) {\n        rectangle.r = Math.min(xHalf, yHalf)\n      }\n\n      return rectangle\n    }\n\n    case POLYGON: {\n      const {diameter, rotation, vertices} = shape\n      const r = diameter / 2\n      const offset = degreesToRadians(rotation ?? 0)\n      const step = TWO_PI / vertices\n      const points = Array.from({length: vertices}).map<Tree.Position>(\n        (_, i) => {\n          const theta = step * i + offset\n          const pointX = x + r * Math.cos(theta)\n          const pointY = y + r * Math.sin(theta)\n          return [pointX, pointY]\n        }\n      )\n\n      return {type: Tree.POLYGON, points}\n    }\n  }\n}\n\nexport function shapeToSegments(shape: Tree.SimpleShape): Tree.PathSegment[] {\n  if (shape.type === Tree.CIRCLE) {\n    const {cx, cy, r} = shape\n    return [\n      {\n        type: Tree.ARC,\n        start: [cx + r, cy, 0],\n        end: [cx + r, cy, TWO_PI],\n        center: [cx, cy],\n        radius: r,\n      },\n    ]\n  }\n\n  if (shape.type === Tree.RECTANGLE) {\n    const {x, y, xSize, ySize, r} = shape\n\n    if (r === xSize / 2) {\n      return [\n        {\n          type: Tree.LINE,\n          start: [x + xSize, y + r],\n          end: [x + xSize, y + ySize - r],\n        },\n        {\n          type: Tree.ARC,\n          start: [x + xSize, y + ySize - r, 0],\n          end: [x, y + ySize - r, PI],\n          center: [x + r, y + ySize - r],\n          radius: r,\n        },\n        {type: Tree.LINE, start: [x, y + ySize - r], end: [x, y + r]},\n        {\n          type: Tree.ARC,\n          start: [x, y + r, PI],\n          end: [x + xSize, y + r, TWO_PI],\n          center: [x + r, y + r],\n          radius: r,\n        },\n      ]\n    }\n\n    if (r === ySize / 2) {\n      return [\n        {type: Tree.LINE, start: [x + r, y], end: [x + xSize - r, y]},\n        {\n          type: Tree.ARC,\n          start: [x + xSize - r, y, -HALF_PI],\n          end: [x + xSize - r, y + ySize, HALF_PI],\n          center: [x + xSize - r, y + r],\n          radius: r,\n        },\n        {\n          type: Tree.LINE,\n          start: [x + xSize - r, y + ySize],\n          end: [x + r, y + ySize],\n        },\n        {\n          type: Tree.ARC,\n          start: [x + r, y + ySize, HALF_PI],\n          end: [x + r, y, THREE_HALF_PI],\n          center: [x + r, y + r],\n          radius: r,\n        },\n      ]\n    }\n\n    return [\n      {type: Tree.LINE, start: [x, y], end: [x + xSize, y]},\n      {type: Tree.LINE, start: [x + xSize, y], end: [x + xSize, y + ySize]},\n      {type: Tree.LINE, start: [x + xSize, y + ySize], end: [x, y + ySize]},\n      {type: Tree.LINE, start: [x, y + ySize], end: [x, y]},\n    ]\n  }\n\n  if (shape.type === Tree.POLYGON) {\n    return shape.points.map((start, i) => {\n      const endIndex = i < shape.points.length - 1 ? i + 1 : 0\n      return {type: Tree.LINE, start, end: shape.points[endIndex]}\n    })\n  }\n\n  return shape.segments\n}\n","import {MACRO_SHAPE} from '@tracespace/parser'\n\nimport * as Tree from '../tree'\nimport type {Location} from '../location-store'\nimport type {SimpleTool} from '../tool-store'\n\nimport {createShape, shapeToSegments} from './shapes'\n\nexport function plotShape(tool: SimpleTool, location: Location): Tree.Shape {\n  const {shape: toolShape, hole: toolHole} = tool\n  const shape = createShape(toolShape, location.endPoint)\n  const holeShape = toolHole\n    ? createShape(toolHole, location.endPoint)\n    : undefined\n\n  return holeShape === undefined\n    ? shape\n    : {\n        type: Tree.OUTLINE,\n        segments: [...shapeToSegments(shape), ...shapeToSegments(holeShape)],\n      }\n}\n","// Functions for stroking rectangular tools\n// Stroking rectangular tools is deprecated by the Gerber spec\n// This functionality may be dropped and replaced with a warning\nimport type {Rectangle} from '@tracespace/parser'\n\nimport * as Tree from '../tree'\nimport {positionsEqual, HALF_PI, PI} from '../coordinate-math'\n\n// Rectangular tools make interesting stroke geometry; see the Gerber spec\n// for graphics and examples\nexport function plotRectPath(\n  segments: Tree.PathSegment[],\n  shape: Rectangle\n): Tree.ImageShape {\n  const shapes = segments\n    .filter((s): s is Tree.PathLineSegment => s.type === Tree.LINE)\n    .map(segment => plotRectPathSegment(segment, shape))\n\n  return {type: Tree.IMAGE_SHAPE, shape: {type: Tree.LAYERED_SHAPE, shapes}}\n}\n\nfunction plotRectPathSegment(\n  segment: Tree.PathLineSegment,\n  shape: Rectangle\n): Tree.PolygonShape {\n  // Since a rectangular stroke like this is so unique to Gerber, it's easier\n  // for downstream graphics generators if we calculate the boundaries of the\n  // correct shape and emit a region rather than a path with a width (which is\n  // what we do for circle tools)\n  const {start, end} = segment\n  const [sx, sy] = start\n  const [ex, ey] = end\n  const [xOffset, yOffset] = [shape.xSize / 2, shape.ySize / 2]\n  const theta = Math.atan2(ey - sy, ex - ey)\n\n  const [sxMin, sxMax] = [sx - xOffset, sx + xOffset]\n  const [syMin, syMax] = [sy - yOffset, sy + yOffset]\n  const [exMin, exMax] = [ex - xOffset, ex + xOffset]\n  const [eyMin, eyMax] = [ey - yOffset, ey + yOffset]\n\n  // Go through the quadrants of the XY plane centered about start to decide\n  // which segments define the boundaries of the stroke shape\n  let points: Tree.Position[] = []\n  if (positionsEqual(start, end)) {\n    points = [\n      [sxMin, syMin],\n      [sxMax, syMin],\n      [exMax, eyMin],\n      [exMax, eyMax],\n      [exMin, eyMax],\n      [sxMin, syMax],\n    ]\n  } else if (theta >= 0 && theta < HALF_PI) {\n    // First quadrant move\n    points = [\n      [sxMin, syMin],\n      [sxMax, syMin],\n      [exMax, eyMin],\n      [exMax, eyMax],\n      [exMin, eyMax],\n      [sxMin, syMax],\n    ]\n  } else if (theta >= HALF_PI && theta <= PI) {\n    // Second quadrant move\n    points = [\n      [sxMax, syMin],\n      [sxMax, syMax],\n      [exMax, eyMax],\n      [exMin, eyMax],\n      [exMin, eyMin],\n      [sxMin, syMin],\n    ]\n  } else if (theta >= -PI && theta < -HALF_PI) {\n    // Third quadrant move\n    points = [\n      [sxMax, syMax],\n      [sxMin, syMax],\n      [exMin, eyMax],\n      [exMin, eyMin],\n      [exMax, eyMin],\n      [sxMax, syMin],\n    ]\n  } else {\n    // Fourth quadrant move\n    points = [\n      [sxMin, syMax],\n      [sxMin, syMin],\n      [exMin, eyMin],\n      [exMax, eyMin],\n      [exMax, eyMax],\n      [sxMax, syMax],\n    ]\n  }\n\n  return {type: Tree.POLYGON, points}\n}\n","import * as Tree from '../tree'\nimport type {Tool} from '../tool-store'\nimport {SIMPLE_TOOL} from '../tool-store'\nimport type {Location, Point} from '../location-store'\nimport {TWO_PI} from '../coordinate-math'\n\nimport {plotRectPath} from './plot-rect-path'\n\nexport const CW = 'cw'\nexport const CCW = 'ccw'\n\nexport type ArcDirection = typeof CW | typeof CCW\n\nexport function plotSegment(\n  location: Location,\n  arcDirection?: ArcDirection,\n  ambiguousArcCenter?: boolean\n): Tree.PathSegment {\n  return arcDirection === undefined\n    ? createLineSegment(location)\n    : createArcSegment(location, arcDirection, ambiguousArcCenter)\n}\n\nexport function plotPath(\n  segments: Tree.PathSegment[],\n  tool: Tool | undefined,\n  region = false\n): Tree.ImageGraphic | undefined {\n  if (segments.length > 0) {\n    if (region) {\n      return {type: Tree.IMAGE_REGION, segments}\n    }\n\n    if (tool?.type === SIMPLE_TOOL && tool.shape.type === Tree.CIRCLE) {\n      return {type: Tree.IMAGE_PATH, width: tool.shape.diameter, segments}\n    }\n\n    if (tool?.type === SIMPLE_TOOL && tool.shape.type === Tree.RECTANGLE) {\n      return plotRectPath(segments, tool.shape)\n    }\n  }\n}\n\nfunction createLineSegment(location: Location): Tree.PathLineSegment {\n  return {\n    type: Tree.LINE,\n    start: [location.startPoint.x, location.startPoint.y],\n    end: [location.endPoint.x, location.endPoint.y],\n  }\n}\n\nfunction createArcSegment(\n  location: Location,\n  arcDirection: ArcDirection,\n  ambiguousArcCenter = false\n): Tree.PathSegment {\n  const {startPoint, endPoint, arcOffsets} = location\n  const radius =\n    arcOffsets.a > 0\n      ? arcOffsets.a\n      : (arcOffsets.i ** 2 + arcOffsets.j ** 2) ** 0.5\n\n  if (ambiguousArcCenter || arcOffsets.a > 0) {\n    if (startPoint.x === endPoint.x && startPoint.y === endPoint.y) {\n      return createLineSegment(location)\n    }\n\n    // Get the center candidates and select the candidate with the smallest arc\n    const [start, end, center] = findCenterCandidates(location, radius)\n      .map(centerPoint => {\n        return getArcPositions(startPoint, endPoint, centerPoint, arcDirection)\n      })\n      .sort(([startA, endA], [startB, endB]) => {\n        const absSweepA = Math.abs(endA[2] - startA[2])\n        const absSweepB = Math.abs(endB[2] - startB[2])\n        return absSweepA - absSweepB\n      })[0]\n\n    return {type: Tree.ARC, start, end, center, radius}\n  }\n\n  const centerPoint = {\n    x: startPoint.x + arcOffsets.i,\n    y: startPoint.y + arcOffsets.j,\n  }\n\n  const [start, end, center] = getArcPositions(\n    startPoint,\n    endPoint,\n    centerPoint,\n    arcDirection\n  )\n\n  return {type: Tree.ARC, start, end, center, radius}\n}\n\nexport function getArcPositions(\n  startPoint: Point,\n  endPoint: Point,\n  centerPoint: Point,\n  arcDirection: ArcDirection\n): [start: Tree.ArcPosition, end: Tree.ArcPosition, center: Tree.Position] {\n  let startAngle = Math.atan2(\n    startPoint.y - centerPoint.y,\n    startPoint.x - centerPoint.x\n  )\n  let endAngle = Math.atan2(\n    endPoint.y - centerPoint.y,\n    endPoint.x - centerPoint.x\n  )\n\n  // If counter-clockwise, end angle should be greater than start angle\n  if (arcDirection === CCW) {\n    endAngle = endAngle > startAngle ? endAngle : endAngle + TWO_PI\n  } else {\n    startAngle = startAngle > endAngle ? startAngle : startAngle + TWO_PI\n  }\n\n  return [\n    [startPoint.x, startPoint.y, startAngle],\n    [endPoint.x, endPoint.y, endAngle],\n    [centerPoint.x, centerPoint.y],\n  ]\n}\n\n// Find arc center candidates by finding the intersection points\n// of two circles with `radius` centered on the start and end points\n// https://math.stackexchange.com/a/1367732\nfunction findCenterCandidates(location: Location, radius: number): Point[] {\n  // This function assumes that start and end are different points\n  const {x: x1, y: y1} = location.startPoint\n  const {x: x2, y: y2} = location.endPoint\n\n  // Distance between the start and end points\n  const [dx, dy] = [x2 - x1, y2 - y1]\n  const [sx, sy] = [x2 + x1, y2 + y1]\n  const distance = Math.sqrt(dx ** 2 + dy ** 2)\n\n  // If the distance to the midpoint equals the arc radius, then there is\n  // exactly one intersection at the midpoint; if the distance to the midpoint\n  // is greater than the radius, assume we've got a rounding error and just use\n  // the midpoint\n  if (radius <= distance / 2) {\n    return [{x: x1 + dx / 2, y: y1 + dy / 2}]\n  }\n\n  // No good name for these variables, but it's how the math works out\n  const factor = Math.sqrt((4 * radius ** 2) / distance ** 2 - 1)\n  const [xBase, yBase] = [sx / 2, sy / 2]\n  const [xAddend, yAddend] = [(dy * factor) / 2, (dx * factor) / 2]\n\n  return [\n    {x: xBase + xAddend, y: yBase - yAddend},\n    {x: xBase - xAddend, y: yBase + yAddend},\n  ]\n}\n","// Plot a tool macro as shapes\nimport type {MacroPrimitiveCode, MacroValue} from '@tracespace/parser'\nimport {\n  MACRO_VARIABLE,\n  MACRO_PRIMITIVE,\n  MACRO_CIRCLE,\n  MACRO_VECTOR_LINE_DEPRECATED,\n  MACRO_VECTOR_LINE,\n  MACRO_CENTER_LINE,\n  MACRO_LOWER_LEFT_LINE_DEPRECATED,\n  MACRO_OUTLINE,\n  MACRO_POLYGON,\n  MACRO_MOIRE_DEPRECATED,\n  MACRO_THERMAL,\n} from '@tracespace/parser'\n\nimport {PI, rotateAndShift, positionsEqual} from '../coordinate-math'\n\nimport * as Tree from '../tree'\nimport type {MacroTool} from '../tool-store'\nimport type {Location} from '../location-store'\n\nimport {shapeToSegments} from './shapes'\nimport {CW, CCW, getArcPositions} from './plot-path'\n\ntype VariableValues = Record<string, number>\n\nexport function plotMacro(\n  tool: MacroTool,\n  location: Location\n): Tree.LayeredShape {\n  const shapes: Tree.ErasableShape[] = []\n  const variableValues: VariableValues = Object.fromEntries(\n    tool.variableValues.map((value, i) => [`$${i + 1}`, value])\n  )\n\n  for (const block of tool.macro) {\n    if (block.type === MACRO_VARIABLE) {\n      variableValues[block.name] = solveExpression(block.value, variableValues)\n    }\n\n    if (block.type === MACRO_PRIMITIVE) {\n      const origin: Tree.Position = [location.endPoint.x, location.endPoint.y]\n      const parameters = block.parameters.map(p => {\n        return solveExpression(p, variableValues)\n      })\n\n      shapes.push(...plotPrimitive(block.code, origin, parameters))\n    }\n  }\n\n  return {type: Tree.LAYERED_SHAPE, shapes}\n}\n\nfunction solveExpression(\n  expression: MacroValue,\n  variables: VariableValues\n): number {\n  if (typeof expression === 'number') return expression\n  if (typeof expression === 'string') return variables[expression]\n\n  const left = solveExpression(expression.left, variables)\n  const right = solveExpression(expression.right, variables)\n\n  switch (expression.operator) {\n    case '+': {\n      return left + right\n    }\n\n    case '-': {\n      return left - right\n    }\n\n    case 'x': {\n      return left * right\n    }\n\n    case '/': {\n      return left / right\n    }\n  }\n}\n\nfunction plotPrimitive(\n  code: MacroPrimitiveCode,\n  origin: Tree.Position,\n  parameters: number[]\n): Tree.ErasableShape[] {\n  switch (code) {\n    case MACRO_CIRCLE: {\n      return [plotCircle(origin, parameters)]\n    }\n\n    case MACRO_VECTOR_LINE:\n    case MACRO_VECTOR_LINE_DEPRECATED: {\n      return [plotVectorLine(origin, parameters)]\n    }\n\n    case MACRO_CENTER_LINE: {\n      return [plotCenterLine(origin, parameters)]\n    }\n\n    case MACRO_LOWER_LEFT_LINE_DEPRECATED: {\n      return [plotLowerLeftLine(origin, parameters)]\n    }\n\n    case MACRO_OUTLINE: {\n      return [plotOutline(origin, parameters)]\n    }\n\n    case MACRO_POLYGON: {\n      return [plotPolygon(origin, parameters)]\n    }\n\n    case MACRO_MOIRE_DEPRECATED: {\n      return plotMoire(origin, parameters)\n    }\n\n    case MACRO_THERMAL: {\n      return [plotThermal(origin, parameters)]\n    }\n  }\n\n  return []\n}\n\nfunction plotCircle(\n  origin: Tree.Position,\n  parameters: number[]\n): Tree.ErasableShape {\n  const [exposure, diameter, cx0, cy0, degrees] = parameters\n  const r = diameter / 2\n  const [cx, cy] = rotateAndShift([cx0, cy0], origin, degrees)\n\n  return {type: Tree.CIRCLE, erase: exposure === 0, cx, cy, r}\n}\n\nfunction plotVectorLine(\n  origin: Tree.Position,\n  parameters: number[]\n): Tree.ErasableShape {\n  const [exposure, width, sx, sy, ex, ey, degrees] = parameters\n  const [dy, dx] = [ey - sy, ex - sx]\n  const halfWid = width / 2\n  const dist = Math.sqrt(dy ** 2 + dx ** 2)\n  const [xOff, yOff] = [(halfWid * dx) / dist, (halfWid * dy) / dist]\n\n  return {\n    type: Tree.POLYGON,\n    erase: exposure === 0,\n    points: (\n      [\n        [sx + xOff, sy - yOff],\n        [ex + xOff, ey - yOff],\n        [ex - xOff, ey + yOff],\n        [sx - xOff, sy + yOff],\n      ] as Tree.Position[]\n    ).map(p => rotateAndShift(p, origin, degrees)),\n  }\n}\n\nfunction plotCenterLine(\n  origin: Tree.Position,\n  parameters: number[]\n): Tree.ErasableShape {\n  const [exposure, width, height, cx, cy, degrees] = parameters\n  const [halfWidth, halfHeight] = [width / 2, height / 2]\n\n  return {\n    type: Tree.POLYGON,\n    erase: exposure === 0,\n    points: (\n      [\n        [cx - halfWidth, cy - halfHeight],\n        [cx + halfWidth, cy - halfHeight],\n        [cx + halfWidth, cy + halfHeight],\n        [cx - halfWidth, cy + halfHeight],\n      ] as Tree.Position[]\n    ).map(p => rotateAndShift(p, origin, degrees)),\n  }\n}\n\nfunction plotLowerLeftLine(\n  origin: Tree.Position,\n  parameters: number[]\n): Tree.ErasableShape {\n  const [exposure, width, height, x, y, degrees] = parameters\n\n  return {\n    type: Tree.POLYGON,\n    erase: exposure === 0,\n    points: (\n      [\n        [x, y],\n        [x + width, y],\n        [x + width, y + height],\n        [x, y + height],\n      ] as Tree.Position[]\n    ).map(p => rotateAndShift(p, origin, degrees)),\n  }\n}\n\nfunction plotOutline(\n  origin: Tree.Position,\n  parameters: number[]\n): Tree.ErasableShape {\n  const [exposure, , ...coords] = parameters.slice(0, -1)\n  const degrees = parameters[parameters.length - 1]\n\n  return {\n    type: Tree.POLYGON,\n    erase: exposure === 0,\n    points: coords\n      .flatMap<[number, number]>((coordinate, i) =>\n        i % 2 === 1 ? [[coords[i - 1], coordinate]] : []\n      )\n      .map(p => rotateAndShift(p, origin, degrees)),\n  }\n}\n\nfunction plotPolygon(\n  origin: Tree.Position,\n  parameters: number[]\n): Tree.ErasableShape {\n  const [exposure, vertices, cx, cy, diameter, degrees] = parameters\n  const r = diameter / 2\n  const step = (2 * PI) / vertices\n  const points: Tree.Position[] = []\n  let i\n\n  for (i = 0; i < vertices; i++) {\n    const theta = step * i\n    const pointX = cx + r * Math.cos(theta)\n    const pointY = cy + r * Math.sin(theta)\n    points.push(rotateAndShift([pointX, pointY], origin, degrees))\n  }\n\n  return {type: Tree.POLYGON, erase: exposure === 0, points}\n}\n\nfunction plotMoire(\n  origin: Tree.Position,\n  parameters: number[]\n): Tree.ErasableShape[] {\n  const rotate = (p: Tree.Position): Tree.Position =>\n    rotateAndShift(p, origin, parameters[8])\n\n  const [cx0, cy0, d, ringThx, ringGap, ringN, lineThx, lineLength] = parameters\n  const [cx, cy] = rotate([cx0, cy0])\n  const halfLineThx = lineThx / 2\n  const halfLineLength = lineLength / 2\n\n  const radii = []\n  let count = 0\n  let dRemain = d\n\n  while (dRemain >= 0 && count < ringN) {\n    const r = dRemain / 2\n    const rHole = r - ringThx\n\n    radii.push(r)\n    if (rHole > 0) radii.push(rHole)\n    count += 1\n    dRemain = 2 * (rHole - ringGap)\n  }\n\n  return [\n    {\n      type: Tree.OUTLINE,\n      segments: radii.flatMap(r => {\n        return shapeToSegments({type: Tree.CIRCLE, cx, cy, r})\n      }),\n    },\n    // Vertical stroke\n    {\n      type: Tree.POLYGON,\n      points: (\n        [\n          [cx0 - halfLineThx, cy0 - halfLineLength],\n          [cx0 + halfLineThx, cy0 - halfLineLength],\n          [cx0 + halfLineThx, cy0 + halfLineLength],\n          [cx0 - halfLineThx, cy0 + halfLineLength],\n        ] as Tree.Position[]\n      ).map(rotate),\n    },\n    // Horizontal stroke\n    {\n      type: Tree.POLYGON,\n      points: (\n        [\n          [cx0 - halfLineLength, cy0 - halfLineThx],\n          [cx0 + halfLineLength, cy0 - halfLineThx],\n          [cx0 + halfLineLength, cy0 + halfLineThx],\n          [cx0 - halfLineLength, cy0 + halfLineThx],\n        ] as Tree.Position[]\n      ).map(rotate),\n    },\n  ]\n}\n\nfunction plotThermal(\n  origin: Tree.Position,\n  parameters: number[]\n): Tree.ErasableShape {\n  const [cx0, cy0, od, id, gap, degrees] = parameters\n  const center = rotateAndShift([cx0, cy0], origin, degrees)\n  const [or, ir] = [od / 2, id / 2]\n  const halfGap = gap / 2\n  const oIntSquare = or ** 2 - halfGap ** 2\n  const iIntSquare = ir ** 2 - halfGap ** 2\n  const oInt = Math.sqrt(oIntSquare)\n  const iInt = iIntSquare >= 0 ? Math.sqrt(iIntSquare) : halfGap\n  const positions = [0, 90, 180, 270]\n  const segments: Tree.PathSegment[] = []\n\n  for (const rot of positions) {\n    const points = (\n      [\n        [iInt, halfGap],\n        [oInt, halfGap],\n        [halfGap, oInt],\n        [halfGap, iInt],\n      ] as Tree.Position[]\n    )\n      .map(p => rotateAndShift(p, [cx0, cy0], rot))\n      .map(p => rotateAndShift(p, origin, degrees))\n\n    const [os, oe, oc] = getArcPositions(\n      {x: points[1][0], y: points[1][1]},\n      {x: points[2][0], y: points[2][1]},\n      {x: center[0], y: center[1]},\n      CCW\n    )\n\n    segments.push(\n      {type: Tree.LINE, start: points[0], end: points[1]},\n      {type: Tree.ARC, start: os, end: oe, center: oc, radius: or},\n      {type: Tree.LINE, start: points[2], end: points[3]}\n    )\n\n    if (!positionsEqual(points[0], points[3])) {\n      const [is, ie, ic] = getArcPositions(\n        {x: points[3][0], y: points[3][1]},\n        {x: points[0][0], y: points[0][1]},\n        {x: center[0], y: center[1]},\n        CW\n      )\n      segments.push({\n        type: Tree.ARC,\n        start: is,\n        end: ie,\n        center: ic,\n        radius: ir,\n      })\n    }\n  }\n\n  return {type: Tree.OUTLINE, segments}\n}\n","// Graphic plotter\n// Takes nodes and turns them into graphics to be added to the image\nimport type {\n  GerberNode,\n  GraphicType,\n  Filetype,\n  InterpolateModeType,\n} from '@tracespace/parser'\nimport {\n  GRAPHIC,\n  SHAPE,\n  SEGMENT,\n  MOVE,\n  SLOT,\n  DONE,\n  LINE,\n  CCW_ARC,\n  CW_ARC,\n  DRILL,\n  SINGLE,\n  INTERPOLATE_MODE,\n  QUADRANT_MODE,\n  REGION_MODE,\n} from '@tracespace/parser'\n\nimport * as Tree from '../tree'\nimport type {Tool} from '../tool-store'\nimport {SIMPLE_TOOL, MACRO_TOOL} from '../tool-store'\nimport type {Location} from '../location-store'\n\nimport {plotShape} from './plot-shape'\nimport {plotMacro} from './plot-macro'\nimport type {ArcDirection} from './plot-path'\nimport {CCW, CW, plotSegment, plotPath} from './plot-path'\n\nexport interface GraphicPlotter {\n  plot(\n    node: GerberNode,\n    tool: Tool | undefined,\n    location: Location\n  ): Tree.ImageGraphic[]\n}\n\nexport function createGraphicPlotter(filetype: Filetype): GraphicPlotter {\n  const plotter = Object.create(GraphicPlotterPrototype)\n\n  return filetype === DRILL\n    ? Object.assign(plotter, DrillGraphicPlotterTrait)\n    : plotter\n}\n\ninterface GraphicPlotterImpl extends GraphicPlotter {\n  _currentPath: CurrentPath | undefined\n  _arcDirection: ArcDirection | undefined\n  _ambiguousArcCenter: boolean\n  _regionMode: boolean\n  _defaultGraphic: NonNullable<GraphicType> | undefined\n\n  _setGraphicState(node: GerberNode): NonNullable<GraphicType> | undefined\n\n  _plotCurrentPath(\n    node: GerberNode,\n    nextTool: Tool | undefined,\n    nextGraphicType: NonNullable<GraphicType> | undefined\n  ): Tree.ImageGraphic | undefined\n}\n\ninterface CurrentPath {\n  segments: Tree.PathSegment[]\n  tool: Tool | undefined\n  region: boolean\n}\n\nconst GraphicPlotterPrototype: GraphicPlotterImpl = {\n  _currentPath: undefined,\n  _arcDirection: undefined,\n  _ambiguousArcCenter: false,\n  _regionMode: false,\n  _defaultGraphic: undefined,\n\n  plot(\n    node: GerberNode,\n    tool: Tool | undefined,\n    location: Location\n  ): Tree.ImageGraphic[] {\n    const graphics: Tree.ImageGraphic[] = []\n    const nextGraphicType = this._setGraphicState(node)\n    const pathGraphic = this._plotCurrentPath(node, tool, nextGraphicType)\n\n    if (pathGraphic) {\n      graphics.push(pathGraphic)\n    }\n\n    if (nextGraphicType === SHAPE && tool?.type === SIMPLE_TOOL) {\n      graphics.push({type: Tree.IMAGE_SHAPE, shape: plotShape(tool, location)})\n    }\n\n    if (nextGraphicType === SHAPE && tool?.type === MACRO_TOOL) {\n      graphics.push({type: Tree.IMAGE_SHAPE, shape: plotMacro(tool, location)})\n    }\n\n    if (nextGraphicType === SEGMENT) {\n      this._currentPath = this._currentPath ?? {\n        segments: [],\n        region: this._regionMode,\n        tool,\n      }\n\n      this._currentPath.segments.push(\n        plotSegment(location, this._arcDirection, this._ambiguousArcCenter)\n      )\n    }\n\n    if (nextGraphicType === SLOT) {\n      const pathGraphic = plotPath([plotSegment(location)], tool)\n\n      if (pathGraphic) {\n        graphics.push(pathGraphic)\n      }\n    }\n\n    return graphics\n  },\n\n  _setGraphicState(node: GerberNode): NonNullable<GraphicType> | undefined {\n    if (node.type === INTERPOLATE_MODE) {\n      this._arcDirection = arcDirectionFromMode(node.mode)\n    }\n\n    if (node.type === QUADRANT_MODE) {\n      this._ambiguousArcCenter = node.quadrant === SINGLE\n    }\n\n    if (node.type === REGION_MODE) {\n      this._regionMode = node.region\n    }\n\n    if (node.type !== GRAPHIC) {\n      return undefined\n    }\n\n    if (node.graphic === SEGMENT) {\n      this._defaultGraphic = SEGMENT\n    } else if (node.graphic !== null) {\n      this._defaultGraphic = undefined\n    }\n\n    return node.graphic ?? this._defaultGraphic\n  },\n\n  _plotCurrentPath(\n    node: GerberNode,\n    nextTool: Tool | undefined,\n    nextGraphicType: NonNullable<GraphicType> | undefined\n  ): Tree.ImageGraphic | undefined {\n    if (this._currentPath === undefined) {\n      return undefined\n    }\n\n    if (\n      nextTool !== this._currentPath.tool ||\n      node.type === REGION_MODE ||\n      node.type === DONE ||\n      (nextGraphicType === MOVE && this._currentPath.region) ||\n      (nextGraphicType === SHAPE && this._currentPath !== undefined)\n    ) {\n      const pathGraphic = plotPath(\n        this._currentPath.segments,\n        this._currentPath.tool,\n        this._currentPath.region\n      )\n\n      this._currentPath = undefined\n      return pathGraphic\n    }\n  },\n}\n\nconst DrillGraphicPlotterTrait: Partial<GraphicPlotterImpl> = {\n  _defaultGraphic: SHAPE,\n  _ambiguousArcCenter: true,\n\n  _setGraphicState(node: GerberNode): NonNullable<GraphicType> | undefined {\n    if (node.type === INTERPOLATE_MODE) {\n      const {mode} = node\n      this._arcDirection = arcDirectionFromMode(mode)\n\n      if (mode === CW_ARC || mode === CCW_ARC || mode === LINE) {\n        this._defaultGraphic = SEGMENT\n      } else if (mode === MOVE) {\n        this._defaultGraphic = MOVE\n      } else {\n        this._defaultGraphic = SHAPE\n      }\n    }\n\n    if (node.type !== GRAPHIC) {\n      return undefined\n    }\n\n    return node.graphic ?? this._defaultGraphic\n  },\n}\n\nfunction arcDirectionFromMode(\n  mode: InterpolateModeType\n): ArcDirection | undefined {\n  if (mode === CCW_ARC) return CCW\n  if (mode === CW_ARC) return CW\n  return undefined\n}\n","// @tracespace/plotter\n// build abstract board images from @tracespace/parser ASTs\nimport type {GerberTree} from '@tracespace/parser'\n\nimport {fromGraphics as sizeFromGraphics} from './bounding-box'\nimport {getPlotOptions} from './options'\nimport {createToolStore} from './tool-store'\nimport {createLocationStore} from './location-store'\nimport {createGraphicPlotter} from './graphic-plotter'\nimport {IMAGE} from './tree'\nimport type {ImageTree} from './tree'\n\nexport * from './tree'\nexport * as BoundingBox from './bounding-box'\nexport {TWO_PI, positionsEqual} from './coordinate-math'\n\nexport function plot(tree: GerberTree): ImageTree {\n  const plotOptions = getPlotOptions(tree)\n  const toolStore = createToolStore()\n  const locationStore = createLocationStore()\n  const graphicPlotter = createGraphicPlotter(tree.filetype)\n  const children = []\n\n  for (const node of tree.children) {\n    const tool = toolStore.use(node)\n    const location = locationStore.use(node, plotOptions)\n    const graphics = graphicPlotter.plot(node, tool, location)\n\n    children.push(...graphics)\n  }\n\n  return {\n    type: IMAGE,\n    units: plotOptions.units,\n    size: sizeFromGraphics(children),\n    children,\n  }\n}\n"],"names":["IMAGE","IMAGE_SHAPE","IMAGE_PATH","IMAGE_REGION","LINE","ARC","CIRCLE","RECTANGLE","POLYGON","OUTLINE","LAYERED_SHAPE","PI","HALF_PI","THREE_HALF_PI","TWO_PI","limitAngle","theta","rotateQuadrant","degreesToRadians","degrees","rotateAndShift","point","shift","rotation","sin","cos","x","y","nextX","nextY","positionsEqual","a","b","isEmpty","box","empty","add","sum","boxes","fromGraphics","graphics","fromGraphic","graphic","Tree.IMAGE_SHAPE","fromShape","fromPath","Tree.IMAGE_PATH","shape","Tree.CIRCLE","cx","cy","fromPosition","Tree.RECTANGLE","xSize","ySize","Tree.POLYGON","p","Tree.OUTLINE","Tree.LAYERED_SHAPE","erase","segments","width","rTool","keyPoints","segment","Tree.ARC","start","end","center","radius","sweep","thetaStart","thetaEnd","axisPoints","position","FORMAT_COMMENT_RE","getPlotOptions","tree","treeNodes","units","coordinateFormat","zeroSuppression","index","node","UNITS","COORDINATE_FORMAT","GRAPHIC","coordinates","coordinate","LEADING","TRAILING","COMMENT","comment","formatMatch","IN","SIMPLE_TOOL","MACRO_TOOL","createToolStore","ToolStorePrototype","TOOL_MACRO","TOOL_DEFINITION","hole","tool","MACRO_SHAPE","TOOL_CHANGE","createLocationStore","LocationStorePrototype","options","arcOffsets","startPoint","endPoint","x0","parseCoordinate","y0","i","j","defaultValue","integerPlaces","decimalPlaces","sign","signlessCoordinate","digits","paddedCoordinate","leading","trailing","createShape","diameter","OBROUND","xHalf","yHalf","rectangle","vertices","r","offset","step","points","_","pointX","pointY","shapeToSegments","Tree.LINE","endIndex","plotShape","location","toolShape","toolHole","holeShape","plotRectPath","shapes","s","plotRectPathSegment","sx","sy","ex","ey","xOffset","yOffset","sxMin","sxMax","syMin","syMax","exMin","exMax","eyMin","eyMax","CW","CCW","plotSegment","arcDirection","ambiguousArcCenter","createLineSegment","createArcSegment","plotPath","region","Tree.IMAGE_REGION","findCenterCandidates","centerPoint","getArcPositions","startA","endA","startB","endB","absSweepA","absSweepB","startAngle","endAngle","x1","y1","x2","y2","dx","dy","distance","factor","xBase","yBase","xAddend","yAddend","plotMacro","variableValues","value","block","MACRO_VARIABLE","solveExpression","MACRO_PRIMITIVE","origin","parameters","plotPrimitive","expression","variables","left","right","code","MACRO_CIRCLE","plotCircle","MACRO_VECTOR_LINE","MACRO_VECTOR_LINE_DEPRECATED","plotVectorLine","MACRO_CENTER_LINE","plotCenterLine","MACRO_LOWER_LEFT_LINE_DEPRECATED","plotLowerLeftLine","MACRO_OUTLINE","plotOutline","MACRO_POLYGON","plotPolygon","MACRO_MOIRE_DEPRECATED","plotMoire","MACRO_THERMAL","plotThermal","exposure","cx0","cy0","halfWid","dist","xOff","yOff","height","halfWidth","halfHeight","coords","rotate","d","ringThx","ringGap","ringN","lineThx","lineLength","halfLineThx","halfLineLength","radii","count","dRemain","rHole","od","id","gap","or","ir","halfGap","oIntSquare","iIntSquare","oInt","iInt","positions","rot","os","oe","oc","is","ie","ic","createGraphicPlotter","filetype","plotter","GraphicPlotterPrototype","DRILL","DrillGraphicPlotterTrait","nextGraphicType","pathGraphic","SHAPE","SEGMENT","SLOT","INTERPOLATE_MODE","arcDirectionFromMode","QUADRANT_MODE","SINGLE","REGION_MODE","nextTool","DONE","MOVE","mode","CW_ARC","CCW_ARC","plot","plotOptions","toolStore","locationStore","graphicPlotter","children","sizeFromGraphics"],"mappings":"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"}