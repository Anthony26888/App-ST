import * as Ue from "@tracespace/parser";
import { GERBER as _e, DRILL as ze } from "@tracespace/parser";
import * as qe from "@tracespace/plotter";
import { LINE as je, IMAGE_REGION as ce, IMAGE_PATH as pe, BoundingBox as Z } from "@tracespace/plotter";
import * as M from "@tracespace/renderer";
import { sizeToViewBox as He, renderGraphic as $e } from "@tracespace/renderer";
import { random as de } from "@tracespace/xml-id";
import { identifyLayers as Ge, TYPE_DRILL as ge, SIDE_ALL as Ye, TYPE_OUTLINE as Ve, TYPE_COPPER as We, TYPE_SOLDERMASK as Ke, TYPE_SILKSCREEN as Xe, TYPE_SOLDERPASTE as Ze, SIDE_TOP as me, SIDE_BOTTOM as U } from "@tracespace/identify-layers";
class A {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(t, l, e) {
    this.property = t, this.normal = l, e && (this.space = e);
  }
}
A.prototype.property = {};
A.prototype.normal = {};
A.prototype.space = null;
function fe(n, t) {
  const l = {}, e = {};
  let o = -1;
  for (; ++o < n.length; )
    Object.assign(l, n[o].property), Object.assign(e, n[o].normal);
  return new A(l, e, t);
}
function E(n) {
  return n.toLowerCase();
}
class b {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(t, l) {
    this.property = t, this.attribute = l;
  }
}
b.prototype.space = null;
b.prototype.boolean = !1;
b.prototype.booleanish = !1;
b.prototype.overloadedBoolean = !1;
b.prototype.number = !1;
b.prototype.commaSeparated = !1;
b.prototype.spaceSeparated = !1;
b.prototype.commaOrSpaceSeparated = !1;
b.prototype.mustUseProperty = !1;
b.prototype.defined = !1;
let Je = 0;
const p = w(), m = w(), he = w(), i = w(), g = w(), P = w(), y = w();
function w() {
  return 2 ** ++Je;
}
const _ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: p,
  booleanish: m,
  commaOrSpaceSeparated: y,
  commaSeparated: P,
  number: i,
  overloadedBoolean: he,
  spaceSeparated: g
}, Symbol.toStringTag, { value: "Module" })), I = Object.keys(_);
class $ extends b {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(t, l, e, o) {
    let a = -1;
    if (super(t, l), J(this, "space", o), typeof e == "number")
      for (; ++a < I.length; ) {
        const r = I[a];
        J(this, I[a], (e & _[r]) === _[r]);
      }
  }
}
$.prototype.defined = !0;
function J(n, t, l) {
  l && (n[t] = l);
}
const Qe = {}.hasOwnProperty;
function O(n) {
  const t = {}, l = {};
  let e;
  for (e in n.properties)
    if (Qe.call(n.properties, e)) {
      const o = n.properties[e], a = new $(
        e,
        n.transform(n.attributes || {}, e),
        o,
        n.space
      );
      n.mustUseProperty && n.mustUseProperty.includes(e) && (a.mustUseProperty = !0), t[e] = a, l[E(e)] = e, l[E(a.attribute)] = e;
    }
  return new A(t, l, n.space);
}
const ye = O({
  space: "xlink",
  transform(n, t) {
    return "xlink:" + t.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
}), be = O({
  space: "xml",
  transform(n, t) {
    return "xml:" + t.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});
function Se(n, t) {
  return t in n ? n[t] : t;
}
function ve(n, t) {
  return Se(n, t.toLowerCase());
}
const xe = O({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: ve,
  properties: { xmlns: null, xmlnsXLink: null }
}), we = O({
  transform(n, t) {
    return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: m,
    ariaAutoComplete: null,
    ariaBusy: m,
    ariaChecked: m,
    ariaColCount: i,
    ariaColIndex: i,
    ariaColSpan: i,
    ariaControls: g,
    ariaCurrent: null,
    ariaDescribedBy: g,
    ariaDetails: null,
    ariaDisabled: m,
    ariaDropEffect: g,
    ariaErrorMessage: null,
    ariaExpanded: m,
    ariaFlowTo: g,
    ariaGrabbed: m,
    ariaHasPopup: null,
    ariaHidden: m,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: g,
    ariaLevel: i,
    ariaLive: null,
    ariaModal: m,
    ariaMultiLine: m,
    ariaMultiSelectable: m,
    ariaOrientation: null,
    ariaOwns: g,
    ariaPlaceholder: null,
    ariaPosInSet: i,
    ariaPressed: m,
    ariaReadOnly: m,
    ariaRelevant: null,
    ariaRequired: m,
    ariaRoleDescription: g,
    ariaRowCount: i,
    ariaRowIndex: i,
    ariaRowSpan: i,
    ariaSelected: m,
    ariaSetSize: i,
    ariaSort: null,
    ariaValueMax: i,
    ariaValueMin: i,
    ariaValueNow: i,
    ariaValueText: null,
    role: null
  }
}), en = O({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: ve,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: P,
    acceptCharset: g,
    accessKey: g,
    action: null,
    allow: null,
    allowFullScreen: p,
    allowPaymentRequest: p,
    allowUserMedia: p,
    alt: null,
    as: null,
    async: p,
    autoCapitalize: null,
    autoComplete: g,
    autoFocus: p,
    autoPlay: p,
    capture: p,
    charSet: null,
    checked: p,
    cite: null,
    className: g,
    cols: i,
    colSpan: null,
    content: null,
    contentEditable: m,
    controls: p,
    controlsList: g,
    coords: i | P,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: p,
    defer: p,
    dir: null,
    dirName: null,
    disabled: p,
    download: he,
    draggable: m,
    encType: null,
    enterKeyHint: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: p,
    formTarget: null,
    headers: g,
    height: i,
    hidden: p,
    high: i,
    href: null,
    hrefLang: null,
    htmlFor: g,
    httpEquiv: g,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: p,
    itemId: null,
    itemProp: g,
    itemRef: g,
    itemScope: p,
    itemType: g,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: p,
    low: i,
    manifest: null,
    max: null,
    maxLength: i,
    media: null,
    method: null,
    min: null,
    minLength: i,
    multiple: p,
    muted: p,
    name: null,
    nonce: null,
    noModule: p,
    noValidate: p,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: p,
    optimum: i,
    pattern: null,
    ping: g,
    placeholder: null,
    playsInline: p,
    poster: null,
    preload: null,
    readOnly: p,
    referrerPolicy: null,
    rel: g,
    required: p,
    reversed: p,
    rows: i,
    rowSpan: i,
    sandbox: g,
    scope: null,
    scoped: p,
    seamless: p,
    selected: p,
    shape: null,
    size: i,
    sizes: null,
    slot: null,
    span: i,
    spellCheck: m,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: i,
    step: null,
    style: null,
    tabIndex: i,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: p,
    useMap: null,
    value: m,
    width: i,
    wrap: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: g,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: i,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: i,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: p,
    // Lists. Use CSS to reduce space between items instead
    declare: p,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: i,
    // `<img>` and `<object>`
    leftMargin: i,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: i,
    // `<body>`
    marginWidth: i,
    // `<body>`
    noResize: p,
    // `<frame>`
    noHref: p,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: p,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: p,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: i,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: m,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: i,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: i,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: p,
    disableRemotePlayback: p,
    prefix: null,
    property: null,
    results: i,
    security: null,
    unselectable: null
  }
}), nn = O({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: Se,
  properties: {
    about: y,
    accentHeight: i,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: i,
    amplitude: i,
    arabicForm: null,
    ascent: i,
    attributeName: null,
    attributeType: null,
    azimuth: i,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: i,
    by: null,
    calcMode: null,
    capHeight: i,
    className: g,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: i,
    diffuseConstant: i,
    direction: null,
    display: null,
    dur: null,
    divisor: i,
    dominantBaseline: null,
    download: p,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: i,
    enableBackground: null,
    end: null,
    event: null,
    exponent: i,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: i,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: P,
    g2: P,
    glyphName: P,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: i,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: i,
    horizOriginX: i,
    horizOriginY: i,
    id: null,
    ideographic: i,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: i,
    k: i,
    k1: i,
    k2: i,
    k3: i,
    k4: i,
    kernelMatrix: y,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: i,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: i,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: i,
    overlineThickness: i,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: i,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: g,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: i,
    pointsAtY: i,
    pointsAtZ: i,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: y,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: y,
    rev: y,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: y,
    requiredFeatures: y,
    requiredFonts: y,
    requiredFormats: y,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: i,
    specularExponent: i,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: i,
    strikethroughThickness: i,
    string: null,
    stroke: null,
    strokeDashArray: y,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: i,
    strokeOpacity: i,
    strokeWidth: null,
    style: null,
    surfaceScale: i,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: y,
    tabIndex: i,
    tableValues: null,
    target: null,
    targetX: i,
    targetY: i,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: y,
    to: null,
    transform: null,
    u1: null,
    u2: null,
    underlinePosition: i,
    underlineThickness: i,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: i,
    values: null,
    vAlphabetic: i,
    vMathematical: i,
    vectorEffect: null,
    vHanging: i,
    vIdeographic: i,
    version: null,
    vertAdvY: i,
    vertOriginX: i,
    vertOriginY: i,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: i,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
}), tn = /^data[-\w.:]+$/i, Q = /-[a-z]/g, ln = /[A-Z]/g;
function ke(n, t) {
  const l = E(t);
  let e = t, o = b;
  if (l in n.normal)
    return n.property[n.normal[l]];
  if (l.length > 4 && l.slice(0, 4) === "data" && tn.test(t)) {
    if (t.charAt(4) === "-") {
      const a = t.slice(5).replace(Q, rn);
      e = "data" + a.charAt(0).toUpperCase() + a.slice(1);
    } else {
      const a = t.slice(4);
      if (!Q.test(a)) {
        let r = a.replace(ln, on);
        r.charAt(0) !== "-" && (r = "-" + r), t = "data" + r;
      }
    }
    o = $;
  }
  return new o(e, t);
}
function on(n) {
  return "-" + n.toLowerCase();
}
function rn(n) {
  return n.charAt(1).toUpperCase();
}
const an = fe([be, ye, xe, we, en], "html"), G = fe([be, ye, xe, we, nn], "svg"), ee = /[#.]/g;
function sn(n, t) {
  const l = n || "", e = {};
  let o = 0, a, r;
  for (; o < l.length; ) {
    ee.lastIndex = o;
    const s = ee.exec(l), u = l.slice(o, s ? s.index : l.length);
    u && (a ? a === "#" ? e.id = u : Array.isArray(e.className) ? e.className.push(u) : e.className = [u] : r = u, o += u.length), s && (a = s[0], o++);
  }
  return {
    type: "element",
    // @ts-expect-error: fine.
    tagName: r || t || "div",
    properties: e,
    children: []
  };
}
function ne(n) {
  const t = String(n || "").trim();
  return t ? t.split(/[ \t\n\r\f]+/g) : [];
}
function un(n) {
  return n.join(" ").trim();
}
function te(n) {
  const t = [], l = String(n || "");
  let e = l.indexOf(","), o = 0, a = !1;
  for (; !a; ) {
    e === -1 && (e = l.length, a = !0);
    const r = l.slice(o, e).trim();
    (r || !a) && t.push(r), o = e + 1, e = l.indexOf(",", o);
  }
  return t;
}
function cn(n, t) {
  const l = t || {};
  return (n[n.length - 1] === "" ? [...n, ""] : n).join(
    (l.padRight ? " " : "") + "," + (l.padLeft === !1 ? "" : " ")
  ).trim();
}
const pn = /* @__PURE__ */ new Set(["menu", "submit", "reset", "button"]), z = {}.hasOwnProperty;
function dn(n, t, l) {
  const e = l && hn(l);
  return (
    /**
     * @type {{
     *   (): Root
     *   (selector: null | undefined, ...children: Array<HChild>): Root
     *   (selector: string, properties?: HProperties, ...children: Array<HChild>): Element
     *   (selector: string, ...children: Array<HChild>): Element
     * }}
     */
    /**
     * Hyperscript compatible DSL for creating virtual hast trees.
     *
     * @param {string | null} [selector]
     * @param {HProperties | HChild} [properties]
     * @param {Array<HChild>} children
     * @returns {HResult}
     */
    function(a, r, ...s) {
      let u = -1, c;
      if (a == null)
        c = { type: "root", children: [] }, s.unshift(r);
      else if (c = sn(a, t), c.tagName = c.tagName.toLowerCase(), e && z.call(e, c.tagName) && (c.tagName = e[c.tagName]), gn(r, c.tagName)) {
        let d;
        for (d in r)
          z.call(r, d) && mn(n, c.properties, d, r[d]);
      } else
        s.unshift(r);
      for (; ++u < s.length; )
        q(c.children, s[u]);
      return c.type === "element" && c.tagName === "template" && (c.content = { type: "root", children: c.children }, c.children = []), c;
    }
  );
}
function gn(n, t) {
  return n == null || typeof n != "object" || Array.isArray(n) ? !1 : t === "input" || !n.type || typeof n.type != "string" ? !0 : "children" in n && Array.isArray(n.children) ? !1 : t === "button" ? pn.has(n.type.toLowerCase()) : !("value" in n);
}
function mn(n, t, l, e) {
  const o = ke(n, l);
  let a = -1, r;
  if (e != null) {
    if (typeof e == "number") {
      if (Number.isNaN(e))
        return;
      r = e;
    } else
      typeof e == "boolean" ? r = e : typeof e == "string" ? o.spaceSeparated ? r = ne(e) : o.commaSeparated ? r = te(e) : o.commaOrSpaceSeparated ? r = ne(te(e).join(" ")) : r = le(o, o.property, e) : Array.isArray(e) ? r = e.concat() : r = o.property === "style" ? fn(e) : String(e);
    if (Array.isArray(r)) {
      const s = [];
      for (; ++a < r.length; )
        s[a] = le(o, o.property, r[a]);
      r = s;
    }
    o.property === "className" && Array.isArray(t.className) && (r = t.className.concat(r)), t[o.property] = r;
  }
}
function q(n, t) {
  let l = -1;
  if (t != null)
    if (typeof t == "string" || typeof t == "number")
      n.push({ type: "text", value: String(t) });
    else if (Array.isArray(t))
      for (; ++l < t.length; )
        q(n, t[l]);
    else if (typeof t == "object" && "type" in t)
      t.type === "root" ? q(n, t.children) : n.push(t);
    else
      throw new Error("Expected node, nodes, or string, got `" + t + "`");
}
function le(n, t, l) {
  if (typeof l == "string") {
    if (n.number && l && !Number.isNaN(Number(l)))
      return Number(l);
    if ((n.boolean || n.overloadedBoolean) && (l === "" || E(l) === E(t)))
      return !0;
  }
  return l;
}
function fn(n) {
  const t = [];
  let l;
  for (l in n)
    z.call(n, l) && t.push([l, n[l]].join(": "));
  return t.join("; ");
}
function hn(n) {
  const t = {};
  let l = -1;
  for (; ++l < n.length; )
    t[n[l].toLowerCase()] = n[l];
  return t;
}
const yn = [
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "solidColor",
  "textArea",
  "textPath"
], h = dn(G, "g", yn);
async function bn(n) {
  return typeof n == "string" ? vn(n) : Sn(n);
}
async function Sn(n) {
  if (typeof File > "u" || typeof FileReader > "u")
    throw new TypeError(
      `Cannot read "file" object of type ${typeof n} in a non-browser environment`
    );
  return new Promise((t, l) => {
    const e = new FileReader();
    e.addEventListener("load", o, { once: !0 }), e.addEventListener("error", a, { once: !0 }), e.readAsText(n);
    function o() {
      const r = e.result;
      e.removeEventListener("error", a), t({ filename: n.name, contents: r });
    }
    function a() {
      e.removeEventListener("load", o), l(e.error);
    }
  });
}
async function vn(n) {
  const [t, l] = await Promise.all([
    import("node:fs/promises"),
    import("node:path")
  ]).catch(() => {
    throw new TypeError(
      "Cannot read a file path string in a non-Node.js environment"
    );
  }), e = l.basename(n), o = await t.readFile(n, "utf8");
  return { filename: e, contents: o };
}
function xn(n) {
  const t = n.filter((e) => e.parseTree.filetype === _e).map((e) => e.filename), l = Ge(t);
  return Object.fromEntries(
    n.map(({ id: e, filename: o, parseTree: a }) => {
      const r = a.filetype === ze ? { type: ge, side: Ye } : l[o];
      return [e, r];
    })
  );
}
const k = ({ id: n }) => n, C = (n, t) => (l) => l.type === n && (t === void 0 || l.side === t);
function wn(n) {
  return n.filter(C(Ve)).map(k)[0];
}
function Ce(n) {
  return n.filter(C(ge)).map(k);
}
function j(n, t) {
  return {
    copper: t.filter(C(We, n)).map(k),
    solderMask: t.filter(C(Ke, n)).map(k),
    silkScreen: t.filter(C(Xe, n)).map(k),
    solderPaste: t.filter(C(Ze, n)).map(k)
  };
}
function kn(n) {
  const t = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ new Map();
  for (const o of n) {
    const a = Pn(o);
    t.set(a, o);
    for (const r of [o.start, o.end]) {
      const s = L(r), u = l.get(s) ?? [];
      u.push(a), l.set(s, u);
    }
  }
  return Object.assign(Object.create(Cn), {
    segmentsById: t,
    segmentIdsByPointId: l
  }).walk();
}
const Cn = {
  walk() {
    const n = [];
    for (; this.segmentsById.size > 0; ) {
      const t = this.segmentIdsByPointId.keys().next().value, l = this.walkPath(t);
      if (l.length > 0) {
        const e = l[0], o = l[l.length - 1], a = [e.start[0], e.start[1]], r = [o.end[0], o.end[1]];
        n.push({ start: a, end: r, segments: l });
      }
    }
    return n;
  },
  walkPath(n) {
    const t = this.shiftNextSegment(n);
    if (t !== void 0) {
      const l = L(t.start), e = L(t.end), o = n === l ? e : l;
      return [
        n === l ? t : Pe(t),
        ...this.walkPath(o)
      ];
    }
    return [];
  },
  shiftNextSegment(n) {
    const t = this.shiftSegmentId(n);
    if (t !== void 0)
      return this.consumeSegment(t) ?? this.shiftNextSegment(n);
  },
  shiftSegmentId(n) {
    const t = this.segmentIdsByPointId.get(n), l = t == null ? void 0 : t.shift();
    return (t == null ? void 0 : t.length) === 0 && this.segmentIdsByPointId.delete(n), l;
  },
  consumeSegment(n) {
    const t = this.segmentsById.get(n);
    return this.segmentsById.delete(n), t;
  }
};
function L(n) {
  return `${n[0]},${n[1]}`;
}
function Pn(n) {
  const { type: t } = n, [l, e] = Nn(n.start, n.end);
  return `${t}:${L(l)}:${L(e)}`;
}
function Nn(n, t) {
  return t[0] < n[0] ? [t, n] : t[0] > n[0] ? [n, t] : t[1] < n[1] ? [t, n] : [n, t];
}
function Pe(n) {
  return { ...n, start: n.end, end: n.start };
}
const On = (n) => ({
  type: ce,
  segments: n
}), En = (n) => ({
  type: pe,
  width: 0,
  segments: n
});
function Ln(n, t) {
  const l = t ** 2, e = [...n], o = [], a = [];
  for (; e.length > 0; ) {
    const r = e.shift();
    let s = oe(r.end, r.start), u = r, c = r.start;
    if (s === 0) {
      o.push(r.segments);
      continue;
    }
    for (const d of e)
      for (const S of [d.start, d.end]) {
        const v = oe(r.end, S);
        v < s && (s = v, u = d, c = S);
      }
    if (s <= l) {
      const d = {
        type: je,
        start: r.end,
        end: c
      };
      if (r === u) {
        o.push([...r.segments, d]);
        continue;
      }
      const S = e.indexOf(u);
      S !== -1 && e.splice(S, 1);
      const v = c === u.start ? u.segments : u.segments.map(Pe).reverse(), x = c === u.start ? u.end : u.start;
      e.unshift({
        start: r.start,
        end: x,
        segments: [...r.segments, d, ...v]
      });
    } else
      a.push(r.segments);
  }
  return [o.map(On), a.map(En)];
}
function oe(n, t) {
  return n[0] !== t[0] || n[1] !== t[1] ? (n[0] - t[0]) ** 2 + (n[1] - t[1]) ** 2 : 0;
}
const An = "missingOutlineLayer", Dn = "noPathsInOutlineLayer", Rn = "noClosedRegionsFound";
function Mn(n, t, l) {
  const e = wn(n), o = e ? t[e] : void 0, a = Z.sum(
    Object.values(t).map(({ size: d }) => d)
  );
  if (o === void 0)
    return {
      size: a,
      regions: [],
      openPaths: [],
      failureReason: An
    };
  const r = o.children.filter((d) => d.type === pe).flatMap((d) => d.segments);
  if (r.length === 0)
    return {
      size: a,
      regions: [],
      openPaths: [],
      failureReason: Dn
    };
  const s = kn(r), [u, c] = Ln(s, l);
  return u.length === 0 ? { size: a, regions: u, openPaths: c, failureReason: Rn } : {
    regions: u,
    openPaths: c,
    size: Z.fromGraphics(u)
  };
}
function Ne(n) {
  const { regions: t, size: l, failureReason: e } = n, o = He(l), a = t.flatMap((r) => r.segments);
  return e ? { viewBox: o, failureReason: e } : { viewBox: o, path: $e({ type: ce, segments: a }) };
}
const Tn = [
  "area",
  "base",
  "basefont",
  "bgsound",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "image",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "menuitem",
  "meta",
  "nextid",
  "param",
  "source",
  "track",
  "wbr"
], re = {}.hasOwnProperty;
function In(n, t) {
  const l = t || {};
  function e(o, ...a) {
    let r = e.invalid;
    const s = e.handlers;
    if (o && re.call(o, n)) {
      const u = String(o[n]);
      r = re.call(s, u) ? s[u] : e.unknown;
    }
    if (r)
      return r.call(this, o, ...a);
  }
  return e.handlers = l.handlers || {}, e.invalid = l.invalid, e.unknown = l.unknown, e;
}
function Bn(n, t) {
  if (n = n.replace(
    t.subset ? Fn(t.subset) : /["&'<>`]/g,
    e
  ), t.subset || t.escapeOnly)
    return n;
  return n.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, l).replace(
    // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
    /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g,
    e
  );
  function l(o, a, r) {
    return t.format(
      (o.charCodeAt(0) - 55296) * 1024 + o.charCodeAt(1) - 56320 + 65536,
      r.charCodeAt(a + 2),
      t
    );
  }
  function e(o, a, r) {
    return t.format(
      o.charCodeAt(0),
      r.charCodeAt(a + 1),
      t
    );
  }
}
function Fn(n) {
  const t = [];
  let l = -1;
  for (; ++l < n.length; )
    t.push(n[l].replace(/[|\\{}()[\]^$+*?.]/g, "\\$&"));
  return new RegExp("(?:" + t.join("|") + ")", "g");
}
function Un(n, t, l) {
  const e = "&#x" + n.toString(16).toUpperCase();
  return l && t && !/[\dA-Fa-f]/.test(String.fromCharCode(t)) ? e : e + ";";
}
function _n(n, t, l) {
  const e = "&#" + String(n);
  return l && t && !/\d/.test(String.fromCharCode(t)) ? e : e + ";";
}
const zn = [
  "AElig",
  "AMP",
  "Aacute",
  "Acirc",
  "Agrave",
  "Aring",
  "Atilde",
  "Auml",
  "COPY",
  "Ccedil",
  "ETH",
  "Eacute",
  "Ecirc",
  "Egrave",
  "Euml",
  "GT",
  "Iacute",
  "Icirc",
  "Igrave",
  "Iuml",
  "LT",
  "Ntilde",
  "Oacute",
  "Ocirc",
  "Ograve",
  "Oslash",
  "Otilde",
  "Ouml",
  "QUOT",
  "REG",
  "THORN",
  "Uacute",
  "Ucirc",
  "Ugrave",
  "Uuml",
  "Yacute",
  "aacute",
  "acirc",
  "acute",
  "aelig",
  "agrave",
  "amp",
  "aring",
  "atilde",
  "auml",
  "brvbar",
  "ccedil",
  "cedil",
  "cent",
  "copy",
  "curren",
  "deg",
  "divide",
  "eacute",
  "ecirc",
  "egrave",
  "eth",
  "euml",
  "frac12",
  "frac14",
  "frac34",
  "gt",
  "iacute",
  "icirc",
  "iexcl",
  "igrave",
  "iquest",
  "iuml",
  "laquo",
  "lt",
  "macr",
  "micro",
  "middot",
  "nbsp",
  "not",
  "ntilde",
  "oacute",
  "ocirc",
  "ograve",
  "ordf",
  "ordm",
  "oslash",
  "otilde",
  "ouml",
  "para",
  "plusmn",
  "pound",
  "quot",
  "raquo",
  "reg",
  "sect",
  "shy",
  "sup1",
  "sup2",
  "sup3",
  "szlig",
  "thorn",
  "times",
  "uacute",
  "ucirc",
  "ugrave",
  "uml",
  "uuml",
  "yacute",
  "yen",
  "yuml"
], B = {
  nbsp: " ",
  iexcl: "¡",
  cent: "¢",
  pound: "£",
  curren: "¤",
  yen: "¥",
  brvbar: "¦",
  sect: "§",
  uml: "¨",
  copy: "©",
  ordf: "ª",
  laquo: "«",
  not: "¬",
  shy: "­",
  reg: "®",
  macr: "¯",
  deg: "°",
  plusmn: "±",
  sup2: "²",
  sup3: "³",
  acute: "´",
  micro: "µ",
  para: "¶",
  middot: "·",
  cedil: "¸",
  sup1: "¹",
  ordm: "º",
  raquo: "»",
  frac14: "¼",
  frac12: "½",
  frac34: "¾",
  iquest: "¿",
  Agrave: "À",
  Aacute: "Á",
  Acirc: "Â",
  Atilde: "Ã",
  Auml: "Ä",
  Aring: "Å",
  AElig: "Æ",
  Ccedil: "Ç",
  Egrave: "È",
  Eacute: "É",
  Ecirc: "Ê",
  Euml: "Ë",
  Igrave: "Ì",
  Iacute: "Í",
  Icirc: "Î",
  Iuml: "Ï",
  ETH: "Ð",
  Ntilde: "Ñ",
  Ograve: "Ò",
  Oacute: "Ó",
  Ocirc: "Ô",
  Otilde: "Õ",
  Ouml: "Ö",
  times: "×",
  Oslash: "Ø",
  Ugrave: "Ù",
  Uacute: "Ú",
  Ucirc: "Û",
  Uuml: "Ü",
  Yacute: "Ý",
  THORN: "Þ",
  szlig: "ß",
  agrave: "à",
  aacute: "á",
  acirc: "â",
  atilde: "ã",
  auml: "ä",
  aring: "å",
  aelig: "æ",
  ccedil: "ç",
  egrave: "è",
  eacute: "é",
  ecirc: "ê",
  euml: "ë",
  igrave: "ì",
  iacute: "í",
  icirc: "î",
  iuml: "ï",
  eth: "ð",
  ntilde: "ñ",
  ograve: "ò",
  oacute: "ó",
  ocirc: "ô",
  otilde: "õ",
  ouml: "ö",
  divide: "÷",
  oslash: "ø",
  ugrave: "ù",
  uacute: "ú",
  ucirc: "û",
  uuml: "ü",
  yacute: "ý",
  thorn: "þ",
  yuml: "ÿ",
  fnof: "ƒ",
  Alpha: "Α",
  Beta: "Β",
  Gamma: "Γ",
  Delta: "Δ",
  Epsilon: "Ε",
  Zeta: "Ζ",
  Eta: "Η",
  Theta: "Θ",
  Iota: "Ι",
  Kappa: "Κ",
  Lambda: "Λ",
  Mu: "Μ",
  Nu: "Ν",
  Xi: "Ξ",
  Omicron: "Ο",
  Pi: "Π",
  Rho: "Ρ",
  Sigma: "Σ",
  Tau: "Τ",
  Upsilon: "Υ",
  Phi: "Φ",
  Chi: "Χ",
  Psi: "Ψ",
  Omega: "Ω",
  alpha: "α",
  beta: "β",
  gamma: "γ",
  delta: "δ",
  epsilon: "ε",
  zeta: "ζ",
  eta: "η",
  theta: "θ",
  iota: "ι",
  kappa: "κ",
  lambda: "λ",
  mu: "μ",
  nu: "ν",
  xi: "ξ",
  omicron: "ο",
  pi: "π",
  rho: "ρ",
  sigmaf: "ς",
  sigma: "σ",
  tau: "τ",
  upsilon: "υ",
  phi: "φ",
  chi: "χ",
  psi: "ψ",
  omega: "ω",
  thetasym: "ϑ",
  upsih: "ϒ",
  piv: "ϖ",
  bull: "•",
  hellip: "…",
  prime: "′",
  Prime: "″",
  oline: "‾",
  frasl: "⁄",
  weierp: "℘",
  image: "ℑ",
  real: "ℜ",
  trade: "™",
  alefsym: "ℵ",
  larr: "←",
  uarr: "↑",
  rarr: "→",
  darr: "↓",
  harr: "↔",
  crarr: "↵",
  lArr: "⇐",
  uArr: "⇑",
  rArr: "⇒",
  dArr: "⇓",
  hArr: "⇔",
  forall: "∀",
  part: "∂",
  exist: "∃",
  empty: "∅",
  nabla: "∇",
  isin: "∈",
  notin: "∉",
  ni: "∋",
  prod: "∏",
  sum: "∑",
  minus: "−",
  lowast: "∗",
  radic: "√",
  prop: "∝",
  infin: "∞",
  ang: "∠",
  and: "∧",
  or: "∨",
  cap: "∩",
  cup: "∪",
  int: "∫",
  there4: "∴",
  sim: "∼",
  cong: "≅",
  asymp: "≈",
  ne: "≠",
  equiv: "≡",
  le: "≤",
  ge: "≥",
  sub: "⊂",
  sup: "⊃",
  nsub: "⊄",
  sube: "⊆",
  supe: "⊇",
  oplus: "⊕",
  otimes: "⊗",
  perp: "⊥",
  sdot: "⋅",
  lceil: "⌈",
  rceil: "⌉",
  lfloor: "⌊",
  rfloor: "⌋",
  lang: "〈",
  rang: "〉",
  loz: "◊",
  spades: "♠",
  clubs: "♣",
  hearts: "♥",
  diams: "♦",
  quot: '"',
  amp: "&",
  lt: "<",
  gt: ">",
  OElig: "Œ",
  oelig: "œ",
  Scaron: "Š",
  scaron: "š",
  Yuml: "Ÿ",
  circ: "ˆ",
  tilde: "˜",
  ensp: " ",
  emsp: " ",
  thinsp: " ",
  zwnj: "‌",
  zwj: "‍",
  lrm: "‎",
  rlm: "‏",
  ndash: "–",
  mdash: "—",
  lsquo: "‘",
  rsquo: "’",
  sbquo: "‚",
  ldquo: "“",
  rdquo: "”",
  bdquo: "„",
  dagger: "†",
  Dagger: "‡",
  permil: "‰",
  lsaquo: "‹",
  rsaquo: "›",
  euro: "€"
}, qn = [
  "cent",
  "copy",
  "divide",
  "gt",
  "lt",
  "not",
  "para",
  "times"
], Oe = {}.hasOwnProperty, H = {};
let D;
for (D in B)
  Oe.call(B, D) && (H[B[D]] = D);
function jn(n, t, l, e) {
  const o = String.fromCharCode(n);
  if (Oe.call(H, o)) {
    const a = H[o], r = "&" + a;
    return l && zn.includes(a) && !qn.includes(a) && (!e || t && t !== 61 && /[^\da-z]/i.test(String.fromCharCode(t))) ? r : r + ";";
  }
  return "";
}
function Hn(n, t, l) {
  let e = Un(n, t, l.omitOptionalSemicolons), o;
  if ((l.useNamedReferences || l.useShortestReferences) && (o = jn(
    n,
    t,
    l.omitOptionalSemicolons,
    l.attribute
  )), (l.useShortestReferences || !o) && l.useShortestReferences) {
    const a = _n(n, t, l.omitOptionalSemicolons);
    a.length < e.length && (e = a);
  }
  return o && (!l.useShortestReferences || o.length < e.length) ? o : e;
}
function N(n, t) {
  return Bn(n, Object.assign({ format: Hn }, t));
}
function $n(n, t, l, e) {
  return e.settings.bogusComments ? "<?" + N(
    n.value,
    Object.assign({}, e.settings.characterReferences, { subset: [">"] })
  ) + ">" : "<!--" + n.value.replace(/^>|^->|<!--|-->|--!>|<!-$/g, o) + "-->";
  function o(a) {
    return N(
      a,
      Object.assign({}, e.settings.characterReferences, {
        subset: ["<", ">"]
      })
    );
  }
}
function Gn(n, t, l, e) {
  return "<!" + (e.settings.upperDoctype ? "DOCTYPE" : "doctype") + (e.settings.tightDoctype ? "" : " ") + "html>";
}
function ae(n, t) {
  const l = String(n);
  if (typeof t != "string")
    throw new TypeError("Expected character");
  let e = 0, o = l.indexOf(t);
  for (; o !== -1; )
    e++, o = l.indexOf(t, o + t.length);
  return e;
}
function Y(n) {
  const t = (
    // @ts-expect-error looks like a node.
    n && typeof n == "object" && n.type === "text" ? (
      // @ts-expect-error looks like a text.
      n.value || ""
    ) : n
  );
  return typeof t == "string" && t.replace(/[ \t\n\f\r]/g, "") === "";
}
const f = Le(1), Ee = Le(-1);
function Le(n) {
  return t;
  function t(l, e, o) {
    const a = l ? l.children : [];
    let r = (e || 0) + n, s = a && a[r];
    if (!o)
      for (; s && Y(s); )
        r += n, s = a[r];
    return s;
  }
}
const Yn = {}.hasOwnProperty;
function Ae(n) {
  return t;
  function t(l, e, o) {
    return Yn.call(n, l.tagName) && n[l.tagName](l, e, o);
  }
}
const V = Ae({
  html: Vn,
  head: F,
  body: Wn,
  p: Kn,
  li: Xn,
  dt: Zn,
  dd: Jn,
  rt: ie,
  rp: ie,
  optgroup: Qn,
  option: et,
  menuitem: nt,
  colgroup: F,
  caption: F,
  thead: tt,
  tbody: lt,
  tfoot: ot,
  tr: rt,
  td: se,
  th: se
});
function F(n, t, l) {
  const e = f(l, t, !0);
  return !e || e.type !== "comment" && !(e.type === "text" && Y(e.value.charAt(0)));
}
function Vn(n, t, l) {
  const e = f(l, t);
  return !e || e.type !== "comment";
}
function Wn(n, t, l) {
  const e = f(l, t);
  return !e || e.type !== "comment";
}
function Kn(n, t, l) {
  const e = f(l, t);
  return e ? e.type === "element" && (e.tagName === "address" || e.tagName === "article" || e.tagName === "aside" || e.tagName === "blockquote" || e.tagName === "details" || e.tagName === "div" || e.tagName === "dl" || e.tagName === "fieldset" || e.tagName === "figcaption" || e.tagName === "figure" || e.tagName === "footer" || e.tagName === "form" || e.tagName === "h1" || e.tagName === "h2" || e.tagName === "h3" || e.tagName === "h4" || e.tagName === "h5" || e.tagName === "h6" || e.tagName === "header" || e.tagName === "hgroup" || e.tagName === "hr" || e.tagName === "main" || e.tagName === "menu" || e.tagName === "nav" || e.tagName === "ol" || e.tagName === "p" || e.tagName === "pre" || e.tagName === "section" || e.tagName === "table" || e.tagName === "ul") : !l || // Confusing parent.
  !(l.type === "element" && (l.tagName === "a" || l.tagName === "audio" || l.tagName === "del" || l.tagName === "ins" || l.tagName === "map" || l.tagName === "noscript" || l.tagName === "video"));
}
function Xn(n, t, l) {
  const e = f(l, t);
  return !e || e.type === "element" && e.tagName === "li";
}
function Zn(n, t, l) {
  const e = f(l, t);
  return e && e.type === "element" && (e.tagName === "dt" || e.tagName === "dd");
}
function Jn(n, t, l) {
  const e = f(l, t);
  return !e || e.type === "element" && (e.tagName === "dt" || e.tagName === "dd");
}
function ie(n, t, l) {
  const e = f(l, t);
  return !e || e.type === "element" && (e.tagName === "rp" || e.tagName === "rt");
}
function Qn(n, t, l) {
  const e = f(l, t);
  return !e || e.type === "element" && e.tagName === "optgroup";
}
function et(n, t, l) {
  const e = f(l, t);
  return !e || e.type === "element" && (e.tagName === "option" || e.tagName === "optgroup");
}
function nt(n, t, l) {
  const e = f(l, t);
  return !e || e.type === "element" && (e.tagName === "menuitem" || e.tagName === "hr" || e.tagName === "menu");
}
function tt(n, t, l) {
  const e = f(l, t);
  return e && e.type === "element" && (e.tagName === "tbody" || e.tagName === "tfoot");
}
function lt(n, t, l) {
  const e = f(l, t);
  return !e || e.type === "element" && (e.tagName === "tbody" || e.tagName === "tfoot");
}
function ot(n, t, l) {
  return !f(l, t);
}
function rt(n, t, l) {
  const e = f(l, t);
  return !e || e.type === "element" && e.tagName === "tr";
}
function se(n, t, l) {
  const e = f(l, t);
  return !e || e.type === "element" && (e.tagName === "td" || e.tagName === "th");
}
const at = Ae({
  html: it,
  head: st,
  body: ut,
  colgroup: ct,
  tbody: pt
});
function it(n) {
  const t = f(n, -1);
  return !t || t.type !== "comment";
}
function st(n) {
  const t = n.children, l = [];
  let e = -1;
  for (; ++e < t.length; ) {
    const o = t[e];
    if (o.type === "element" && (o.tagName === "title" || o.tagName === "base")) {
      if (l.includes(o.tagName))
        return !1;
      l.push(o.tagName);
    }
  }
  return t.length > 0;
}
function ut(n) {
  const t = f(n, -1, !0);
  return !t || t.type !== "comment" && !(t.type === "text" && Y(t.value.charAt(0))) && !(t.type === "element" && (t.tagName === "meta" || t.tagName === "link" || t.tagName === "script" || t.tagName === "style" || t.tagName === "template"));
}
function ct(n, t, l) {
  const e = Ee(l, t), o = f(n, -1, !0);
  return l && e && e.type === "element" && e.tagName === "colgroup" && V(e, l.children.indexOf(e), l) ? !1 : o && o.type === "element" && o.tagName === "col";
}
function pt(n, t, l) {
  const e = Ee(l, t), o = f(n, -1);
  return l && e && e.type === "element" && (e.tagName === "thead" || e.tagName === "tbody") && V(e, l.children.indexOf(e), l) ? !1 : o && o.type === "element" && o.tagName === "tr";
}
const R = {
  // See: <https://html.spec.whatwg.org/#attribute-name-state>.
  name: [
    [`	
\f\r &/=>`.split(""), `	
\f\r "&'/=>\``.split("")],
    [`\0	
\f\r "&'/<=>`.split(""), `\0	
\f\r "&'/<=>\``.split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(unquoted)-state>.
  unquoted: [
    [`	
\f\r &>`.split(""), `\0	
\f\r "&'<=>\``.split("")],
    [`\0	
\f\r "&'<=>\``.split(""), `\0	
\f\r "&'<=>\``.split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(single-quoted)-state>.
  single: [
    ["&'".split(""), "\"&'`".split("")],
    ["\0&'".split(""), "\0\"&'`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(double-quoted)-state>.
  double: [
    ['"&'.split(""), "\"&'`".split("")],
    ['\0"&'.split(""), "\0\"&'`".split("")]
  ]
};
function dt(n, t, l, e) {
  const o = e.schema, a = o.space === "svg" ? !1 : e.settings.omitOptionalTags;
  let r = o.space === "svg" ? e.settings.closeEmptyElements : e.settings.voids.includes(n.tagName.toLowerCase());
  const s = [];
  let u;
  o.space === "html" && n.tagName === "svg" && (e.schema = G);
  const c = gt(e, n.properties), d = e.all(
    o.space === "html" && n.tagName === "template" ? n.content : n
  );
  return e.schema = o, d && (r = !1), (c || !a || !at(n, t, l)) && (s.push("<", n.tagName, c ? " " + c : ""), r && (o.space === "svg" || e.settings.closeSelfClosing) && (u = c.charAt(c.length - 1), (!e.settings.tightSelfClosing || u === "/" || u && u !== '"' && u !== "'") && s.push(" "), s.push("/")), s.push(">")), s.push(d), !r && (!a || !V(n, t, l)) && s.push("</" + n.tagName + ">"), s.join("");
}
function gt(n, t) {
  const l = [];
  let e = -1, o;
  if (t) {
    for (o in t)
      if (t[o] !== void 0 && t[o] !== null) {
        const a = mt(n, o, t[o]);
        a && l.push(a);
      }
  }
  for (; ++e < l.length; ) {
    const a = n.settings.tightAttributes ? l[e].charAt(l[e].length - 1) : null;
    e !== l.length - 1 && a !== '"' && a !== "'" && (l[e] += " ");
  }
  return l.join("");
}
function mt(n, t, l) {
  const e = ke(n.schema, t), o = n.settings.allowParseErrors && n.schema.space === "html" ? 0 : 1, a = n.settings.allowDangerousCharacters ? 0 : 1;
  let r = n.quote, s;
  if (e.overloadedBoolean && (l === e.attribute || l === "") ? l = !0 : (e.boolean || e.overloadedBoolean && typeof l != "string") && (l = Boolean(l)), l == null || l === !1 || typeof l == "number" && Number.isNaN(l))
    return "";
  const u = N(
    e.attribute,
    Object.assign({}, n.settings.characterReferences, {
      // Always encode without parse errors in non-HTML.
      subset: R.name[o][a]
    })
  );
  return l === !0 || (l = Array.isArray(l) ? (e.commaSeparated ? cn : un)(l, {
    padLeft: !n.settings.tightCommaSeparatedLists
  }) : String(l), n.settings.collapseEmptyAttributes && !l) ? u : (n.settings.preferUnquoted && (s = N(
    l,
    Object.assign({}, n.settings.characterReferences, {
      subset: R.unquoted[o][a],
      attribute: !0
    })
  )), s !== l && (n.settings.quoteSmart && ae(l, r) > ae(l, n.alternative) && (r = n.alternative), s = r + N(
    l,
    Object.assign({}, n.settings.characterReferences, {
      // Always encode without parse errors in non-HTML.
      subset: (r === "'" ? R.single : R.double)[o][a],
      attribute: !0
    })
  ) + r), u + (s && "=" + s));
}
function De(n, t, l, e) {
  return l && l.type === "element" && (l.tagName === "script" || l.tagName === "style") ? n.value : N(
    n.value,
    Object.assign({}, e.settings.characterReferences, {
      subset: ["<", "&"]
    })
  );
}
function ft(n, t, l, e) {
  return e.settings.allowDangerousHtml ? n.value : De(n, t, l, e);
}
function ht(n, t, l, e) {
  return e.all(n);
}
const yt = In("type", {
  invalid: bt,
  unknown: St,
  handlers: { comment: $n, doctype: Gn, element: dt, raw: ft, root: ht, text: De }
});
function bt(n) {
  throw new Error("Expected node, not `" + n + "`");
}
function St(n) {
  throw new Error("Cannot compile unknown node `" + n.type + "`");
}
function vt(n, t) {
  const l = t || {}, e = l.quote || '"', o = e === '"' ? "'" : '"';
  if (e !== '"' && e !== "'")
    throw new Error("Invalid quote `" + e + "`, expected `'` or `\"`");
  return {
    one: xt,
    all: wt,
    settings: {
      omitOptionalTags: l.omitOptionalTags || !1,
      allowParseErrors: l.allowParseErrors || !1,
      allowDangerousCharacters: l.allowDangerousCharacters || !1,
      quoteSmart: l.quoteSmart || !1,
      preferUnquoted: l.preferUnquoted || !1,
      tightAttributes: l.tightAttributes || !1,
      upperDoctype: l.upperDoctype || !1,
      tightDoctype: l.tightDoctype || !1,
      bogusComments: l.bogusComments || !1,
      tightCommaSeparatedLists: l.tightCommaSeparatedLists || !1,
      tightSelfClosing: l.tightSelfClosing || !1,
      collapseEmptyAttributes: l.collapseEmptyAttributes || !1,
      allowDangerousHtml: l.allowDangerousHtml || !1,
      voids: l.voids || Tn,
      characterReferences: l.characterReferences || l.entities || {},
      closeSelfClosing: l.closeSelfClosing || !1,
      closeEmptyElements: l.closeEmptyElements || !1
    },
    schema: l.space === "svg" ? G : an,
    quote: e,
    alternative: o
  }.one(
    Array.isArray(n) ? { type: "root", children: n } : n,
    void 0,
    void 0
  );
}
function xt(n, t, l) {
  return yt(n, t, l, this);
}
function wt(n) {
  const t = [], l = n && n.children || [];
  let e = -1;
  for (; ++e < l.length; )
    t[e] = this.one(l[e], e, n);
  return t.join("");
}
function ue(n) {
  return vt(n, { space: "svg" });
}
async function Lt(n) {
  const t = n.map(kt), l = await Promise.all(t), e = xn(l), o = [], a = {};
  for (const { id: r, filename: s, parseTree: u } of l) {
    const { type: c, side: d } = e[r];
    o.push({ id: r, filename: s, type: c, side: d }), a[r] = u;
  }
  return { layers: o, parseTreesById: a };
}
async function kt(n) {
  const t = de(), { filename: l, contents: e } = await bn(n), o = Ue.parse(e);
  return { id: t, filename: l, parseTree: o };
}
function At(n) {
  const { layers: t, parseTreesById: l } = n, e = {};
  for (const { id: a } of t)
    e[a] = qe.plot(l[a]);
  const o = Mn(t, e, 0.02);
  return { layers: t, plotTreesById: e, boardShape: o };
}
function Dt(n) {
  const { layers: t, boardShape: l, plotTreesById: e } = n, o = Ne(l), a = {};
  for (const { id: r } of t)
    a[r] = M.render(
      e[r],
      o.viewBox
    );
  return { layers: t, rendersById: a, boardShapeRender: o };
}
function Rt(n) {
  const { layers: t, rendersById: l, boardShapeRender: e } = n, { viewBox: o, path: a } = e, r = Ce(t), [s, u, c, d] = o, S = {}, v = (x) => l[x].children;
  for (const x of [me, U]) {
    const {
      copper: Re,
      solderMask: Me,
      silkScreen: Te,
      solderPaste: Ie
    } = j(x, t), T = de(), W = `drill-${T}`, K = `resist-${T}`, X = `shape-${T}`, Be = a ? `url(#${X})` : void 0, Fe = x === U ? `translate(${2 * s + c},0) scale(-1,1)` : void 0;
    S[x] = h(
      "svg",
      {
        ...M.BASE_SVG_PROPS,
        ...M.BASE_IMAGE_PROPS,
        viewBox: `${s} ${u} ${c} ${d}`
      },
      [
        h("defs", [
          h("mask", { id: W }, [
            h("rect", { x: s, y: u, width: c, height: d, fill: "#fff" }),
            h("g", { color: "#000" }, r.flatMap(v))
          ]),
          h("mask", { id: K }, [
            h("rect", { x: s, y: u, width: c, height: d, fill: "#fff" }),
            h("g", { color: "#000" }, Me.flatMap(v))
          ]),
          a ? h("clipPath", { id: X }, a) : void 0
        ]),
        h("g", { transform: Fe, "clip-path": Be }, [
          h("g", { mask: `url(#${W})` }, [
            h("rect", { fill: "#666", x: s, y: u, width: c, height: d }),
            h("g", { color: "#c93" }, Re.flatMap(v))
          ]),
          h("g", { mask: `url(#${K})` }, [
            h("rect", { fill: "#004200", opacity: "0.8", x: s, y: u, width: c, height: d }),
            h("g", { color: "#fff" }, Te.flatMap(v))
          ]),
          h("g", { color: "#999" }, Ie.flatMap(v))
        ])
      ]
    );
  }
  return S;
}
function Mt(n) {
  const { layers: t, plotTreesById: l, boardShape: e } = n, { viewBox: o, path: a } = Ne(e), r = j(me, t), s = j(U, t), u = Ce(t), c = {
    viewBox: o,
    svgFragment: a ? ue(a) : void 0
  }, d = {};
  for (const { id: S } of t)
    d[S] = ue(
      M.renderFragment(l[S])
    );
  return {
    layers: t,
    topLayers: r,
    bottomLayers: s,
    drillLayers: u,
    boardShapeRenderFragment: c,
    svgFragmentsById: d
  };
}
export {
  At as plot,
  Lt as read,
  Rt as renderBoard,
  Mt as renderFragments,
  Dt as renderLayers,
  ue as stringifySvg
};
//# sourceMappingURL=tracespace-core.js.map
