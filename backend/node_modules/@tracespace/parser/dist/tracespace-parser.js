var it = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, ce = {}, st = {
  get exports() {
    return ce;
  },
  set exports(e) {
    ce = e;
  }
};
(function(e) {
  (function(o, r) {
    e.exports ? e.exports = r() : o.moo = r();
  })(it, function() {
    var o = Object.prototype.hasOwnProperty, r = Object.prototype.toString, s = typeof new RegExp().sticky == "boolean";
    function i(n) {
      return n && r.call(n) === "[object RegExp]";
    }
    function c(n) {
      return n && typeof n == "object" && !i(n) && !Array.isArray(n);
    }
    function f(n) {
      return n.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
    }
    function p(n) {
      var a = new RegExp("|" + n);
      return a.exec("").length - 1;
    }
    function N(n) {
      return "(" + n + ")";
    }
    function O(n) {
      if (!n.length)
        return "(?!)";
      var a = n.map(function(l) {
        return "(?:" + l + ")";
      }).join("|");
      return "(?:" + a + ")";
    }
    function T(n) {
      if (typeof n == "string")
        return "(?:" + f(n) + ")";
      if (i(n)) {
        if (n.ignoreCase)
          throw new Error("RegExp /i flag not allowed");
        if (n.global)
          throw new Error("RegExp /g flag is implied");
        if (n.sticky)
          throw new Error("RegExp /y flag is implied");
        if (n.multiline)
          throw new Error("RegExp /m flag is implied");
        return n.source;
      } else
        throw new Error("Not a pattern: " + n);
    }
    function P(n, a) {
      return n.length > a ? n : Array(a - n.length + 1).join(" ") + n;
    }
    function Ke(n, a) {
      for (var l = n.length, u = 0; ; ) {
        var m = n.lastIndexOf(`
`, l - 1);
        if (m === -1 || (u++, l = m, u === a) || l === 0)
          break;
      }
      var h = u < a ? 0 : l + 1;
      return n.substring(h).split(`
`);
    }
    function Qe(n) {
      for (var a = Object.getOwnPropertyNames(n), l = [], u = 0; u < a.length; u++) {
        var m = a[u], h = n[m], v = [].concat(h);
        if (m === "include") {
          for (var A = 0; A < v.length; A++)
            l.push({ include: v[A] });
          continue;
        }
        var E = [];
        v.forEach(function(d) {
          c(d) ? (E.length && l.push(Y(m, E)), l.push(Y(m, d)), E = []) : E.push(d);
        }), E.length && l.push(Y(m, E));
      }
      return l;
    }
    function Je(n) {
      for (var a = [], l = 0; l < n.length; l++) {
        var u = n[l];
        if (u.include) {
          for (var m = [].concat(u.include), h = 0; h < m.length; h++)
            a.push({ include: m[h] });
          continue;
        }
        if (!u.type)
          throw new Error("Rule has no type: " + JSON.stringify(u));
        a.push(Y(u.type, u));
      }
      return a;
    }
    function Y(n, a) {
      if (c(a) || (a = { match: a }), a.include)
        throw new Error("Matching rules cannot also include states");
      var l = {
        defaultType: n,
        lineBreaks: !!a.error || !!a.fallback,
        pop: !1,
        next: null,
        push: null,
        error: !1,
        fallback: !1,
        value: null,
        type: null,
        shouldThrow: !1
      };
      for (var u in a)
        o.call(a, u) && (l[u] = a[u]);
      if (typeof l.type == "string" && n !== l.type)
        throw new Error("Type transform cannot be a string (type '" + l.type + "' for token '" + n + "')");
      var m = l.match;
      return l.match = Array.isArray(m) ? m : m ? [m] : [], l.match.sort(function(h, v) {
        return i(h) && i(v) ? 0 : i(v) ? -1 : i(h) ? 1 : v.length - h.length;
      }), l;
    }
    function ie(n) {
      return Array.isArray(n) ? Je(n) : Qe(n);
    }
    var je = Y("error", { lineBreaks: !0, shouldThrow: !0 });
    function Oe(n, a) {
      for (var l = null, u = /* @__PURE__ */ Object.create(null), m = !0, h = null, v = [], A = [], E = 0; E < n.length; E++)
        n[E].fallback && (m = !1);
      for (var E = 0; E < n.length; E++) {
        var d = n[E];
        if (d.include)
          throw new Error("Inheritance is not allowed in stateless lexers");
        if (d.error || d.fallback) {
          if (l)
            throw !d.fallback == !l.fallback ? new Error("Multiple " + (d.fallback ? "fallback" : "error") + " rules not allowed (for token '" + d.defaultType + "')") : new Error("fallback and error are mutually exclusive (for token '" + d.defaultType + "')");
          l = d;
        }
        var _ = d.match.slice();
        if (m)
          for (; _.length && typeof _[0] == "string" && _[0].length === 1; ) {
            var q = _.shift();
            u[q.charCodeAt(0)] = d;
          }
        if (d.pop || d.push || d.next) {
          if (!a)
            throw new Error("State-switching options are not allowed in stateless lexers (for token '" + d.defaultType + "')");
          if (d.fallback)
            throw new Error("State-switching options are not allowed on fallback tokens (for token '" + d.defaultType + "')");
        }
        if (_.length !== 0) {
          m = !1, v.push(d);
          for (var H = 0; H < _.length; H++) {
            var U = _[H];
            if (i(U)) {
              if (h === null)
                h = U.unicode;
              else if (h !== U.unicode && d.fallback === !1)
                throw new Error("If one rule is /u then all must be");
            }
          }
          var V = O(_.map(T)), L = new RegExp(V);
          if (L.test(""))
            throw new Error("RegExp matches empty string: " + L);
          var X = p(V);
          if (X > 0)
            throw new Error("RegExp has capture groups: " + L + `
Use (?: â€¦ ) instead`);
          if (!d.lineBreaks && L.test(`
`))
            throw new Error("Rule should declare lineBreaks: " + L);
          A.push(N(V));
        }
      }
      var Z = l && l.fallback, K = s && !Z ? "ym" : "gm", ee = s || Z ? "" : "|";
      h === !0 && (K += "u");
      var at = new RegExp(O(A) + ee, K);
      return { regexp: at, groups: v, fast: u, error: l || je };
    }
    function et(n) {
      var a = Oe(ie(n));
      return new w({ start: a }, "start");
    }
    function ge(n, a, l) {
      var u = n && (n.push || n.next);
      if (u && !l[u])
        throw new Error("Missing state '" + u + "' (in token '" + n.defaultType + "' of state '" + a + "')");
      if (n && n.pop && +n.pop != 1)
        throw new Error("pop must be 1 (in token '" + n.defaultType + "' of state '" + a + "')");
    }
    function tt(n, a) {
      var l = n.$all ? ie(n.$all) : [];
      delete n.$all;
      var u = Object.getOwnPropertyNames(n);
      a || (a = u[0]);
      for (var m = /* @__PURE__ */ Object.create(null), h = 0; h < u.length; h++) {
        var v = u[h];
        m[v] = ie(n[v]).concat(l);
      }
      for (var h = 0; h < u.length; h++)
        for (var v = u[h], A = m[v], E = /* @__PURE__ */ Object.create(null), d = 0; d < A.length; d++) {
          var _ = A[d];
          if (_.include) {
            var q = [d, 1];
            if (_.include !== v && !E[_.include]) {
              E[_.include] = !0;
              var H = m[_.include];
              if (!H)
                throw new Error("Cannot include nonexistent state '" + _.include + "' (in state '" + v + "')");
              for (var U = 0; U < H.length; U++) {
                var V = H[U];
                A.indexOf(V) === -1 && q.push(V);
              }
            }
            A.splice.apply(A, q), d--;
          }
        }
      for (var L = /* @__PURE__ */ Object.create(null), h = 0; h < u.length; h++) {
        var v = u[h];
        L[v] = Oe(m[v], !0);
      }
      for (var h = 0; h < u.length; h++) {
        for (var X = u[h], Z = L[X], K = Z.groups, d = 0; d < K.length; d++)
          ge(K[d], X, L);
        for (var ee = Object.getOwnPropertyNames(Z.fast), d = 0; d < ee.length; d++)
          ge(Z.fast[ee[d]], X, L);
      }
      return new w(L, a);
    }
    function nt(n) {
      for (var a = typeof Map < "u", l = a ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null), u = Object.getOwnPropertyNames(n), m = 0; m < u.length; m++) {
        var h = u[m], v = n[h], A = Array.isArray(v) ? v : [v];
        A.forEach(function(E) {
          if (typeof E != "string")
            throw new Error("keyword must be string (in keyword '" + h + "')");
          a ? l.set(E, h) : l[E] = h;
        });
      }
      return function(E) {
        return a ? l.get(E) : l[E];
      };
    }
    var w = function(n, a) {
      this.startState = a, this.states = n, this.buffer = "", this.stack = [], this.reset();
    };
    w.prototype.reset = function(n, a) {
      return this.buffer = n || "", this.index = 0, this.line = a ? a.line : 1, this.col = a ? a.col : 1, this.queuedToken = a ? a.queuedToken : null, this.queuedText = a ? a.queuedText : "", this.queuedThrow = a ? a.queuedThrow : null, this.setState(a ? a.state : this.startState), this.stack = a && a.stack ? a.stack.slice() : [], this;
    }, w.prototype.save = function() {
      return {
        line: this.line,
        col: this.col,
        state: this.state,
        stack: this.stack.slice(),
        queuedToken: this.queuedToken,
        queuedText: this.queuedText,
        queuedThrow: this.queuedThrow
      };
    }, w.prototype.setState = function(n) {
      if (!(!n || this.state === n)) {
        this.state = n;
        var a = this.states[n];
        this.groups = a.groups, this.error = a.error, this.re = a.regexp, this.fast = a.fast;
      }
    }, w.prototype.popState = function() {
      this.setState(this.stack.pop());
    }, w.prototype.pushState = function(n) {
      this.stack.push(this.state), this.setState(n);
    };
    var rt = s ? function(n, a) {
      return n.exec(a);
    } : function(n, a) {
      var l = n.exec(a);
      return l[0].length === 0 ? null : l;
    };
    w.prototype._getGroup = function(n) {
      for (var a = this.groups.length, l = 0; l < a; l++)
        if (n[l + 1] !== void 0)
          return this.groups[l];
      throw new Error("Cannot find token type for matched text");
    };
    function ot() {
      return this.value;
    }
    if (w.prototype.next = function() {
      var n = this.index;
      if (this.queuedGroup) {
        var a = this._token(this.queuedGroup, this.queuedText, n);
        return this.queuedGroup = null, this.queuedText = "", a;
      }
      var l = this.buffer;
      if (n !== l.length) {
        var v = this.fast[l.charCodeAt(n)];
        if (v)
          return this._token(v, l.charAt(n), n);
        var u = this.re;
        u.lastIndex = n;
        var m = rt(u, l), h = this.error;
        if (m == null)
          return this._token(h, l.slice(n, l.length), n);
        var v = this._getGroup(m), A = m[0];
        return h.fallback && m.index !== n ? (this.queuedGroup = v, this.queuedText = A, this._token(h, l.slice(n, m.index), n)) : this._token(v, A, n);
      }
    }, w.prototype._token = function(n, a, l) {
      var u = 0;
      if (n.lineBreaks) {
        var m = /\n/g, h = 1;
        if (a === `
`)
          u = 1;
        else
          for (; m.exec(a); )
            u++, h = m.lastIndex;
      }
      var v = {
        type: typeof n.type == "function" && n.type(a) || n.defaultType,
        value: typeof n.value == "function" ? n.value(a) : a,
        text: a,
        toString: ot,
        offset: l,
        lineBreaks: u,
        line: this.line,
        col: this.col
      }, A = a.length;
      if (this.index += A, this.line += u, u !== 0 ? this.col = A - h + 1 : this.col += A, n.shouldThrow) {
        var E = new Error(this.formatError(v, "invalid syntax"));
        throw E;
      }
      return n.pop ? this.popState() : n.push ? this.pushState(n.push) : n.next && this.setState(n.next), v;
    }, typeof Symbol < "u" && Symbol.iterator) {
      var se = function(n) {
        this.lexer = n;
      };
      se.prototype.next = function() {
        var n = this.lexer.next();
        return { value: n, done: !n };
      }, se.prototype[Symbol.iterator] = function() {
        return this;
      }, w.prototype[Symbol.iterator] = function() {
        return new se(this);
      };
    }
    return w.prototype.formatError = function(n, a) {
      if (n == null)
        var l = this.buffer.slice(this.index), n = {
          text: l,
          offset: this.index,
          lineBreaks: l.indexOf(`
`) === -1 ? 0 : 1,
          line: this.line,
          col: this.col
        };
      var u = 2, m = Math.max(n.line - u, 1), h = n.line + u, v = String(h).length, A = Ke(
        this.buffer,
        this.line - n.line + u + 1
      ).slice(0, 5), E = [];
      E.push(a + " at line " + n.line + " col " + n.col + ":"), E.push("");
      for (var d = 0; d < A.length; d++) {
        var _ = A[d], q = m + d;
        E.push(P(String(q), v) + "  " + _), q === n.line && E.push(P("", v + n.col + 1) + "^");
      }
      return E.join(`
`);
    }, w.prototype.clone = function() {
      return new w(this.states, this.state);
    }, w.prototype.has = function(n) {
      return !0;
    }, {
      compile: et,
      states: tt,
      error: Object.freeze({ error: !0 }),
      fallback: Object.freeze({ fallback: !0 }),
      keywords: nt
    };
  });
})(st);
const Ae = ce, Q = "T_CODE", y = "G_CODE", B = "M_CODE", I = "D_CODE", g = "ASTERISK", x = "PERCENT", Me = "EQUALS", W = "COMMA", k = "OPERATOR", ue = "GERBER_FORMAT", ne = "GERBER_UNITS", Ce = "GERBER_TOOL_MACRO", Ne = "GERBER_TOOL_DEF", _e = "GERBER_LOAD_POLARITY", xe = "GERBER_STEP_REPEAT", J = "GERBER_MACRO_VARIABLE", we = "SEMICOLON", Le = "DRILL_UNITS", fe = "DRILL_ZERO_INCLUSION", M = "COORD_CHAR", C = "NUMBER", lt = "WORD", ct = "WHITESPACE", S = "NEWLINE", ut = "CATCHALL", ft = "ERROR", pt = /^0*/, Ie = (e) => e.replace(pt, ""), te = (e) => Ie(e.slice(1)) || "0", ht = {
  [Q]: {
    match: /T\d+/,
    value: te
  },
  [y]: {
    match: /G\d+/,
    value: te
  },
  [B]: {
    match: /M\d+/,
    value: te
  },
  [I]: {
    match: /D\d+/,
    value: te
  },
  [g]: "*",
  [x]: "%",
  [Me]: "=",
  [ue]: {
    match: /FS[LTDAI]+/,
    value: (e) => e.slice(2)
  },
  [ne]: {
    match: /MO(?:IN|MM)/,
    value: (e) => e.slice(2)
  },
  [Ce]: {
    // "-" in a tool name is illegal, but some gerber writers misbehave
    // https://github.com/mcous/gerber-parser/pull/13
    match: /AM[a-zA-Z_.$][\w.-]*/,
    value: (e) => e.slice(2)
  },
  [Ne]: {
    match: /ADD\d+[a-zA-Z_.$][\w.-]*/,
    value: (e) => Ie(e.slice(3))
  },
  [_e]: {
    match: /LP[DC]/,
    value: (e) => e.slice(2)
  },
  [xe]: "SR",
  [J]: /\$\d+/,
  [we]: ";",
  [Le]: /^(?:METRIC|INCH)/,
  [fe]: {
    match: /,(?:TZ|LZ)/,
    value: (e) => e.slice(1)
  },
  [M]: /[XYIJACFSBHZN]/,
  [C]: /[+-]?[\d.]+/,
  [k]: ["x", "/", "+", "-", "(", ")"],
  [W]: ",",
  [lt]: /[a-zA-Z]+/,
  [ct]: /[ \t]+/,
  [S]: {
    match: /\r?\n/,
    lineBreaks: !0
  },
  [ut]: /\S/,
  [ft]: Ae.error
};
function dt() {
  const e = Ae.compile(ht);
  return { feed: o };
  function o(s, i = null) {
    return e.reset(s, i ?? void 0), r((i == null ? void 0 : i.offset) ?? 0);
  }
  function r(s) {
    return {
      [Symbol.iterator]() {
        return this;
      },
      next() {
        const i = e.next();
        if (i) {
          const c = { ...i, offset: s + i.offset }, f = {
            ...e.save(),
            offset: s + (e.index ?? 0)
          };
          return { value: [c, f] };
        }
        return { value: void 0, done: !0 };
      }
    };
  }
}
const Se = "gerber", pe = "drill", he = "mm", de = "in", be = "leading", Pe = "trailing", mt = "absolute", vt = "incremental", me = "circle", De = "rectangle", Et = "obround", yt = "polygon", Rt = "macroShape", Mn = "1", Cn = "2", Nn = "20", _n = "21", xn = "22", wn = "4", Ln = "5", In = "6", Sn = "7", Ot = "shape", Ge = "move", gt = "segment", Tt = "slot", At = "line", Mt = "cwArc", Ct = "ccwArc", Nt = "single", _t = "multi", xt = "dark", wt = "clear", re = "TOKEN", G = "MIN_TO_MAX";
function t(e, o) {
  return { rule: re, type: e, value: o };
}
function F(e, o) {
  return { rule: re, type: e, value: o, negate: !0 };
}
function D(e) {
  return { rule: G, min: 1, max: 1, match: e };
}
function j(e) {
  return { rule: G, min: 0, max: 1, match: e };
}
function b(e) {
  return { rule: G, min: 0, max: Number.POSITIVE_INFINITY, match: e };
}
function Be(e) {
  return { rule: G, min: 1, max: Number.POSITIVE_INFINITY, match: e };
}
function z(e, o, r) {
  return { rule: G, min: e, max: o, match: r };
}
function qe(e, o) {
  const r = [];
  for (const s of o) {
    const i = It(e, s.rules);
    if (i === Ue)
      r.push(s);
    else if (i === He)
      return {
        filetype: s.filetype,
        nodes: s.createNodes(e)
      };
  }
  return r.length > 0 ? { candidates: r, tokens: e } : {};
}
const He = "FULL_MATCH", Ue = "PARTIAL_MATCH", Lt = "NO_MATCH";
function It(e, o) {
  let r = 0, s = 0, i = 0;
  for (; r < o.length && s < e.length; ) {
    const c = o[r], f = e[s];
    if (ke(c, f))
      c.rule === re || c.rule === G && i >= c.max - 1 ? (r++, s++, i = 0) : c.rule === G && (s++, i++);
    else if (c.rule === G && i >= c.min)
      i = 0, r++;
    else
      return Lt;
  }
  return r < o.length ? Ue : He;
}
function ke(e, o) {
  if (e.rule === re) {
    const r = e.type === o.type, s = e.value === null || typeof e.value > "u" || typeof e.value == "string" && e.value === o.value || e.value instanceof RegExp && e.value.test(o.value), i = r && s;
    return e.negate ? !i : i;
  }
  return Array.isArray(e.match) ? e.match.some((r) => ke(r, o)) : !1;
}
const St = "root", Fe = "comment", bt = "drillHeader", ze = "done", ve = "units", $e = "coordinateFormat", Ve = "toolDefinition", Pt = "toolMacro", Ee = "toolChange", Dt = "loadPolarity", Gt = "stepRepeat", ye = "graphic", oe = "interpolateMode", Bt = "regionMode", qt = "quadrantMode", Ht = "unimplemented", Ut = "macroComment", kt = "macroVariable", Ft = "macroPrimitive";
function $(e) {
  return Object.fromEntries(
    e.map((o, r) => [o, e[r - 1]]).filter(([o, r]) => o.type === C && (r == null ? void 0 : r.type) === M).map(([o, r]) => [r.value.toLowerCase(), o.value])
  );
}
function ae(e) {
  return e.filter((r) => r.type === y).map((r) => r.value === "0" ? Ge : r.value === "1" ? At : r.value === "2" ? Mt : r.value === "3" ? Ct : r.value === "5" ? pe : null)[0] ?? null;
}
function zt(e) {
  return e.filter((r) => r.type === I).map((r) => r.value === "1" ? gt : r.value === "2" ? Ge : r.value === "3" ? Ot : null)[0] ?? null;
}
function Re(e) {
  return e.map((o) => o.value).join("").trim();
}
function R(e, o = {}) {
  const { head: r = e[0], length: s = 0 } = o, i = s > 0 ? e[e.indexOf(r) + s - 1] : e[e.length - 1];
  return {
    start: { line: r.line, column: r.col, offset: r.offset },
    end: { line: i.line, column: i.col, offset: i.offset }
  };
}
const $t = {
  name: "units",
  rules: [
    D([
      t(Le),
      t(B, "71"),
      t(B, "72")
    ]),
    b([
      t(W),
      t(fe),
      t(C, /^0{1,8}\.0{1,8}$/)
    ]),
    t(S)
  ],
  createNodes(e) {
    const o = e[0].value === "INCH" || e[0].value === "72" ? de : he, r = e.filter((c) => c.type === fe).map((c) => c.value === "LZ" ? Pe : c.value === "TZ" ? be : null), s = e.filter((c) => c.type === C).map((c) => {
      const [f = "", p = ""] = c.value.split(".");
      return [f.length, p.length];
    }), i = [
      { type: ve, position: R(e.slice(0, 2)), units: o }
    ];
    return (r.length > 0 || s.length > 0) && i.push({
      type: $e,
      position: R(e.slice(1)),
      mode: null,
      format: s[0] ?? null,
      zeroSuppression: r[0] ?? null
    }), i;
  }
}, Vt = {
  name: "tool",
  rules: [
    t(Q),
    z(0, 12, [
      t(M, "C"),
      t(M, "F"),
      t(M, "S"),
      t(M, "B"),
      t(M, "H"),
      t(M, "Z"),
      t(C)
    ]),
    t(S)
  ],
  createNodes(e) {
    const o = e[0].value, r = R(e), { c: s = null } = $(e.slice(1, -1)), i = s === null ? null : { type: me, diameter: Number(s) };
    return i ? [{ type: Ve, hole: null, position: r, shape: i, code: o }] : [{ type: Ee, position: r, code: o }];
  }
}, Zt = {
  name: "operationMode",
  rules: [
    D([
      t(y, "0"),
      t(y, "1"),
      t(y, "2"),
      t(y, "3"),
      t(y, "5")
    ]),
    t(S)
  ],
  createNodes: (e) => [
    {
      type: oe,
      position: R(e),
      mode: ae(e)
    }
  ]
}, Wt = {
  name: "operation",
  rules: [
    z(0, 2, [
      t(Q),
      t(y, "0"),
      t(y, "1"),
      t(y, "2"),
      t(y, "3"),
      t(y, "5")
    ]),
    z(2, 8, [t(M), t(C)]),
    j([t(Q)]),
    t(S)
  ],
  createNodes(e) {
    const o = e.filter(
      (P) => P.type === M || P.type === C
    ), r = e.find((P) => P.type === y), s = e.find((P) => P.type === Q), i = $(o), c = s ? s.value : null, f = ae(e), p = R(e, {
      head: o[0],
      length: o.length + 1
    }), N = R(e, { head: r, length: 2 }), O = R(e, { head: s, length: 2 }), T = [
      {
        type: ye,
        position: p,
        graphic: null,
        coordinates: i
      }
    ];
    return f && T.unshift({ type: oe, position: N, mode: f }), c && T.unshift({ type: Ee, position: O, code: c }), T;
  }
}, Yt = {
  name: "slot",
  rules: [
    z(2, 4, [t(M), t(C)]),
    t(y, "85"),
    z(2, 4, [t(M), t(C)]),
    t(S)
  ],
  createNodes(e) {
    const o = e.find((c) => c.type === y), r = o ? e.indexOf(o) : -1, s = Object.fromEntries(
      Object.entries($(e.slice(0, r))).map(
        ([c, f]) => [`${c}0`, f]
      )
    ), i = $(e.slice(r));
    return [
      {
        type: ye,
        position: R(e),
        graphic: Tt,
        coordinates: { ...s, ...i }
      }
    ];
  }
}, Xt = {
  name: "done",
  rules: [
    D([t(B, "30"), t(B, "0")]),
    t(S)
  ],
  createNodes: (e) => [
    { type: ze, position: R(e) }
  ]
}, Kt = {
  name: "header",
  rules: [
    D([t(B, "48"), t(x)]),
    t(S)
  ],
  createNodes: (e) => [
    { type: bt, position: R(e) }
  ]
}, Qt = {
  name: "comment",
  rules: [
    t(we),
    b([F(S)]),
    t(S)
  ],
  createNodes: (e) => [
    {
      type: Fe,
      comment: Re(e.slice(1, -1)),
      position: R(e)
    }
  ]
}, Ze = [
  Vt,
  Zt,
  Wt,
  Yt,
  Qt,
  $t,
  Xt,
  Kt
].map((e) => ({ ...e, filetype: pe })), Jt = {
  name: "macroComment",
  rules: [
    t(C, "0"),
    b([F(g)]),
    t(g)
  ],
  createNodes: tn
}, jt = {
  name: "macroVariable",
  rules: [
    t(J),
    t(Me),
    Be([
      t(C),
      t(k),
      t(J),
      t(M, "X")
    ]),
    t(g)
  ],
  createNodes: rn
}, en = {
  name: "macroPrimitive",
  rules: [
    t(C),
    t(W),
    Be([
      t(W),
      t(C),
      t(k),
      t(J),
      t(M, "X")
    ]),
    t(g)
  ],
  createNodes: nn
};
function tn(e) {
  const o = e.slice(1, -1).map((r) => r.text).join("").trim();
  return [
    { type: Ut, position: R(e), comment: o }
  ];
}
function nn(e) {
  const o = e[0].value, r = [[]];
  let s = r[0];
  for (const c of e.slice(2, -1))
    c.type === W ? (s = [], r.push(s)) : s.push(c);
  const i = r.map(
    (c) => We(c)
  );
  return [
    {
      type: Ft,
      position: R(e),
      code: o,
      parameters: i
    }
  ];
}
function rn(e) {
  const o = e[0].value, r = We(e.slice(2, -1));
  return [
    {
      type: kt,
      position: R(e),
      name: o,
      value: r
    }
  ];
}
function We(e) {
  const o = e.map((f) => f.type === M ? { ...f, type: k, value: "x" } : f);
  return c();
  function r() {
    return o[0] ?? null;
  }
  function s() {
    const f = o.shift();
    if (f.type === C)
      return Number(f.value);
    if (f.type === J)
      return f.value;
    const p = c();
    return o.shift(), p;
  }
  function i() {
    let f = s(), p = r();
    for (; (p == null ? void 0 : p.type) === k && (p.value === "x" || p.value === "/"); )
      o.shift(), f = {
        left: f,
        right: s(),
        operator: p.value
      }, p = r();
    return f;
  }
  function c() {
    let f = i(), p = r();
    for (; (p == null ? void 0 : p.type) === k && (p.value === "+" || p.value === "-") || (p == null ? void 0 : p.type) === C; ) {
      let N = "+";
      p.type === k && (o.shift(), N = p.value);
      const O = i();
      f = { left: f, right: O, operator: N }, p = r();
    }
    return f;
  }
}
const Te = [en, jt, Jt];
function on(e) {
  let o = Te, r = [];
  const s = [];
  for (const i of e) {
    const c = qe([...r, i], o);
    c.nodes && s.push(...c.nodes), r = c.tokens ?? [], o = c.candidates ?? Te;
  }
  return s;
}
const le = (e) => {
  if (e.length === 1) {
    const [o] = e;
    return { type: me, diameter: o };
  }
  if (e.length === 2) {
    const [o, r] = e;
    return { type: De, xSize: o, ySize: r };
  }
  return null;
}, an = {
  name: "done",
  rules: [
    D([t(B, "0"), t(B, "2")]),
    t(g)
  ],
  createNodes: (e) => [
    { type: ze, position: R(e) }
  ]
}, sn = {
  name: "comment",
  rules: [
    t(y, "4"),
    b([F(g)]),
    t(g)
  ],
  createNodes: (e) => [
    {
      type: Fe,
      position: R(e),
      comment: Re(e.slice(1, -1))
    }
  ]
}, ln = {
  name: "format",
  rules: [
    t(x),
    t(ue),
    b([F(M, "X")]),
    t(M, "X"),
    t(C),
    t(M, "Y"),
    t(C),
    b([F(g)]),
    t(g),
    // Including units here is invalid syntax, but Cadence Allegro does it
    // https://github.com/tracespace/tracespace/issues/234
    z(0, 2, [t(ne), t(g)]),
    t(x)
  ],
  createNodes(e) {
    var N;
    let o = null, r = null, s = null;
    const i = $(e), c = e.findIndex((O) => O.type === g), f = e.find((O) => O.type === ne);
    for (const O of e.filter((T) => T.type === ue))
      O.value.includes("T") && (r = Pe), O.value.includes("L") && (r = be), O.value.includes("I") && (s = vt), O.value.includes("A") && (s = mt);
    if (i.x === i.y && ((N = i.x) == null ? void 0 : N.length) === 2) {
      const O = Number(i.x[0]), T = Number(i.x[1]);
      O && T && (o = [O, T]);
    }
    const p = [
      {
        type: $e,
        position: R(e.slice(1, c + 1)),
        zeroSuppression: r,
        format: o,
        mode: s
      }
    ];
    return f && p.push({
      type: ve,
      position: R(e.slice(1, -1), { head: f }),
      units: f.value === "MM" ? he : de
    }), p;
  }
}, cn = {
  name: "units",
  rules: [
    t(x),
    t(ne),
    t(g),
    t(x)
  ],
  createNodes: (e) => [
    {
      type: ve,
      position: R(e.slice(1, -1)),
      units: e[1].value === "MM" ? he : de
    }
  ]
}, un = {
  name: "toolMacro",
  rules: [
    t(x),
    t(Ce),
    t(g),
    b([F(x)]),
    t(x)
  ],
  createNodes(e) {
    const o = e[1].value, r = R(e.slice(1, -1)), s = e.slice(3, -1);
    return [
      {
        type: Pt,
        position: r,
        children: on(s),
        name: o
      }
    ];
  }
}, fn = {
  name: "toolDefinition",
  rules: [
    t(x),
    t(Ne),
    b([
      t(W),
      t(C),
      t(M, "X")
    ]),
    t(g),
    t(x)
  ],
  createNodes(e) {
    let o, r = null;
    const s = /(\d+)(.+)/.exec(e[1].value), [, i = "", c = ""] = s ?? [], f = e.slice(3, -2).filter((p) => p.type === C).map((p) => Number(p.value));
    switch (c) {
      case "C": {
        const [p, ...N] = f;
        o = { type: me, diameter: p }, r = le(N);
        break;
      }
      case "R":
      case "O": {
        const [p, N, ...O] = f;
        o = { type: c === "R" ? De : Et, xSize: p, ySize: N }, r = le(O);
        break;
      }
      case "P": {
        const [p, N, O = null, ...T] = f;
        o = { type: yt, diameter: p, vertices: N, rotation: O }, r = le(T);
        break;
      }
      default:
        o = { type: Rt, name: c, variableValues: f };
    }
    return [
      {
        type: Ve,
        position: R(e.slice(1, -1)),
        code: i,
        shape: o,
        hole: r
      }
    ];
  }
}, pn = {
  name: "toolChange",
  rules: [
    j([t(y, "54")]),
    t(I),
    t(g)
  ],
  createNodes: (e) => [
    {
      type: Ee,
      position: R(e),
      code: e.find((o) => o.type === I).value
    }
  ]
}, Ye = (e) => {
  const o = zt(e), r = $(e), s = ae(e), i = R(e, {
    head: s ? e[1] : e[0]
  }), c = [
    { type: ye, position: i, graphic: o, coordinates: r }
  ];
  if (s) {
    const f = R(e, { head: e[0], length: 2 });
    c.unshift({ type: oe, position: f, mode: s });
  }
  return c;
}, hn = {
  name: "operation",
  rules: [
    j([
      t(y, "1"),
      t(y, "2"),
      t(y, "3")
    ]),
    z(2, 8, [t(M), t(C)]),
    j([
      t(I, "1"),
      t(I, "2"),
      t(I, "3")
    ]),
    t(g)
  ],
  createNodes: Ye
}, dn = {
  name: "operationWithoutCoords",
  rules: [
    j([
      t(y, "1"),
      t(y, "2"),
      t(y, "3")
    ]),
    D([
      t(I, "1"),
      t(I, "2"),
      t(I, "3")
    ]),
    t(g)
  ],
  createNodes: Ye
}, mn = {
  name: "interpolationMode",
  rules: [
    D([
      t(y, "1"),
      t(y, "2"),
      t(y, "3")
    ]),
    t(g)
  ],
  createNodes: (e) => [
    {
      type: oe,
      position: R(e),
      mode: ae(e)
    }
  ]
}, vn = {
  name: "regionMode",
  rules: [
    D([t(y, "36"), t(y, "37")]),
    t(g)
  ],
  createNodes: (e) => [
    {
      type: Bt,
      position: R(e),
      region: e[0].value === "36"
    }
  ]
}, En = {
  name: "quadrantMode",
  rules: [
    D([t(y, "74"), t(y, "75")]),
    t(g)
  ],
  createNodes: (e) => [
    {
      type: qt,
      position: R(e),
      quadrant: e[0].value === "74" ? Nt : _t
    }
  ]
}, yn = {
  name: "loadPolarity",
  rules: [
    t(x),
    t(_e),
    t(g),
    t(x)
  ],
  createNodes: (e) => [
    {
      type: Dt,
      position: R(e.slice(1, -1)),
      polarity: e[1].value === "D" ? xt : wt
    }
  ]
}, Rn = {
  name: "stepRepeat",
  rules: [
    t(x),
    t(xe),
    b([t(M), t(C)]),
    t(g),
    t(x)
  ],
  createNodes(e) {
    const o = $(e), r = Object.fromEntries(
      Object.entries(o).map(([s, i]) => [
        s,
        Number(i)
      ])
    );
    return [
      {
        type: Gt,
        position: R(e.slice(1, -1)),
        stepRepeat: r
      }
    ];
  }
}, On = {
  name: "unimplementedExtendedCommand",
  rules: [
    t(x),
    b([F(g)]),
    t(g),
    t(x)
  ],
  createNodes: (e) => [
    {
      type: Ht,
      position: R(e.slice(1, -1)),
      value: Re(e)
    }
  ]
}, Xe = [
  hn,
  dn,
  mn,
  pn,
  fn,
  un,
  sn,
  vn,
  En,
  yn,
  Rn,
  ln,
  cn,
  an,
  On
].map((e) => ({ ...e, filetype: Se })), gn = [...Xe, ...Ze];
function Tn(e, o = null) {
  const r = [];
  let s = p(), i = [], c = null, f = "";
  for (const [N, O] of e) {
    const T = qe([...i, N], s);
    T.nodes ? (r.push(...T.nodes), c = O, f = "") : f += N.text, o = o ?? T.filetype ?? null, i = T.tokens ?? [], s = T.candidates ?? p();
  }
  return {
    filetype: o,
    unmatched: f,
    nodes: r,
    lexerState: c
  };
  function p() {
    return o === Se ? Xe : o === pe ? Ze : gn;
  }
}
function An() {
  const e = dt(), o = [];
  let r = null, s = null, i = "";
  const c = { lexer: e, feed: f, result: p };
  return c;
  function f(N) {
    const O = e.feed(`${i}${N}`, s), T = Tn(O, r);
    return r = r ?? T.filetype, i = T.unmatched, s = T.lexerState ?? s, o.push(...T.nodes), c;
  }
  function p() {
    if (r === null)
      throw new Error("File type not recognized");
    return { type: St, filetype: r, children: o };
  }
}
function bn(e) {
  return An().feed(e).result();
}
export {
  mt as ABSOLUTE,
  g as ASTERISK,
  ut as CATCHALL,
  Ct as CCW_ARC,
  me as CIRCLE,
  wt as CLEAR,
  W as COMMA,
  Fe as COMMENT,
  $e as COORDINATE_FORMAT,
  M as COORD_CHAR,
  Mt as CW_ARC,
  xt as DARK,
  ze as DONE,
  pe as DRILL,
  bt as DRILL_HEADER,
  Le as DRILL_UNITS,
  fe as DRILL_ZERO_INCLUSION,
  I as D_CODE,
  Me as EQUALS,
  ft as ERROR,
  Se as GERBER,
  ue as GERBER_FORMAT,
  _e as GERBER_LOAD_POLARITY,
  J as GERBER_MACRO_VARIABLE,
  xe as GERBER_STEP_REPEAT,
  Ne as GERBER_TOOL_DEF,
  Ce as GERBER_TOOL_MACRO,
  ne as GERBER_UNITS,
  ye as GRAPHIC,
  y as G_CODE,
  de as IN,
  vt as INCREMENTAL,
  oe as INTERPOLATE_MODE,
  be as LEADING,
  At as LINE,
  Dt as LOAD_POLARITY,
  _n as MACRO_CENTER_LINE,
  Mn as MACRO_CIRCLE,
  Ut as MACRO_COMMENT,
  xn as MACRO_LOWER_LEFT_LINE_DEPRECATED,
  In as MACRO_MOIRE_DEPRECATED,
  wn as MACRO_OUTLINE,
  Ln as MACRO_POLYGON,
  Ft as MACRO_PRIMITIVE,
  Rt as MACRO_SHAPE,
  Sn as MACRO_THERMAL,
  kt as MACRO_VARIABLE,
  Nn as MACRO_VECTOR_LINE,
  Cn as MACRO_VECTOR_LINE_DEPRECATED,
  he as MM,
  Ge as MOVE,
  _t as MULTI,
  B as M_CODE,
  S as NEWLINE,
  C as NUMBER,
  Et as OBROUND,
  k as OPERATOR,
  x as PERCENT,
  yt as POLYGON,
  qt as QUADRANT_MODE,
  De as RECTANGLE,
  Bt as REGION_MODE,
  St as ROOT,
  gt as SEGMENT,
  we as SEMICOLON,
  Ot as SHAPE,
  Nt as SINGLE,
  Tt as SLOT,
  Gt as STEP_REPEAT,
  Ee as TOOL_CHANGE,
  Ve as TOOL_DEFINITION,
  Pt as TOOL_MACRO,
  Pe as TRAILING,
  Q as T_CODE,
  Ht as UNIMPLEMENTED,
  ve as UNITS,
  ct as WHITESPACE,
  lt as WORD,
  dt as createLexer,
  An as createParser,
  bn as parse
};
//# sourceMappingURL=tracespace-parser.js.map
