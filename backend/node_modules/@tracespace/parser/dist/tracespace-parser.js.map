{"version":3,"file":"tracespace-parser.js","sources":["../../../node_modules/.pnpm/moo@0.5.2/node_modules/moo/moo.js","../src/lexer/tokens.ts","../src/lexer/rules.ts","../src/lexer/index.ts","../src/constants.ts","../src/syntax/rules.ts","../src/tree.ts","../src/syntax/map-tokens.ts","../src/syntax/drill.ts","../src/syntax/macro.ts","../src/syntax/gerber.ts","../src/syntax/index.ts","../src/index.ts"],"sourcesContent":["(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], factory) /* global define */\n  } else if (typeof module === 'object' && module.exports) {\n    module.exports = factory()\n  } else {\n    root.moo = factory()\n  }\n}(this, function() {\n  'use strict';\n\n  var hasOwnProperty = Object.prototype.hasOwnProperty\n  var toString = Object.prototype.toString\n  var hasSticky = typeof new RegExp().sticky === 'boolean'\n\n  /***************************************************************************/\n\n  function isRegExp(o) { return o && toString.call(o) === '[object RegExp]' }\n  function isObject(o) { return o && typeof o === 'object' && !isRegExp(o) && !Array.isArray(o) }\n\n  function reEscape(s) {\n    return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\n  }\n  function reGroups(s) {\n    var re = new RegExp('|' + s)\n    return re.exec('').length - 1\n  }\n  function reCapture(s) {\n    return '(' + s + ')'\n  }\n  function reUnion(regexps) {\n    if (!regexps.length) return '(?!)'\n    var source =  regexps.map(function(s) {\n      return \"(?:\" + s + \")\"\n    }).join('|')\n    return \"(?:\" + source + \")\"\n  }\n\n  function regexpOrLiteral(obj) {\n    if (typeof obj === 'string') {\n      return '(?:' + reEscape(obj) + ')'\n\n    } else if (isRegExp(obj)) {\n      // TODO: consider /u support\n      if (obj.ignoreCase) throw new Error('RegExp /i flag not allowed')\n      if (obj.global) throw new Error('RegExp /g flag is implied')\n      if (obj.sticky) throw new Error('RegExp /y flag is implied')\n      if (obj.multiline) throw new Error('RegExp /m flag is implied')\n      return obj.source\n\n    } else {\n      throw new Error('Not a pattern: ' + obj)\n    }\n  }\n\n  function pad(s, length) {\n    if (s.length > length) {\n      return s\n    }\n    return Array(length - s.length + 1).join(\" \") + s\n  }\n\n  function lastNLines(string, numLines) {\n    var position = string.length\n    var lineBreaks = 0;\n    while (true) {\n      var idx = string.lastIndexOf(\"\\n\", position - 1)\n      if (idx === -1) {\n        break;\n      } else {\n        lineBreaks++\n      }\n      position = idx\n      if (lineBreaks === numLines) {\n        break;\n      }\n      if (position === 0) {\n        break;\n      }\n    }\n    var startPosition = \n      lineBreaks < numLines ?\n      0 : \n      position + 1\n    return string.substring(startPosition).split(\"\\n\")\n  }\n\n  function objectToRules(object) {\n    var keys = Object.getOwnPropertyNames(object)\n    var result = []\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      var thing = object[key]\n      var rules = [].concat(thing)\n      if (key === 'include') {\n        for (var j = 0; j < rules.length; j++) {\n          result.push({include: rules[j]})\n        }\n        continue\n      }\n      var match = []\n      rules.forEach(function(rule) {\n        if (isObject(rule)) {\n          if (match.length) result.push(ruleOptions(key, match))\n          result.push(ruleOptions(key, rule))\n          match = []\n        } else {\n          match.push(rule)\n        }\n      })\n      if (match.length) result.push(ruleOptions(key, match))\n    }\n    return result\n  }\n\n  function arrayToRules(array) {\n    var result = []\n    for (var i = 0; i < array.length; i++) {\n      var obj = array[i]\n      if (obj.include) {\n        var include = [].concat(obj.include)\n        for (var j = 0; j < include.length; j++) {\n          result.push({include: include[j]})\n        }\n        continue\n      }\n      if (!obj.type) {\n        throw new Error('Rule has no type: ' + JSON.stringify(obj))\n      }\n      result.push(ruleOptions(obj.type, obj))\n    }\n    return result\n  }\n\n  function ruleOptions(type, obj) {\n    if (!isObject(obj)) {\n      obj = { match: obj }\n    }\n    if (obj.include) {\n      throw new Error('Matching rules cannot also include states')\n    }\n\n    // nb. error and fallback imply lineBreaks\n    var options = {\n      defaultType: type,\n      lineBreaks: !!obj.error || !!obj.fallback,\n      pop: false,\n      next: null,\n      push: null,\n      error: false,\n      fallback: false,\n      value: null,\n      type: null,\n      shouldThrow: false,\n    }\n\n    // Avoid Object.assign(), so we support IE9+\n    for (var key in obj) {\n      if (hasOwnProperty.call(obj, key)) {\n        options[key] = obj[key]\n      }\n    }\n\n    // type transform cannot be a string\n    if (typeof options.type === 'string' && type !== options.type) {\n      throw new Error(\"Type transform cannot be a string (type '\" + options.type + \"' for token '\" + type + \"')\")\n    }\n\n    // convert to array\n    var match = options.match\n    options.match = Array.isArray(match) ? match : match ? [match] : []\n    options.match.sort(function(a, b) {\n      return isRegExp(a) && isRegExp(b) ? 0\n           : isRegExp(b) ? -1 : isRegExp(a) ? +1 : b.length - a.length\n    })\n    return options\n  }\n\n  function toRules(spec) {\n    return Array.isArray(spec) ? arrayToRules(spec) : objectToRules(spec)\n  }\n\n  var defaultErrorRule = ruleOptions('error', {lineBreaks: true, shouldThrow: true})\n  function compileRules(rules, hasStates) {\n    var errorRule = null\n    var fast = Object.create(null)\n    var fastAllowed = true\n    var unicodeFlag = null\n    var groups = []\n    var parts = []\n\n    // If there is a fallback rule, then disable fast matching\n    for (var i = 0; i < rules.length; i++) {\n      if (rules[i].fallback) {\n        fastAllowed = false\n      }\n    }\n\n    for (var i = 0; i < rules.length; i++) {\n      var options = rules[i]\n\n      if (options.include) {\n        // all valid inclusions are removed by states() preprocessor\n        throw new Error('Inheritance is not allowed in stateless lexers')\n      }\n\n      if (options.error || options.fallback) {\n        // errorRule can only be set once\n        if (errorRule) {\n          if (!options.fallback === !errorRule.fallback) {\n            throw new Error(\"Multiple \" + (options.fallback ? \"fallback\" : \"error\") + \" rules not allowed (for token '\" + options.defaultType + \"')\")\n          } else {\n            throw new Error(\"fallback and error are mutually exclusive (for token '\" + options.defaultType + \"')\")\n          }\n        }\n        errorRule = options\n      }\n\n      var match = options.match.slice()\n      if (fastAllowed) {\n        while (match.length && typeof match[0] === 'string' && match[0].length === 1) {\n          var word = match.shift()\n          fast[word.charCodeAt(0)] = options\n        }\n      }\n\n      // Warn about inappropriate state-switching options\n      if (options.pop || options.push || options.next) {\n        if (!hasStates) {\n          throw new Error(\"State-switching options are not allowed in stateless lexers (for token '\" + options.defaultType + \"')\")\n        }\n        if (options.fallback) {\n          throw new Error(\"State-switching options are not allowed on fallback tokens (for token '\" + options.defaultType + \"')\")\n        }\n      }\n\n      // Only rules with a .match are included in the RegExp\n      if (match.length === 0) {\n        continue\n      }\n      fastAllowed = false\n\n      groups.push(options)\n\n      // Check unicode flag is used everywhere or nowhere\n      for (var j = 0; j < match.length; j++) {\n        var obj = match[j]\n        if (!isRegExp(obj)) {\n          continue\n        }\n\n        if (unicodeFlag === null) {\n          unicodeFlag = obj.unicode\n        } else if (unicodeFlag !== obj.unicode && options.fallback === false) {\n          throw new Error('If one rule is /u then all must be')\n        }\n      }\n\n      // convert to RegExp\n      var pat = reUnion(match.map(regexpOrLiteral))\n\n      // validate\n      var regexp = new RegExp(pat)\n      if (regexp.test(\"\")) {\n        throw new Error(\"RegExp matches empty string: \" + regexp)\n      }\n      var groupCount = reGroups(pat)\n      if (groupCount > 0) {\n        throw new Error(\"RegExp has capture groups: \" + regexp + \"\\nUse (?: â€¦ ) instead\")\n      }\n\n      // try and detect rules matching newlines\n      if (!options.lineBreaks && regexp.test('\\n')) {\n        throw new Error('Rule should declare lineBreaks: ' + regexp)\n      }\n\n      // store regex\n      parts.push(reCapture(pat))\n    }\n\n\n    // If there's no fallback rule, use the sticky flag so we only look for\n    // matches at the current index.\n    //\n    // If we don't support the sticky flag, then fake it using an irrefutable\n    // match (i.e. an empty pattern).\n    var fallbackRule = errorRule && errorRule.fallback\n    var flags = hasSticky && !fallbackRule ? 'ym' : 'gm'\n    var suffix = hasSticky || fallbackRule ? '' : '|'\n\n    if (unicodeFlag === true) flags += \"u\"\n    var combined = new RegExp(reUnion(parts) + suffix, flags)\n    return {regexp: combined, groups: groups, fast: fast, error: errorRule || defaultErrorRule}\n  }\n\n  function compile(rules) {\n    var result = compileRules(toRules(rules))\n    return new Lexer({start: result}, 'start')\n  }\n\n  function checkStateGroup(g, name, map) {\n    var state = g && (g.push || g.next)\n    if (state && !map[state]) {\n      throw new Error(\"Missing state '\" + state + \"' (in token '\" + g.defaultType + \"' of state '\" + name + \"')\")\n    }\n    if (g && g.pop && +g.pop !== 1) {\n      throw new Error(\"pop must be 1 (in token '\" + g.defaultType + \"' of state '\" + name + \"')\")\n    }\n  }\n  function compileStates(states, start) {\n    var all = states.$all ? toRules(states.$all) : []\n    delete states.$all\n\n    var keys = Object.getOwnPropertyNames(states)\n    if (!start) start = keys[0]\n\n    var ruleMap = Object.create(null)\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      ruleMap[key] = toRules(states[key]).concat(all)\n    }\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      var rules = ruleMap[key]\n      var included = Object.create(null)\n      for (var j = 0; j < rules.length; j++) {\n        var rule = rules[j]\n        if (!rule.include) continue\n        var splice = [j, 1]\n        if (rule.include !== key && !included[rule.include]) {\n          included[rule.include] = true\n          var newRules = ruleMap[rule.include]\n          if (!newRules) {\n            throw new Error(\"Cannot include nonexistent state '\" + rule.include + \"' (in state '\" + key + \"')\")\n          }\n          for (var k = 0; k < newRules.length; k++) {\n            var newRule = newRules[k]\n            if (rules.indexOf(newRule) !== -1) continue\n            splice.push(newRule)\n          }\n        }\n        rules.splice.apply(rules, splice)\n        j--\n      }\n    }\n\n    var map = Object.create(null)\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      map[key] = compileRules(ruleMap[key], true)\n    }\n\n    for (var i = 0; i < keys.length; i++) {\n      var name = keys[i]\n      var state = map[name]\n      var groups = state.groups\n      for (var j = 0; j < groups.length; j++) {\n        checkStateGroup(groups[j], name, map)\n      }\n      var fastKeys = Object.getOwnPropertyNames(state.fast)\n      for (var j = 0; j < fastKeys.length; j++) {\n        checkStateGroup(state.fast[fastKeys[j]], name, map)\n      }\n    }\n\n    return new Lexer(map, start)\n  }\n\n  function keywordTransform(map) {\n\n    // Use a JavaScript Map to map keywords to their corresponding token type\n    // unless Map is unsupported, then fall back to using an Object:\n    var isMap = typeof Map !== 'undefined'\n    var reverseMap = isMap ? new Map : Object.create(null)\n\n    var types = Object.getOwnPropertyNames(map)\n    for (var i = 0; i < types.length; i++) {\n      var tokenType = types[i]\n      var item = map[tokenType]\n      var keywordList = Array.isArray(item) ? item : [item]\n      keywordList.forEach(function(keyword) {\n        if (typeof keyword !== 'string') {\n          throw new Error(\"keyword must be string (in keyword '\" + tokenType + \"')\")\n        }\n        if (isMap) {\n          reverseMap.set(keyword, tokenType)\n        } else {\n          reverseMap[keyword] = tokenType\n        }\n      })\n    }\n    return function(k) {\n      return isMap ? reverseMap.get(k) : reverseMap[k]\n    }\n  }\n\n  /***************************************************************************/\n\n  var Lexer = function(states, state) {\n    this.startState = state\n    this.states = states\n    this.buffer = ''\n    this.stack = []\n    this.reset()\n  }\n\n  Lexer.prototype.reset = function(data, info) {\n    this.buffer = data || ''\n    this.index = 0\n    this.line = info ? info.line : 1\n    this.col = info ? info.col : 1\n    this.queuedToken = info ? info.queuedToken : null\n    this.queuedText = info ? info.queuedText: \"\";\n    this.queuedThrow = info ? info.queuedThrow : null\n    this.setState(info ? info.state : this.startState)\n    this.stack = info && info.stack ? info.stack.slice() : []\n    return this\n  }\n\n  Lexer.prototype.save = function() {\n    return {\n      line: this.line,\n      col: this.col,\n      state: this.state,\n      stack: this.stack.slice(),\n      queuedToken: this.queuedToken,\n      queuedText: this.queuedText,\n      queuedThrow: this.queuedThrow,\n    }\n  }\n\n  Lexer.prototype.setState = function(state) {\n    if (!state || this.state === state) return\n    this.state = state\n    var info = this.states[state]\n    this.groups = info.groups\n    this.error = info.error\n    this.re = info.regexp\n    this.fast = info.fast\n  }\n\n  Lexer.prototype.popState = function() {\n    this.setState(this.stack.pop())\n  }\n\n  Lexer.prototype.pushState = function(state) {\n    this.stack.push(this.state)\n    this.setState(state)\n  }\n\n  var eat = hasSticky ? function(re, buffer) { // assume re is /y\n    return re.exec(buffer)\n  } : function(re, buffer) { // assume re is /g\n    var match = re.exec(buffer)\n    // will always match, since we used the |(?:) trick\n    if (match[0].length === 0) {\n      return null\n    }\n    return match\n  }\n\n  Lexer.prototype._getGroup = function(match) {\n    var groupCount = this.groups.length\n    for (var i = 0; i < groupCount; i++) {\n      if (match[i + 1] !== undefined) {\n        return this.groups[i]\n      }\n    }\n    throw new Error('Cannot find token type for matched text')\n  }\n\n  function tokenToString() {\n    return this.value\n  }\n\n  Lexer.prototype.next = function() {\n    var index = this.index\n\n    // If a fallback token matched, we don't need to re-run the RegExp\n    if (this.queuedGroup) {\n      var token = this._token(this.queuedGroup, this.queuedText, index)\n      this.queuedGroup = null\n      this.queuedText = \"\"\n      return token\n    }\n\n    var buffer = this.buffer\n    if (index === buffer.length) {\n      return // EOF\n    }\n\n    // Fast matching for single characters\n    var group = this.fast[buffer.charCodeAt(index)]\n    if (group) {\n      return this._token(group, buffer.charAt(index), index)\n    }\n\n    // Execute RegExp\n    var re = this.re\n    re.lastIndex = index\n    var match = eat(re, buffer)\n\n    // Error tokens match the remaining buffer\n    var error = this.error\n    if (match == null) {\n      return this._token(error, buffer.slice(index, buffer.length), index)\n    }\n\n    var group = this._getGroup(match)\n    var text = match[0]\n\n    if (error.fallback && match.index !== index) {\n      this.queuedGroup = group\n      this.queuedText = text\n\n      // Fallback tokens contain the unmatched portion of the buffer\n      return this._token(error, buffer.slice(index, match.index), index)\n    }\n\n    return this._token(group, text, index)\n  }\n\n  Lexer.prototype._token = function(group, text, offset) {\n    // count line breaks\n    var lineBreaks = 0\n    if (group.lineBreaks) {\n      var matchNL = /\\n/g\n      var nl = 1\n      if (text === '\\n') {\n        lineBreaks = 1\n      } else {\n        while (matchNL.exec(text)) { lineBreaks++; nl = matchNL.lastIndex }\n      }\n    }\n\n    var token = {\n      type: (typeof group.type === 'function' && group.type(text)) || group.defaultType,\n      value: typeof group.value === 'function' ? group.value(text) : text,\n      text: text,\n      toString: tokenToString,\n      offset: offset,\n      lineBreaks: lineBreaks,\n      line: this.line,\n      col: this.col,\n    }\n    // nb. adding more props to token object will make V8 sad!\n\n    var size = text.length\n    this.index += size\n    this.line += lineBreaks\n    if (lineBreaks !== 0) {\n      this.col = size - nl + 1\n    } else {\n      this.col += size\n    }\n\n    // throw, if no rule with {error: true}\n    if (group.shouldThrow) {\n      var err = new Error(this.formatError(token, \"invalid syntax\"))\n      throw err;\n    }\n\n    if (group.pop) this.popState()\n    else if (group.push) this.pushState(group.push)\n    else if (group.next) this.setState(group.next)\n\n    return token\n  }\n\n  if (typeof Symbol !== 'undefined' && Symbol.iterator) {\n    var LexerIterator = function(lexer) {\n      this.lexer = lexer\n    }\n\n    LexerIterator.prototype.next = function() {\n      var token = this.lexer.next()\n      return {value: token, done: !token}\n    }\n\n    LexerIterator.prototype[Symbol.iterator] = function() {\n      return this\n    }\n\n    Lexer.prototype[Symbol.iterator] = function() {\n      return new LexerIterator(this)\n    }\n  }\n\n  Lexer.prototype.formatError = function(token, message) {\n    if (token == null) {\n      // An undefined token indicates EOF\n      var text = this.buffer.slice(this.index)\n      var token = {\n        text: text,\n        offset: this.index,\n        lineBreaks: text.indexOf('\\n') === -1 ? 0 : 1,\n        line: this.line,\n        col: this.col,\n      }\n    }\n    \n    var numLinesAround = 2\n    var firstDisplayedLine = Math.max(token.line - numLinesAround, 1)\n    var lastDisplayedLine = token.line + numLinesAround\n    var lastLineDigits = String(lastDisplayedLine).length\n    var displayedLines = lastNLines(\n        this.buffer, \n        (this.line - token.line) + numLinesAround + 1\n      )\n      .slice(0, 5)\n    var errorLines = []\n    errorLines.push(message + \" at line \" + token.line + \" col \" + token.col + \":\")\n    errorLines.push(\"\")\n    for (var i = 0; i < displayedLines.length; i++) {\n      var line = displayedLines[i]\n      var lineNo = firstDisplayedLine + i\n      errorLines.push(pad(String(lineNo), lastLineDigits) + \"  \" + line);\n      if (lineNo === token.line) {\n        errorLines.push(pad(\"\", lastLineDigits + token.col + 1) + \"^\")\n      }\n    }\n    return errorLines.join(\"\\n\")\n  }\n\n  Lexer.prototype.clone = function() {\n    return new Lexer(this.states, this.state)\n  }\n\n  Lexer.prototype.has = function(tokenType) {\n    return true\n  }\n\n\n  return {\n    compile: compile,\n    states: compileStates,\n    error: Object.freeze({error: true}),\n    fallback: Object.freeze({fallback: true}),\n    keywords: keywordTransform,\n  }\n\n}));\n","import type {Token as MooToken} from 'moo'\n\n/**\n * T-code token type\n *\n * @category Lexer\n */\nexport const T_CODE = 'T_CODE'\n\n/**\n * G-code token type\n *\n * @category Lexer\n */\nexport const G_CODE = 'G_CODE'\n\n/**\n * M-code token type\n *\n * @category Lexer\n */\nexport const M_CODE = 'M_CODE'\n\n/**\n * D-code token type\n *\n * @category Lexer\n */\nexport const D_CODE = 'D_CODE'\n\n/**\n * Asterisk token type\n *\n * @category Lexer\n */\nexport const ASTERISK = 'ASTERISK'\n\n/**\n * Percent sign token type\n *\n * @category Lexer\n */\nexport const PERCENT = 'PERCENT'\n\n/**\n * Equals sign token type\n *\n * @category Lexer\n */\nexport const EQUALS = 'EQUALS'\n\n/**\n * Comma token type\n *\n * @category Lexer\n */\nexport const COMMA = 'COMMA'\n\n/**\n * Arithmatic operator token type\n *\n * @category Lexer\n */\nexport const OPERATOR = 'OPERATOR'\n\n/**\n * Gerber format specification token type\n *\n * @category Lexer\n */\nexport const GERBER_FORMAT = 'GERBER_FORMAT'\n\n/**\n * Gerber units specification token type\n *\n * @category Lexer\n */\nexport const GERBER_UNITS = 'GERBER_UNITS'\n\n/**\n * Gerber tool macro token type\n *\n * @category Lexer\n */\nexport const GERBER_TOOL_MACRO = 'GERBER_TOOL_MACRO'\n\n/**\n * Gerber tool definition token type\n *\n * @category Lexer\n */\nexport const GERBER_TOOL_DEF = 'GERBER_TOOL_DEF'\n\n/**\n * Gerber load polarity token type\n *\n * @category Lexer\n */\nexport const GERBER_LOAD_POLARITY = 'GERBER_LOAD_POLARITY'\n\n/**\n * Gerber step repear token type\n *\n * @category Lexer\n */\nexport const GERBER_STEP_REPEAT = 'GERBER_STEP_REPEAT'\n\n/**\n * Gerber macro variable token type\n *\n * @category Lexer\n */\nexport const GERBER_MACRO_VARIABLE = 'GERBER_MACRO_VARIABLE'\n\n/**\n * Semicolor token type\n *\n * @category Lexer\n */\nexport const SEMICOLON = 'SEMICOLON'\n\n/**\n * Drill file units token type\n *\n * @category Lexer\n */\nexport const DRILL_UNITS = 'DRILL_UNITS'\n\n/**\n * Drill zero-inclusion token type\n *\n * @category Lexer\n */\nexport const DRILL_ZERO_INCLUSION = 'DRILL_ZERO_INCLUSION'\n\n/**\n * Coordinate axis character token type\n *\n * @category Lexer\n */\nexport const COORD_CHAR = 'COORD_CHAR'\n\n/**\n * Number token type\n *\n * @category Lexer\n */\nexport const NUMBER = 'NUMBER'\n\n/**\n * Word token type\n *\n * @category Lexer\n */\nexport const WORD = 'WORD'\n\n/**\n * Whitespace token type\n *\n * @category Lexer\n */\nexport const WHITESPACE = 'WHITESPACE'\n\n/**\n * Newline token type\n *\n * @category Lexer\n */\nexport const NEWLINE = 'NEWLINE'\n\n/**\n * Catchall token type\n *\n * @category Lexer\n */\nexport const CATCHALL = 'CATCHALL'\n\n/**\n * Error token type\n *\n * @category Lexer\n */\nexport const ERROR = 'ERROR'\n\n/**\n * Union of all available token types\n *\n * @category Lexer\n */\nexport type TokenType =\n  | typeof T_CODE\n  | typeof G_CODE\n  | typeof M_CODE\n  | typeof D_CODE\n  | typeof ASTERISK\n  | typeof PERCENT\n  | typeof EQUALS\n  | typeof COMMA\n  | typeof OPERATOR\n  | typeof GERBER_FORMAT\n  | typeof GERBER_UNITS\n  | typeof GERBER_TOOL_MACRO\n  | typeof GERBER_TOOL_DEF\n  | typeof GERBER_LOAD_POLARITY\n  | typeof GERBER_STEP_REPEAT\n  | typeof GERBER_MACRO_VARIABLE\n  | typeof SEMICOLON\n  | typeof DRILL_UNITS\n  | typeof DRILL_ZERO_INCLUSION\n  | typeof COORD_CHAR\n  | typeof NUMBER\n  | typeof WORD\n  | typeof WHITESPACE\n  | typeof NEWLINE\n  | typeof CATCHALL\n  | typeof ERROR\n\n/**\n * {@linkcode Lexer} token\n *\n * @category Lexer\n */\nexport interface Token extends MooToken {\n  /** Token identifier */\n  type: TokenType\n}\n","import Moo from 'moo'\nimport * as Tokens from './tokens'\n\nexport type Rules = {\n  [t in Tokens.TokenType]: RegExp | string | string[] | Moo.Rule | Moo.Rule[]\n}\n\nconst RE_STRIP_LEADING_ZEROS = /^0*/\n\nconst stripLeadingZeros = (text: string): string => {\n  return text.replace(RE_STRIP_LEADING_ZEROS, '')\n}\n\nconst getCodeValue = (text: string): string => {\n  return stripLeadingZeros(text.slice(1)) || '0'\n}\n\nexport const rules: Rules = {\n  [Tokens.T_CODE]: {\n    match: /T\\d+/,\n    value: getCodeValue,\n  },\n  [Tokens.G_CODE]: {\n    match: /G\\d+/,\n    value: getCodeValue,\n  },\n  [Tokens.M_CODE]: {\n    match: /M\\d+/,\n    value: getCodeValue,\n  },\n  [Tokens.D_CODE]: {\n    match: /D\\d+/,\n    value: getCodeValue,\n  },\n  [Tokens.ASTERISK]: '*',\n  [Tokens.PERCENT]: '%',\n  [Tokens.EQUALS]: '=',\n  [Tokens.GERBER_FORMAT]: {\n    match: /FS[LTDAI]+/,\n    value: (text: string): string => text.slice(2),\n  },\n  [Tokens.GERBER_UNITS]: {\n    match: /MO(?:IN|MM)/,\n    value: (text: string): string => text.slice(2),\n  },\n  [Tokens.GERBER_TOOL_MACRO]: {\n    // \"-\" in a tool name is illegal, but some gerber writers misbehave\n    // https://github.com/mcous/gerber-parser/pull/13\n    match: /AM[a-zA-Z_.$][\\w.-]*/,\n    value: (text: string): string => text.slice(2),\n  },\n  [Tokens.GERBER_TOOL_DEF]: {\n    match: /ADD\\d+[a-zA-Z_.$][\\w.-]*/,\n    value: (text: string): string => stripLeadingZeros(text.slice(3)),\n  },\n  [Tokens.GERBER_LOAD_POLARITY]: {\n    match: /LP[DC]/,\n    value: (text: string): string => text.slice(2),\n  },\n  [Tokens.GERBER_STEP_REPEAT]: 'SR',\n  [Tokens.GERBER_MACRO_VARIABLE]: /\\$\\d+/,\n  [Tokens.SEMICOLON]: ';',\n  [Tokens.DRILL_UNITS]: /^(?:METRIC|INCH)/,\n  [Tokens.DRILL_ZERO_INCLUSION]: {\n    match: /,(?:TZ|LZ)/,\n    value: (text: string): string => text.slice(1),\n  },\n  [Tokens.COORD_CHAR]: /[XYIJACFSBHZN]/,\n  [Tokens.NUMBER]: /[+-]?[\\d.]+/,\n  [Tokens.OPERATOR]: ['x', '/', '+', '-', '(', ')'],\n  [Tokens.COMMA]: ',',\n  [Tokens.WORD]: /[a-zA-Z]+/,\n  [Tokens.WHITESPACE]: /[ \\t]+/,\n  [Tokens.NEWLINE]: {\n    match: /\\r?\\n/,\n    lineBreaks: true,\n  },\n  [Tokens.CATCHALL]: /\\S/,\n  [Tokens.ERROR]: Moo.error,\n}\n","// Gerber and drill file lexer + tokenizer\nimport Moo from 'moo'\nimport type {Token} from './tokens'\nimport {rules} from './rules'\n\nexport * from './tokens'\n\nexport interface LexerState extends Moo.LexerState {\n  offset: number\n}\n\nexport interface LexerIterable extends Iterable<[Token, LexerState]> {}\n\n/**\n * The lexing module of the parser.\n *\n * @category Lexer\n */\nexport interface Lexer {\n  feed(chunk: string, state?: LexerState | null): LexerIterable\n}\n\n/**\n * {@linkcode Lexer} factory\n *\n * @example\n * ```ts\n * import {createLexer} from '@tracespace/parser'\n *\n * const lexer = createLexer()\n * const tokens = lexer.feed('G04 gerber string*\\nM02*\\n')\n *\n * for (const token of tokens) {\n *   console.log(`${token.type}: ${token.value}`)\n * }\n * ```\n *\n * @category Lexer\n */\nexport function createLexer(): Lexer {\n  const mooLexer = Moo.compile(rules)\n\n  return {feed}\n\n  function feed(chunk: string, state: LexerState | null = null): LexerIterable {\n    mooLexer.reset(chunk, state ?? undefined)\n    return tokenIterator(state?.offset ?? 0)\n  }\n\n  function tokenIterator(\n    offset: number\n  ): LexerIterable & Iterator<[Token, LexerState]> {\n    return {\n      [Symbol.iterator]() {\n        return this\n      },\n\n      next() {\n        const token = mooLexer.next() as Token | undefined\n\n        if (token) {\n          const nextToken = {...token, offset: offset + token.offset}\n          const nextState = {\n            ...mooLexer.save(),\n            offset: offset + (mooLexer.index ?? 0),\n          }\n\n          return {value: [nextToken, nextState]}\n        }\n\n        return {value: undefined, done: true}\n      },\n    }\n  }\n}\n\ndeclare module 'moo' {\n  export interface Lexer {\n    index?: number\n  }\n}\n","// Common constants\n\n// filetype constants\nexport const GERBER = 'gerber'\nexport const DRILL = 'drill'\n\n// Units constants\nexport const MM = 'mm'\nexport const IN = 'in'\n\n// Format constants\nexport const LEADING = 'leading'\nexport const TRAILING = 'trailing'\nexport const ABSOLUTE = 'absolute'\nexport const INCREMENTAL = 'incremental'\n\n// Tool constants\nexport const CIRCLE = 'circle'\nexport const RECTANGLE = 'rectangle'\nexport const OBROUND = 'obround'\nexport const POLYGON = 'polygon'\nexport const MACRO_SHAPE = 'macroShape'\n\n// Macro primitive codes\nexport const MACRO_CIRCLE = '1'\nexport const MACRO_VECTOR_LINE_DEPRECATED = '2'\nexport const MACRO_VECTOR_LINE = '20'\nexport const MACRO_CENTER_LINE = '21'\nexport const MACRO_LOWER_LEFT_LINE_DEPRECATED = '22'\nexport const MACRO_OUTLINE = '4'\nexport const MACRO_POLYGON = '5'\nexport const MACRO_MOIRE_DEPRECATED = '6'\nexport const MACRO_THERMAL = '7'\n\n// Drawing constants\nexport const SHAPE = 'shape'\nexport const MOVE = 'move'\nexport const SEGMENT = 'segment'\nexport const SLOT = 'slot'\n\n// Interpolation / routing constants\nexport const LINE = 'line'\nexport const CW_ARC = 'cwArc'\nexport const CCW_ARC = 'ccwArc'\n\n// Quadrant mode\nexport const SINGLE = 'single'\nexport const MULTI = 'multi'\n\n// Load polarity\nexport const DARK = 'dark'\nexport const CLEAR = 'clear'\n","import type {Token} from '../lexer'\nimport type {Filetype} from '../types'\nimport type {GerberNode} from '../tree'\n\nexport const SINGLE_TOKEN = 'TOKEN'\nexport const MIN_TO_MAX = 'MIN_TO_MAX'\n\nexport interface SyntaxRule<Node = GerberNode> {\n  name: string\n  rules: TokenRule[]\n  createNodes: (tokens: Token[]) => Node[]\n  filetype?: Filetype\n}\n\nexport type TokenRule = SingleTokenRule | MinToMaxRule\n\nexport interface SingleTokenRule {\n  rule: typeof SINGLE_TOKEN\n  type: Token['type']\n  value: Token['value'] | RegExp | null | undefined\n  negate?: boolean\n}\n\nexport interface MinToMaxRule {\n  rule: typeof MIN_TO_MAX\n  min: number\n  max: number\n  match: SingleTokenRule[]\n}\n\nexport function token(\n  type: Token['type'],\n  value?: Token['value'] | RegExp\n): SingleTokenRule {\n  return {rule: SINGLE_TOKEN, type, value}\n}\n\nexport function notToken(\n  type: Token['type'],\n  value?: Token['value']\n): SingleTokenRule {\n  return {rule: SINGLE_TOKEN, type, value, negate: true}\n}\n\nexport function one(match: SingleTokenRule[]): MinToMaxRule {\n  return {rule: MIN_TO_MAX, min: 1, max: 1, match}\n}\n\nexport function zeroOrOne(match: SingleTokenRule[]): MinToMaxRule {\n  return {rule: MIN_TO_MAX, min: 0, max: 1, match}\n}\n\nexport function zeroOrMore(match: SingleTokenRule[]): MinToMaxRule {\n  return {rule: MIN_TO_MAX, min: 0, max: Number.POSITIVE_INFINITY, match}\n}\n\nexport function oneOrMore(match: SingleTokenRule[]): MinToMaxRule {\n  return {rule: MIN_TO_MAX, min: 1, max: Number.POSITIVE_INFINITY, match}\n}\n\nexport function minToMax(\n  min: number,\n  max: number,\n  match: SingleTokenRule[]\n): MinToMaxRule {\n  return {rule: MIN_TO_MAX, min, max, match}\n}\n\nexport interface MatchSearchResult<Node> {\n  filetype?: Filetype\n  nodes?: Node[]\n  tokens?: Token[]\n  candidates?: Array<SyntaxRule<Node>>\n}\n\nexport function findSyntaxMatch<Node>(\n  tokens: Token[],\n  candidates: Array<SyntaxRule<Node>>\n): MatchSearchResult<Node> {\n  const remainingCandidates: Array<SyntaxRule<Node>> = []\n\n  for (const candidate of candidates) {\n    const matchType = tokenListMatches(tokens, candidate.rules)\n\n    if (matchType === PARTIAL_MATCH) {\n      remainingCandidates.push(candidate)\n    } else if (matchType === FULL_MATCH) {\n      return {\n        filetype: candidate.filetype,\n        nodes: candidate.createNodes(tokens),\n      }\n    }\n  }\n\n  return remainingCandidates.length > 0\n    ? {candidates: remainingCandidates, tokens}\n    : {}\n}\n\nconst FULL_MATCH = 'FULL_MATCH'\nconst PARTIAL_MATCH = 'PARTIAL_MATCH'\nconst NO_MATCH = 'NO_MATCH'\n\ntype TokenMatchType = typeof FULL_MATCH | typeof PARTIAL_MATCH | typeof NO_MATCH\n\nfunction tokenListMatches(tokens: Token[], rules: TokenRule[]): TokenMatchType {\n  let i = 0\n  let j = 0\n  let multiMatchCount = 0\n\n  while (i < rules.length && j < tokens.length) {\n    const rule = rules[i]\n    const token = tokens[j]\n    const match = tokenMatches(rule, token)\n\n    if (match) {\n      if (\n        rule.rule === SINGLE_TOKEN ||\n        (rule.rule === MIN_TO_MAX && multiMatchCount >= rule.max - 1)\n      ) {\n        i++\n        j++\n        multiMatchCount = 0\n      } else if (rule.rule === MIN_TO_MAX) {\n        j++\n        multiMatchCount++\n      }\n    } else if (rule.rule === MIN_TO_MAX && multiMatchCount >= rule.min) {\n      multiMatchCount = 0\n      i++\n    } else {\n      return NO_MATCH\n    }\n  }\n\n  if (i < rules.length) return PARTIAL_MATCH\n  return FULL_MATCH\n}\n\nfunction tokenMatches(rule: TokenRule, token: Token): boolean {\n  if (rule.rule === SINGLE_TOKEN) {\n    const typeResult = rule.type === token.type\n    const valueResult =\n      rule.value === null ||\n      typeof rule.value === 'undefined' ||\n      (typeof rule.value === 'string' && rule.value === token.value) ||\n      (rule.value instanceof RegExp && rule.value.test(token.value))\n\n    const result = typeResult && valueResult\n\n    return rule.negate ? !result : result\n  }\n\n  if (Array.isArray(rule.match)) {\n    return rule.match.some(match => tokenMatches(match, token))\n  }\n\n  return false\n}\n","import type {Position} from 'unist'\n\nimport type * as Types from './types'\n\n/**\n * {@linkcode Root} node type\n *\n * @category Node\n */\nexport const ROOT = 'root'\n\n/**\n * {@linkcode Comment} node type\n *\n * @category Node\n */\nexport const COMMENT = 'comment'\n\n/**\n * {@linkcode DrillHeader} node type\n *\n * @category Node\n */\nexport const DRILL_HEADER = 'drillHeader'\n\n/**\n * {@linkcode Done} node type\n *\n * @category Node\n */\nexport const DONE = 'done'\n\n/**\n * {@linkcode Units} node type\n *\n * @category Node\n */\nexport const UNITS = 'units'\n\n/**\n * {@linkcode CoordinateFormat} node type\n *\n * @category Node\n */\nexport const COORDINATE_FORMAT = 'coordinateFormat'\n\n/**\n * {@linkcode ToolDefinition} node type\n *\n * @category Node\n */\nexport const TOOL_DEFINITION = 'toolDefinition'\n\n/**\n * {@linkcode ToolMacro} node type\n *\n * @category Node\n */\nexport const TOOL_MACRO = 'toolMacro'\n\n/**\n * {@linkcode ToolChange} node type\n *\n * @category Node\n */\nexport const TOOL_CHANGE = 'toolChange'\n\n/**\n * {@linkcode LoadPolarity} node type\n *\n * @category Node\n */\nexport const LOAD_POLARITY = 'loadPolarity'\n\n/**\n * {@linkcode StepRepeat} node type\n *\n * @category Node\n */\nexport const STEP_REPEAT = 'stepRepeat'\n\n/**\n * {@linkcode Graphic} node type\n *\n * @category Node\n */\nexport const GRAPHIC = 'graphic'\n\n/**\n * {@linkcode InterpolateMode} node type\n *\n * @category Node\n */\nexport const INTERPOLATE_MODE = 'interpolateMode'\n\n/**\n * {@linkcode RegionMode} node type\n *\n * @category Node\n */\nexport const REGION_MODE = 'regionMode'\n\n/**\n * {@linkcode QuadrantMode} node type\n *\n * @category Node\n */\nexport const QUADRANT_MODE = 'quadrantMode'\n\n/**\n * {@linkcode Unimplemented} node type\n *\n * @category Node\n */\nexport const UNIMPLEMENTED = 'unimplemented'\n\n/**\n * {@linkcode MacroComment} node type\n *\n * @category Macro\n */\nexport const MACRO_COMMENT = 'macroComment'\n\n/**\n * {@linkcode MacroVariable} node type\n *\n * @category Macro\n */\nexport const MACRO_VARIABLE = 'macroVariable'\n\n/**\n * {@linkcode MacroPrimitive} node type\n *\n * @category Macro\n */\nexport const MACRO_PRIMITIVE = 'macroPrimitive'\n\ninterface BaseNode {\n  type: string\n  /** Location in the source file the node was parsed from */\n  position?: Position\n}\n\ninterface BaseParent extends BaseNode {\n  children: BaseNode[]\n}\n\n/**\n * Syntax tree node\n *\n * @category Node\n */\nexport type Node = Root | ChildNode\n\n/**\n * Child of the tree's {@linkcode Root} node\n *\n * @category Node\n */\nexport type ChildNode =\n  | Comment\n  | DrillHeader\n  | Done\n  | Units\n  | CoordinateFormat\n  | ToolDefinition\n  | ToolMacro\n  | ToolChange\n  | InterpolateMode\n  | RegionMode\n  | QuadrantMode\n  | LoadPolarity\n  | StepRepeat\n  | Graphic\n  | Unimplemented\n\n/**\n * Child of a {@linkcode ToolMacro} node\n *\n * @category Macro\n */\nexport type MacroBlock = MacroComment | MacroVariable | MacroPrimitive\n\n/**\n * Root node of the syntax tree, identifying the filetype and whether or not\n * the entire file seems to have been read. Filetype, if known, will be\n * either {@linkcode GERBER | gerber} or {@linkcode DRILL | drill}.\n *\n * If `filetype` is `null` or `done` is `false`, this may be a sign that\n *\n * 1. the parser has not finished parsing the file or\n * 2. the file is invalid and/or not a Gerber or drill file.\n *\n * @category Node\n */\nexport interface Root extends BaseParent {\n  /** Node type */\n  type: typeof ROOT\n  /** The parsed file's type (Gerber or NC drill), if known */\n  filetype: Types.Filetype\n\n  /** Parse results */\n  children: ChildNode[]\n}\n\n/**\n * Node representing a comment in the file. Usually, comment nodes can be\n * ignored, but in NC drill files, they may contain important format\n * specifications that are not able to be expressed in the file itself.\n *\n *  @category Node\n */\nexport interface Comment extends BaseNode {\n  /** Node type */\n  type: typeof COMMENT\n  /** Contents of the comment as a string */\n  comment: string\n}\n\n/**\n * Node representing drill file's header start or end.\n *\n *  @category Node\n */\nexport interface DrillHeader extends BaseNode {\n  /** Node type */\n  type: typeof DRILL_HEADER\n}\n\n/**\n * Node representing a done command. This represents an `M02` or `M00` command\n * in a Gerber file or an `M00` or `M30` in an NC drill file. Its presence in a\n * tree means the full source file was parsed.\n *\n * @category Node\n */\nexport interface Done extends BaseNode {\n  /** Node type */\n  type: typeof DONE\n}\n\n/**\n * A `Units` node specifies the units used for the file. Units may be\n * {@linkcode IN | in} or {@linkcode MM | mm}.\n *\n * @category Node\n */\nexport interface Units extends BaseNode {\n  /** Node type */\n  type: typeof UNITS\n  /** Inches or millimeters */\n  units: Types.UnitsType\n}\n\n/**\n * A `CoordinateFormat` node specifies the format of coordinate value strings.\n *\n * In Gerber and drill files, coordinates are (almost always) specified as\n * strings of digits without decimal points. `format` is a tuple where the\n * first element is the number of integer places in the string and the second\n * is the number of decimal places. Leading or trailing zeros may also be\n * omitted from the coordinate strings.\n *\n * For example, with `format` set to `[2, 4]`, some (intermediate) coordinate\n * strings could be:\n *\n * - `0.012` > `000120`\n * - `3.45` > `034500`\n * - `67` > `670000`\n *\n * With those same numbers, either {@linkcode LEADING | leading} or\n * {@linkcode TRAILING | trailing} zeros may be omitted depending on the\n * `zeroSuppression` setting:\n *\n * - `0.012` > `000120` > leading omitted: `120`, trailing omitted: `00012`\n * - `3.45` > `024500` > leading omitted: `24500`, trailing omitted: `0245`\n * - `67` > `670000` > leading omitted: `670000`, trailing omitted: `67`\n *\n * Some important things to keep in mind when processing coordinate strings\n * according to the `CoordinateFormat` node:\n *\n * - `format`, `zeroSuppression`, and/or `mode` could be left unspecified\n *     - In this case, `format` and `zeroSuppression` should be assumed or\n *       inferred, if possible\n *     - It's very safe to assume `mode` is always {@linkcode ABSOLUTE | absolute};\n *       {@linkcode INCREMENTAL | incremental} mode is deprecated and very rare\n * - Just because `zeroSuppression` is set doesn't mean zeros are dropped\n *     - It's common to see Gerber writers keep all zeros to ensure there is no\n *       ambiguity, but `zeroSuppression` still needs to be set to _something_\n * - A Gerber or NC drill file may choose to include decimal points! This is\n *   not necessarily \"in spec\", but it is unambiguous and easy to parse\n *\n * @category Node\n */\nexport interface CoordinateFormat extends BaseNode {\n  /** Node type */\n  type: typeof COORDINATE_FORMAT\n  /** Integer/decimal format setting, if known */\n  format: Types.Format | null\n  /** Zero suppression setting, if known */\n  zeroSuppression: Types.ZeroSuppression | null\n  /** Absolute or incremental coordinate system, if known */\n  mode: Types.Mode | null\n}\n\n/**\n * A `ToolDefinition` node defines a \"tool\" that may be used to either create a\n * shape (\"pad\" or \"drill hit\") or a stroke (\"trace\" or \"route\") in a later\n * graphic command.\n *\n * A tool shape may be one of:\n *\n * - {@linkcode Types.Circle} - A circle defined by a diameter\n * - {@linkcode Types.Rectangle} - A rectangle defined by sizes in the x and y axis\n * - {@linkcode Types.Obround} - A \"pill\" rectangle, with a border-radius equal to half of its shorter side\n * - {@linkcode Types.Polygon} - A regular polygon defined by its diameter, number of vertices, and rotation\n * - {@linkcode Types.MacroShape} - A shape defined by a previous {@linkcode ToolMacro}\n *\n * A tool may have a hole in its center; the `hole`, if not `null`, may be a:\n *\n * - {@linkcode Types.Circle}\n * - {@linkcode Types.Rectangle} (deprecated by the Gerber specification)\n *\n * Only `Circle` or `Rectangle` tools without a `hole` may create strokes.\n * `MacroShape` tools may not have a `hole` defined.\n *\n * @category Node\n */\nexport interface ToolDefinition extends BaseNode {\n  /** Node type */\n  type: typeof TOOL_DEFINITION\n  /** Unique tool identifier */\n  code: string\n  /** Tool shape */\n  shape: Types.ToolShape\n  /** Hole shape, if applicable */\n  hole: Types.HoleShape | null\n}\n\n/**\n * A `ToolMacro` node describes a complex shape in a Gerber file that can use a\n * variety of \"primitives\", simple arithmetic, and differing polarities to lay\n * out an image that will later be repeated.\n *\n * See the {@link https://www.ucamco.com/gerber | Gerber file specification}\n * for an in-depth description of how macros function.\n *\n * @category Node\n */\nexport interface ToolMacro extends BaseNode {\n  /** Node type */\n  type: typeof TOOL_MACRO\n  /** Unique macro identifier */\n  name: string\n  /** Macro definition blocks */\n  children: MacroBlock[]\n}\n\n/**\n * A `MacroComment` represents a comment in a macro and can be safely ignored\n *\n * @category Macro\n */\nexport interface MacroComment extends BaseNode {\n  /** Node type */\n  type: typeof MACRO_COMMENT\n  /** Comment string */\n  comment: string\n}\n\n/**\n * A `MacroVariable` node assigns a value to the `name` variable in a macro,\n * where that value may be a number or an arithmetic expression.\n *\n * @category Macro\n */\nexport interface MacroVariable extends BaseNode {\n  /** Node type */\n  type: typeof MACRO_VARIABLE\n  /** Variable name */\n  name: string\n  /** Concrete value or expression to assign to variable */\n  value: Types.MacroValue\n}\n\n/**\n * A `MacroPrimitive` node describes a shape to add to the overall macro shape.\n *\n * @category Macro\n */\nexport interface MacroPrimitive extends BaseNode {\n  /** Node type */\n  type: typeof MACRO_PRIMITIVE\n  /** Primitive shape type */\n  code: Types.MacroPrimitiveCode\n  /** Shape parameter values or expressions */\n  parameters: Types.MacroValue[]\n}\n\n/**\n * A `ToolChange` node sets the current active \"tool\". At a given point in the\n * file, the active tool determines the image that graphical operations produce.\n *\n * @category Node\n */\nexport interface ToolChange extends BaseNode {\n  /** Node type */\n  type: typeof TOOL_CHANGE\n  /** Tool identifier */\n  code: string\n}\n\n/**\n * A `LoadPolarity` node sets the current polarity to {@linkcode DARK | dark}\n * or {@linkcode CLEAR | clear}. Subsequent {@linkcode Graphic} operations\n * add to the overall image if the polarity is \"dark\", or remove from the image\n * if the polarity is \"clear\".\n *\n * @category Node\n */\nexport interface LoadPolarity extends BaseNode {\n  /** Node type */\n  type: typeof LOAD_POLARITY\n  /** Polarity */\n  polarity: Types.Polarity\n}\n\n/**\n * A `StepRepeat` node starts or ends a step repeat block.\n *\n * See the {@link https://www.ucamco.com/gerber | Gerber file specification}\n * for an in-depth description of step repeat blocks.\n *\n * @category Node\n */\nexport interface StepRepeat extends BaseNode {\n  /** Node type */\n  type: typeof STEP_REPEAT\n  /** Step repeat parameters */\n  stepRepeat: Types.StepRepeatParameters\n}\n\n/**\n * A `Graphic` node that represents an image being draw to the active layer.\n * The type of image \"drawn\" is dependent on the value of `graphic`:\n *\n * - {@linkcode SHAPE | shape} - the shape of the current tool is added to the\n *   image at `coordinates`\n * - {@linkcode MOVE | move} - the plotter is \"moved\" to `coordinates` **without\n *   drawing anything to the image**\n * - {@linkcode SEGMENT | segment} - the tool is \"stroked\" from the plotter's\n *   current location to `coordinates`\n *     - The path the tool takes is determined by the current {@linkcode InterpolateMode}\n *     - The segment may be a standalone path, or it may be a part of a region\n *       fill set by a {@linkcode RegionMode}\n *     - Only {@linkcode Circle} or {@linkcode Rectangle} tools may create\n *       standalone paths\n * - {@linkcode SLOT | slot} - a drill-file-specific graphic that creates a\n *   slot from `(coordinates.x1, coordinates.y1)` to `(coordinates.x2, coordinates.y2)`\n * - `null` - The graphic type was not explicitly specified in the source file\n *     - This is deprecated syntax in Gerber files, but if present the last\n *       used graphic type should be repeated\n *     - In a drill file, this means `shape` if in `drill` mode (default),\n *       `move` if in `move` mode, or `segment` if in a routing mode\n *\n * @category Node\n */\nexport interface Graphic extends BaseNode {\n  /** Node type */\n  type: typeof GRAPHIC\n  /** Graphical operation */\n  graphic: Types.GraphicType\n  /** Coordinates where the graphic will be applied */\n  coordinates: Types.Coordinates\n}\n\n/**\n * An `InterpolateMode` node is a command to define how subsequent `segment`\n * (or `null`, if you're processing a drill file) graphic nodes are rendered.\n * The `mode` may be one of:\n *\n * - {@linkcode LINE | line} - Draw a straight line segment\n * - {@linkcode CW_ARC | cwArc} - Draw a clockwise arc segment\n * - {@linkcode CCW_ARC | ccwArc} - Draw a counterclockwise arc segment\n * - {@linkcode MOVE | move } - (Drill file only) Move the current coordinate without drawing\n * - {@linkcode DRILL | drill} - (Drill file only) Draw a shape with the current tool\n *\n * @category Node\n */\nexport interface InterpolateMode extends BaseNode {\n  type: typeof INTERPOLATE_MODE\n  mode: Types.InterpolateModeType\n}\n\n/**\n * A `RegionMode` node is a command to treat subsequent graphics as part of a\n * region definition. Regions are typically used to describe things like\n * copper fills, and only occur in Gerber files. In region mode:\n *\n * - `segment` graphics define the edges of the region\n * - `move` graphics end the current region and start a new one\n * - Other graphics are disallowed\n *\n * @category Node\n */\nexport interface RegionMode extends BaseNode {\n  type: typeof REGION_MODE\n  region: boolean\n}\n\n/**\n * A `QuadrantMode` node determines how subsequent arc segments are drawn.\n *\n * See the {@link https://www.ucamco.com/gerber | Gerber file specification}\n * for an in-depth description of arc plotting.\n *\n * @category Node\n */\nexport interface QuadrantMode extends BaseNode {\n  type: typeof QUADRANT_MODE\n  quadrant: Types.QuadrantModeType\n}\n\n/**\n * An `Unimplemented` node is a chunk that the parser recognizes as part of a\n * Gerber file, but that it doesn't know how to process. These Nodes may be\n * implemented in a future minor release of the parser and should be used with\n * caution.\n *\n * Most unimplemented nodes will either be deprecated commands or valid\n * commands in the {@link https://www.ucamco.com/gerber | Gerber specification}\n * that we don't yet support.\n *\n * @category Node\n */\nexport interface Unimplemented extends BaseNode {\n  /** Node type */\n  type: typeof UNIMPLEMENTED\n  /** String value of chunk */\n  value: string\n}\n\nexport type GerberTree = Root\n\nexport type GerberNode = ChildNode\n","import type {Position} from 'unist'\nimport type {Token} from '../lexer'\nimport {NUMBER, COORD_CHAR, G_CODE, D_CODE} from '../lexer'\nimport type {Coordinates, InterpolateModeType, GraphicType} from '../types'\nimport {SEGMENT, MOVE, SHAPE, LINE, CW_ARC, CCW_ARC, DRILL} from '../constants'\n\nexport function tokensToCoordinates(tokens: Token[]): Coordinates {\n  return Object.fromEntries(\n    tokens\n      .map((token, i) => [token, tokens[i - 1]])\n      .filter(([token, previousToken]) => {\n        return token.type === NUMBER && previousToken?.type === COORD_CHAR\n      })\n      .map(([token, previousToken]) => {\n        return [previousToken.value.toLowerCase(), token.value]\n      })\n  )\n}\n\nexport function tokensToMode(tokens: Token[]): InterpolateModeType {\n  const maybeMode = tokens\n    .filter(t => t.type === G_CODE)\n    .map(t => {\n      if (t.value === '0') return MOVE\n      if (t.value === '1') return LINE\n      if (t.value === '2') return CW_ARC\n      if (t.value === '3') return CCW_ARC\n      if (t.value === '5') return DRILL\n      return null\n    })\n\n  return maybeMode[0] ?? null\n}\n\nexport function tokensToGraphic(tokens: Token[]): GraphicType {\n  const maybeGraphic = tokens\n    .filter(t => t.type === D_CODE)\n    .map(t => {\n      if (t.value === '1') return SEGMENT\n      if (t.value === '2') return MOVE\n      if (t.value === '3') return SHAPE\n      return null\n    })\n\n  return maybeGraphic[0] ?? null\n}\n\nexport function tokensToString(tokens: Token[]): string {\n  return tokens\n    .map(t => t.value)\n    .join('')\n    .trim()\n}\n\nexport function tokensToPosition(\n  tokens: Token[],\n  options: Partial<{head: Token; length: number}> = {}\n): Position {\n  const {head = tokens[0], length = 0} = options\n  const tail =\n    length > 0\n      ? tokens[tokens.indexOf(head) + length - 1]\n      : tokens[tokens.length - 1]\n\n  return {\n    start: {line: head.line, column: head.col, offset: head.offset},\n    end: {line: tail.line, column: tail.col, offset: tail.offset},\n  }\n}\n","// Drill file grammar\nimport * as Lexer from '../lexer'\nimport * as Tree from '../tree'\nimport * as Constants from '../constants'\nimport type * as Types from '../types'\nimport type {SyntaxRule} from './rules'\nimport {token, notToken, one, zeroOrOne, zeroOrMore, minToMax} from './rules'\n\nimport {\n  tokensToCoordinates,\n  tokensToMode,\n  tokensToString,\n  tokensToPosition,\n} from './map-tokens'\n\nconst units: SyntaxRule = {\n  name: 'units',\n  rules: [\n    one([\n      token(Lexer.DRILL_UNITS),\n      token(Lexer.M_CODE, '71'),\n      token(Lexer.M_CODE, '72'),\n    ]),\n    zeroOrMore([\n      token(Lexer.COMMA),\n      token(Lexer.DRILL_ZERO_INCLUSION),\n      token(Lexer.NUMBER, /^0{1,8}\\.0{1,8}$/),\n    ]),\n    token(Lexer.NEWLINE),\n  ],\n  createNodes(tokens) {\n    const units =\n      tokens[0].value === 'INCH' || tokens[0].value === '72'\n        ? Constants.IN\n        : Constants.MM\n\n    const zeroSuppression = tokens\n      .filter(t => t.type === Lexer.DRILL_ZERO_INCLUSION)\n      .map(t => {\n        if (t.value === 'LZ') return Constants.TRAILING\n        if (t.value === 'TZ') return Constants.LEADING\n        return null\n      })\n\n    const format = tokens\n      .filter(t => t.type === Lexer.NUMBER)\n      .map<Types.Format>(t => {\n        const [integer = '', decimal = ''] = t.value.split('.')\n        return [integer.length, decimal.length]\n      })\n\n    const nodes: Tree.ChildNode[] = [\n      {type: Tree.UNITS, position: tokensToPosition(tokens.slice(0, 2)), units},\n    ]\n\n    if (zeroSuppression.length > 0 || format.length > 0) {\n      nodes.push({\n        type: Tree.COORDINATE_FORMAT,\n        position: tokensToPosition(tokens.slice(1)),\n        mode: null,\n        format: format[0] ?? null,\n        zeroSuppression: zeroSuppression[0] ?? null,\n      })\n    }\n\n    return nodes\n  },\n}\n\nconst tool: SyntaxRule = {\n  name: 'tool',\n  rules: [\n    token(Lexer.T_CODE),\n    minToMax(0, 12, [\n      token(Lexer.COORD_CHAR, 'C'),\n      token(Lexer.COORD_CHAR, 'F'),\n      token(Lexer.COORD_CHAR, 'S'),\n      token(Lexer.COORD_CHAR, 'B'),\n      token(Lexer.COORD_CHAR, 'H'),\n      token(Lexer.COORD_CHAR, 'Z'),\n      token(Lexer.NUMBER),\n    ]),\n    token(Lexer.NEWLINE),\n  ],\n  createNodes(tokens) {\n    const code = tokens[0].value\n    const position = tokensToPosition(tokens)\n    const {c = null} = tokensToCoordinates(tokens.slice(1, -1))\n    const shape: Types.ToolShape | null =\n      c === null ? null : {type: Constants.CIRCLE, diameter: Number(c)}\n\n    return shape\n      ? [{type: Tree.TOOL_DEFINITION, hole: null, position, shape, code}]\n      : [{type: Tree.TOOL_CHANGE, position, code}]\n  },\n}\n\nconst mode: SyntaxRule = {\n  name: 'operationMode',\n  rules: [\n    one([\n      token(Lexer.G_CODE, '0'),\n      token(Lexer.G_CODE, '1'),\n      token(Lexer.G_CODE, '2'),\n      token(Lexer.G_CODE, '3'),\n      token(Lexer.G_CODE, '5'),\n    ]),\n    token(Lexer.NEWLINE),\n  ],\n  createNodes: tokens => [\n    {\n      type: Tree.INTERPOLATE_MODE,\n      position: tokensToPosition(tokens),\n      mode: tokensToMode(tokens),\n    },\n  ],\n}\n\nconst operation: SyntaxRule = {\n  name: 'operation',\n  rules: [\n    minToMax(0, 2, [\n      token(Lexer.T_CODE),\n      token(Lexer.G_CODE, '0'),\n      token(Lexer.G_CODE, '1'),\n      token(Lexer.G_CODE, '2'),\n      token(Lexer.G_CODE, '3'),\n      token(Lexer.G_CODE, '5'),\n    ]),\n    minToMax(2, 8, [token(Lexer.COORD_CHAR), token(Lexer.NUMBER)]),\n    zeroOrOne([token(Lexer.T_CODE)]),\n    token(Lexer.NEWLINE),\n  ],\n  createNodes(tokens) {\n    const graphicTokens = tokens.filter(\n      t => t.type === Lexer.COORD_CHAR || t.type === Lexer.NUMBER\n    )\n    const modeToken = tokens.find(t => t.type === Lexer.G_CODE)\n    const toolToken = tokens.find(t => t.type === Lexer.T_CODE)\n    const coordinates = tokensToCoordinates(graphicTokens)\n    const code = toolToken ? toolToken.value : null\n    const mode = tokensToMode(tokens)\n\n    const graphicPosition = tokensToPosition(tokens, {\n      head: graphicTokens[0],\n      length: graphicTokens.length + 1,\n    })\n    const modePosition = tokensToPosition(tokens, {head: modeToken, length: 2})\n    const toolPosition = tokensToPosition(tokens, {head: toolToken, length: 2})\n\n    const nodes: Tree.ChildNode[] = [\n      {\n        type: Tree.GRAPHIC,\n        position: graphicPosition,\n        graphic: null,\n        coordinates,\n      },\n    ]\n\n    if (mode) {\n      nodes.unshift({type: Tree.INTERPOLATE_MODE, position: modePosition, mode})\n    }\n\n    if (code) {\n      nodes.unshift({type: Tree.TOOL_CHANGE, position: toolPosition, code})\n    }\n\n    return nodes\n  },\n}\n\nconst slot: SyntaxRule = {\n  name: 'slot',\n  rules: [\n    minToMax(2, 4, [token(Lexer.COORD_CHAR), token(Lexer.NUMBER)]),\n    token(Lexer.G_CODE, '85'),\n    minToMax(2, 4, [token(Lexer.COORD_CHAR), token(Lexer.NUMBER)]),\n    token(Lexer.NEWLINE),\n  ],\n  createNodes(tokens) {\n    const gCode = tokens.find(t => t.type === Lexer.G_CODE)\n    const splitIdx = gCode ? tokens.indexOf(gCode) : -1\n    const start = Object.fromEntries(\n      Object.entries(tokensToCoordinates(tokens.slice(0, splitIdx))).map(\n        ([axis, value]) => [`${axis}0`, value]\n      )\n    )\n    const end = tokensToCoordinates(tokens.slice(splitIdx))\n\n    return [\n      {\n        type: Tree.GRAPHIC,\n        position: tokensToPosition(tokens),\n        graphic: Constants.SLOT,\n        coordinates: {...start, ...end},\n      },\n    ]\n  },\n}\n\nconst done: SyntaxRule = {\n  name: 'done',\n  rules: [\n    one([token(Lexer.M_CODE, '30'), token(Lexer.M_CODE, '0')]),\n    token(Lexer.NEWLINE),\n  ],\n  createNodes: tokens => [\n    {type: Tree.DONE, position: tokensToPosition(tokens)},\n  ],\n}\n\nconst header: SyntaxRule = {\n  name: 'header',\n  rules: [\n    one([token(Lexer.M_CODE, '48'), token(Lexer.PERCENT)]),\n    token(Lexer.NEWLINE),\n  ],\n  createNodes: tokens => [\n    {type: Tree.DRILL_HEADER, position: tokensToPosition(tokens)},\n  ],\n}\n\nconst comment: SyntaxRule = {\n  name: 'comment',\n  rules: [\n    token(Lexer.SEMICOLON),\n    zeroOrMore([notToken(Lexer.NEWLINE)]),\n    token(Lexer.NEWLINE),\n  ],\n  createNodes: tokens => [\n    {\n      type: Tree.COMMENT,\n      comment: tokensToString(tokens.slice(1, -1)),\n      position: tokensToPosition(tokens),\n    },\n  ],\n}\n\nexport const drillGrammar: SyntaxRule[] = [\n  tool,\n  mode,\n  operation,\n  slot,\n  comment,\n  units,\n  done,\n  header,\n].map(r => ({...r, filetype: Constants.DRILL}))\n","// Gerber aperture macro syntax\nimport * as Lexer from '../lexer'\nimport * as Tree from '../tree'\nimport type {MacroValue, MacroPrimitiveCode} from '../types'\n\nimport {tokensToPosition} from './map-tokens'\nimport type {SyntaxRule} from './rules'\nimport {token, notToken, zeroOrMore, oneOrMore, findSyntaxMatch} from './rules'\n\nconst macroComment: SyntaxRule<Tree.MacroBlock> = {\n  name: 'macroComment',\n  rules: [\n    token(Lexer.NUMBER, '0'),\n    zeroOrMore([notToken(Lexer.ASTERISK)]),\n    token(Lexer.ASTERISK),\n  ],\n  createNodes: createMacroComment,\n}\n\nconst macroVariable: SyntaxRule<Tree.MacroBlock> = {\n  name: 'macroVariable',\n  rules: [\n    token(Lexer.GERBER_MACRO_VARIABLE),\n    token(Lexer.EQUALS),\n    oneOrMore([\n      token(Lexer.NUMBER),\n      token(Lexer.OPERATOR),\n      token(Lexer.GERBER_MACRO_VARIABLE),\n      token(Lexer.COORD_CHAR, 'X'),\n    ]),\n    token(Lexer.ASTERISK),\n  ],\n  createNodes: createMacroVariable,\n}\n\nconst macroPrimitive: SyntaxRule<Tree.MacroBlock> = {\n  name: 'macroPrimitive',\n  rules: [\n    token(Lexer.NUMBER),\n    token(Lexer.COMMA),\n    oneOrMore([\n      token(Lexer.COMMA),\n      token(Lexer.NUMBER),\n      token(Lexer.OPERATOR),\n      token(Lexer.GERBER_MACRO_VARIABLE),\n      token(Lexer.COORD_CHAR, 'X'),\n    ]),\n    token(Lexer.ASTERISK),\n  ],\n  createNodes: createMacroPrimitive,\n}\n\nfunction createMacroComment(tokens: Lexer.Token[]): Tree.MacroComment[] {\n  const comment = tokens\n    .slice(1, -1)\n    .map(t => t.text)\n    .join('')\n    .trim()\n\n  return [\n    {type: Tree.MACRO_COMMENT, position: tokensToPosition(tokens), comment},\n  ]\n}\n\nfunction createMacroPrimitive(tokens: Lexer.Token[]): Tree.MacroPrimitive[] {\n  const code = tokens[0].value as MacroPrimitiveCode\n  const commaDelimitedTokens: Lexer.Token[][] = [[]]\n  let currentGroup = commaDelimitedTokens[0]\n\n  for (const token of tokens.slice(2, -1)) {\n    if (token.type === Lexer.COMMA) {\n      currentGroup = []\n      commaDelimitedTokens.push(currentGroup)\n    } else {\n      currentGroup.push(token)\n    }\n  }\n\n  const parameters = commaDelimitedTokens.map(tokens =>\n    parseMacroExpression(tokens)\n  )\n\n  return [\n    {\n      type: Tree.MACRO_PRIMITIVE,\n      position: tokensToPosition(tokens),\n      code,\n      parameters,\n    },\n  ]\n}\n\nfunction createMacroVariable(tokens: Lexer.Token[]): Tree.MacroVariable[] {\n  const name = tokens[0].value\n  const value = parseMacroExpression(tokens.slice(2, -1))\n\n  return [\n    {\n      type: Tree.MACRO_VARIABLE,\n      position: tokensToPosition(tokens),\n      name,\n      value,\n    },\n  ]\n}\n\nfunction parseMacroExpression(tokens: Lexer.Token[]): MacroValue {\n  const toParse = tokens.map<Lexer.Token>(token => {\n    return token.type === Lexer.COORD_CHAR\n      ? {...token, type: Lexer.OPERATOR, value: 'x'}\n      : token\n  })\n\n  return parseAddition()\n\n  function peekNextToken(): Lexer.Token | null {\n    return toParse[0] ?? null\n  }\n\n  // Parse numbers, variables, and parenthesis\n  function parsePrimary(): MacroValue {\n    const token = toParse.shift()!\n\n    if (token.type === Lexer.NUMBER) return Number(token.value)\n    if (token.type === Lexer.GERBER_MACRO_VARIABLE) return token.value\n\n    // Else, we've got a parentheses group, so parse it and consume the \")\"\n    const expression = parseAddition()\n    toParse.shift()\n    return expression\n  }\n\n  // Parse multiplication and division operations\n  function parseMultiplication(): MacroValue {\n    let expression = parsePrimary()\n    let nextToken = peekNextToken()\n\n    while (\n      nextToken?.type === Lexer.OPERATOR &&\n      (nextToken.value === 'x' || nextToken.value === '/')\n    ) {\n      toParse.shift()\n      expression = {\n        left: expression,\n        right: parsePrimary(),\n        operator: nextToken.value,\n      }\n      nextToken = peekNextToken()\n    }\n\n    return expression\n  }\n\n  function parseAddition(): MacroValue {\n    let expression = parseMultiplication()\n    let nextToken = peekNextToken()\n\n    while (\n      (nextToken?.type === Lexer.OPERATOR &&\n        (nextToken.value === '+' || nextToken.value === '-')) ||\n      nextToken?.type === Lexer.NUMBER\n    ) {\n      let operator: '+' | '-' = '+'\n      if (nextToken.type === Lexer.OPERATOR) {\n        toParse.shift()\n        operator = nextToken.value as '+' | '-'\n      }\n\n      const right = parseMultiplication()\n      expression = {left: expression, right, operator}\n      nextToken = peekNextToken()\n    }\n\n    return expression\n  }\n}\n\nconst MACRO_GRAMMAR = [macroPrimitive, macroVariable, macroComment]\n\nexport function parseMacroBlocks(tokens: Lexer.Token[]): Tree.MacroBlock[] {\n  let matchedCandidates = MACRO_GRAMMAR\n  let matchedTokens: Lexer.Token[] = []\n  const blocks: Tree.MacroBlock[] = []\n\n  for (const token of tokens) {\n    const result = findSyntaxMatch([...matchedTokens, token], matchedCandidates)\n\n    if (result.nodes) blocks.push(...result.nodes)\n    matchedTokens = result.tokens ?? []\n    matchedCandidates = result.candidates ?? MACRO_GRAMMAR\n  }\n\n  return blocks\n}\n","// Gerber file syntax\nimport * as Lexer from '../lexer'\nimport * as Constants from '../constants'\nimport type * as Types from '../types'\nimport * as Tree from '../tree'\nimport {parseMacroBlocks} from './macro'\nimport type {SyntaxRule} from './rules'\nimport {token, notToken, one, zeroOrMore, zeroOrOne, minToMax} from './rules'\n\nimport {\n  tokensToCoordinates,\n  tokensToMode,\n  tokensToGraphic,\n  tokensToString,\n  tokensToPosition,\n} from './map-tokens'\n\nconst holeShape = (parameters: number[]): Types.HoleShape | null => {\n  if (parameters.length === 1) {\n    const [diameter] = parameters\n    return {type: Constants.CIRCLE, diameter}\n  }\n\n  if (parameters.length === 2) {\n    const [xSize, ySize] = parameters\n    return {type: Constants.RECTANGLE, xSize, ySize}\n  }\n\n  return null\n}\n\nconst done: SyntaxRule = {\n  name: 'done',\n  rules: [\n    one([token(Lexer.M_CODE, '0'), token(Lexer.M_CODE, '2')]),\n    token(Lexer.ASTERISK),\n  ],\n  createNodes: tokens => [\n    {type: Tree.DONE, position: tokensToPosition(tokens)},\n  ],\n}\n\nconst comment: SyntaxRule = {\n  name: 'comment',\n  rules: [\n    token(Lexer.G_CODE, '4'),\n    zeroOrMore([notToken(Lexer.ASTERISK)]),\n    token(Lexer.ASTERISK),\n  ],\n  createNodes: tokens => [\n    {\n      type: Tree.COMMENT,\n      position: tokensToPosition(tokens),\n      comment: tokensToString(tokens.slice(1, -1)),\n    },\n  ],\n}\n\nconst format: SyntaxRule = {\n  name: 'format',\n  rules: [\n    token(Lexer.PERCENT),\n    token(Lexer.GERBER_FORMAT),\n    zeroOrMore([notToken(Lexer.COORD_CHAR, 'X')]),\n    token(Lexer.COORD_CHAR, 'X'),\n    token(Lexer.NUMBER),\n    token(Lexer.COORD_CHAR, 'Y'),\n    token(Lexer.NUMBER),\n    zeroOrMore([notToken(Lexer.ASTERISK)]),\n    token(Lexer.ASTERISK),\n    // Including units here is invalid syntax, but Cadence Allegro does it\n    // https://github.com/tracespace/tracespace/issues/234\n    minToMax(0, 2, [token(Lexer.GERBER_UNITS), token(Lexer.ASTERISK)]),\n    token(Lexer.PERCENT),\n  ],\n  createNodes(tokens) {\n    let format: Types.Format | null = null\n    let zeroSuppression: Types.ZeroSuppression | null = null\n    let mode: Types.Mode | null = null\n    const coords = tokensToCoordinates(tokens)\n    const formatEndIdx = tokens.findIndex(t => t.type === Lexer.ASTERISK)\n    const unitsToken = tokens.find(t => t.type === Lexer.GERBER_UNITS)\n\n    for (const t of tokens.filter(t => t.type === Lexer.GERBER_FORMAT)) {\n      if (t.value.includes('T')) zeroSuppression = Constants.TRAILING\n      if (t.value.includes('L')) zeroSuppression = Constants.LEADING\n      if (t.value.includes('I')) mode = Constants.INCREMENTAL\n      if (t.value.includes('A')) mode = Constants.ABSOLUTE\n    }\n\n    if (coords.x === coords.y && coords.x?.length === 2) {\n      const integers = Number(coords.x[0])\n      const decimals = Number(coords.x[1])\n      if (integers && decimals) format = [integers, decimals]\n    }\n\n    const nodes: Tree.ChildNode[] = [\n      {\n        type: Tree.COORDINATE_FORMAT,\n        position: tokensToPosition(tokens.slice(1, formatEndIdx + 1)),\n        zeroSuppression,\n        format,\n        mode,\n      },\n    ]\n\n    if (unitsToken) {\n      nodes.push({\n        type: Tree.UNITS,\n        position: tokensToPosition(tokens.slice(1, -1), {head: unitsToken}),\n        units: unitsToken.value === 'MM' ? Constants.MM : Constants.IN,\n      })\n    }\n\n    return nodes\n  },\n}\n\nconst units: SyntaxRule = {\n  name: 'units',\n  rules: [\n    token(Lexer.PERCENT),\n    token(Lexer.GERBER_UNITS),\n    token(Lexer.ASTERISK),\n    token(Lexer.PERCENT),\n  ],\n  createNodes: tokens => [\n    {\n      type: Tree.UNITS,\n      position: tokensToPosition(tokens.slice(1, -1)),\n      units: tokens[1].value === 'MM' ? Constants.MM : Constants.IN,\n    },\n  ],\n}\n\nconst toolMacro: SyntaxRule = {\n  name: 'toolMacro',\n  rules: [\n    token(Lexer.PERCENT),\n    token(Lexer.GERBER_TOOL_MACRO),\n    token(Lexer.ASTERISK),\n    zeroOrMore([notToken(Lexer.PERCENT)]),\n    token(Lexer.PERCENT),\n  ],\n  createNodes(tokens) {\n    const name = tokens[1].value\n    const position = tokensToPosition(tokens.slice(1, -1))\n    const blockTokens = tokens.slice(3, -1)\n\n    return [\n      {\n        type: Tree.TOOL_MACRO,\n        position,\n        children: parseMacroBlocks(blockTokens),\n        name,\n      },\n    ]\n  },\n}\n\nconst toolDefinition: SyntaxRule = {\n  name: 'toolDefinition',\n  rules: [\n    token(Lexer.PERCENT),\n    token(Lexer.GERBER_TOOL_DEF),\n    zeroOrMore([\n      token(Lexer.COMMA),\n      token(Lexer.NUMBER),\n      token(Lexer.COORD_CHAR, 'X'),\n    ]),\n    token(Lexer.ASTERISK),\n    token(Lexer.PERCENT),\n  ],\n  createNodes(tokens) {\n    let shape: Types.ToolShape\n    let hole: Types.HoleShape | null = null\n\n    const toolProps = /(\\d+)(.+)/.exec(tokens[1].value)\n    const [, code = '', name = ''] = toolProps ?? []\n    const parameters: number[] = tokens\n      .slice(3, -2)\n      .filter(t => t.type === Lexer.NUMBER)\n      .map(t => Number(t.value))\n\n    switch (name) {\n      case 'C': {\n        const [diameter, ...holeParameters] = parameters\n        shape = {type: Constants.CIRCLE, diameter}\n        hole = holeShape(holeParameters)\n        break\n      }\n\n      case 'R':\n      case 'O': {\n        const [xSize, ySize, ...holeParameters] = parameters\n        const type = name === 'R' ? Constants.RECTANGLE : Constants.OBROUND\n        shape = {type, xSize, ySize}\n        hole = holeShape(holeParameters)\n        break\n      }\n\n      case 'P': {\n        const [diameter, vertices, rotation = null, ...holeParameters] =\n          parameters\n        shape = {type: Constants.POLYGON, diameter, vertices, rotation}\n        hole = holeShape(holeParameters)\n        break\n      }\n\n      default: {\n        shape = {type: Constants.MACRO_SHAPE, name, variableValues: parameters}\n      }\n    }\n\n    return [\n      {\n        type: Tree.TOOL_DEFINITION,\n        position: tokensToPosition(tokens.slice(1, -1)),\n        code,\n        shape,\n        hole,\n      },\n    ]\n  },\n}\n\nconst toolChange: SyntaxRule = {\n  name: 'toolChange',\n  rules: [\n    zeroOrOne([token(Lexer.G_CODE, '54')]),\n    token(Lexer.D_CODE),\n    token(Lexer.ASTERISK),\n  ],\n  createNodes: tokens => [\n    {\n      type: Tree.TOOL_CHANGE,\n      position: tokensToPosition(tokens),\n      code: tokens.find(t => t.type === Lexer.D_CODE)!.value,\n    },\n  ],\n}\n\nconst createOperationNodes = (tokens: Lexer.Token[]): Tree.ChildNode[] => {\n  const graphic = tokensToGraphic(tokens)\n  const coordinates = tokensToCoordinates(tokens)\n  const mode = tokensToMode(tokens)\n  const position = tokensToPosition(tokens, {\n    head: mode ? tokens[1] : tokens[0],\n  })\n  const nodes: Tree.ChildNode[] = [\n    {type: Tree.GRAPHIC, position, graphic, coordinates},\n  ]\n  if (mode) {\n    const modePosition = tokensToPosition(tokens, {head: tokens[0], length: 2})\n    nodes.unshift({type: Tree.INTERPOLATE_MODE, position: modePosition, mode})\n  }\n\n  return nodes\n}\n\nconst operation: SyntaxRule = {\n  name: 'operation',\n  rules: [\n    zeroOrOne([\n      token(Lexer.G_CODE, '1'),\n      token(Lexer.G_CODE, '2'),\n      token(Lexer.G_CODE, '3'),\n    ]),\n    minToMax(2, 8, [token(Lexer.COORD_CHAR), token(Lexer.NUMBER)]),\n    zeroOrOne([\n      token(Lexer.D_CODE, '1'),\n      token(Lexer.D_CODE, '2'),\n      token(Lexer.D_CODE, '3'),\n    ]),\n    token(Lexer.ASTERISK),\n  ],\n  createNodes: createOperationNodes,\n}\n\nconst operationWithoutCoords: SyntaxRule = {\n  name: 'operationWithoutCoords',\n  rules: [\n    zeroOrOne([\n      token(Lexer.G_CODE, '1'),\n      token(Lexer.G_CODE, '2'),\n      token(Lexer.G_CODE, '3'),\n    ]),\n    one([\n      token(Lexer.D_CODE, '1'),\n      token(Lexer.D_CODE, '2'),\n      token(Lexer.D_CODE, '3'),\n    ]),\n    token(Lexer.ASTERISK),\n  ],\n  createNodes: createOperationNodes,\n}\n\nconst interpolationMode: SyntaxRule = {\n  name: 'interpolationMode',\n  rules: [\n    one([\n      token(Lexer.G_CODE, '1'),\n      token(Lexer.G_CODE, '2'),\n      token(Lexer.G_CODE, '3'),\n    ]),\n    token(Lexer.ASTERISK),\n  ],\n  createNodes: tokens => [\n    {\n      type: Tree.INTERPOLATE_MODE,\n      position: tokensToPosition(tokens),\n      mode: tokensToMode(tokens),\n    },\n  ],\n}\n\nconst regionMode: SyntaxRule = {\n  name: 'regionMode',\n  rules: [\n    one([token(Lexer.G_CODE, '36'), token(Lexer.G_CODE, '37')]),\n    token(Lexer.ASTERISK),\n  ],\n  createNodes: tokens => [\n    {\n      type: Tree.REGION_MODE,\n      position: tokensToPosition(tokens),\n      region: tokens[0].value === '36',\n    },\n  ],\n}\n\nconst quadrantMode: SyntaxRule = {\n  name: 'quadrantMode',\n  rules: [\n    one([token(Lexer.G_CODE, '74'), token(Lexer.G_CODE, '75')]),\n    token(Lexer.ASTERISK),\n  ],\n  createNodes: tokens => [\n    {\n      type: Tree.QUADRANT_MODE,\n      position: tokensToPosition(tokens),\n      quadrant: tokens[0].value === '74' ? Constants.SINGLE : Constants.MULTI,\n    },\n  ],\n}\n\nconst loadPolarity: SyntaxRule = {\n  name: 'loadPolarity',\n  rules: [\n    token(Lexer.PERCENT),\n    token(Lexer.GERBER_LOAD_POLARITY),\n    token(Lexer.ASTERISK),\n    token(Lexer.PERCENT),\n  ],\n  createNodes: tokens => [\n    {\n      type: Tree.LOAD_POLARITY,\n      position: tokensToPosition(tokens.slice(1, -1)),\n      polarity: tokens[1].value === 'D' ? Constants.DARK : Constants.CLEAR,\n    },\n  ],\n}\n\nconst stepRepeat: SyntaxRule = {\n  name: 'stepRepeat',\n  rules: [\n    token(Lexer.PERCENT),\n    token(Lexer.GERBER_STEP_REPEAT),\n    zeroOrMore([token(Lexer.COORD_CHAR), token(Lexer.NUMBER)]),\n    token(Lexer.ASTERISK),\n    token(Lexer.PERCENT),\n  ],\n  createNodes(tokens) {\n    const coordinates = tokensToCoordinates(tokens)\n    const parameters = Object.fromEntries(\n      Object.entries(coordinates).map(([axis, coordinateString]) => [\n        axis,\n        Number(coordinateString),\n      ])\n    )\n\n    return [\n      {\n        type: Tree.STEP_REPEAT,\n        position: tokensToPosition(tokens.slice(1, -1)),\n        stepRepeat: parameters,\n      },\n    ]\n  },\n}\n\nconst unimplementedExtendedCommand: SyntaxRule = {\n  name: 'unimplementedExtendedCommand',\n  rules: [\n    token(Lexer.PERCENT),\n    zeroOrMore([notToken(Lexer.ASTERISK)]),\n    token(Lexer.ASTERISK),\n    token(Lexer.PERCENT),\n  ],\n  createNodes: tokens => [\n    {\n      type: Tree.UNIMPLEMENTED,\n      position: tokensToPosition(tokens.slice(1, -1)),\n      value: tokensToString(tokens),\n    },\n  ],\n}\n\nexport const gerberGrammar: SyntaxRule[] = [\n  operation,\n  operationWithoutCoords,\n  interpolationMode,\n  toolChange,\n  toolDefinition,\n  toolMacro,\n  comment,\n  regionMode,\n  quadrantMode,\n  loadPolarity,\n  stepRepeat,\n  format,\n  units,\n  done,\n  unimplementedExtendedCommand,\n].map(r => ({...r, filetype: Constants.GERBER}))\n","import type {Filetype} from '../types'\nimport type {GerberNode} from '../tree'\nimport type {Token, LexerIterable, LexerState} from '../lexer'\nimport {GERBER, DRILL} from '../constants'\nimport type {SyntaxRule} from './rules'\nimport {findSyntaxMatch} from './rules'\nimport {drillGrammar} from './drill'\nimport {gerberGrammar} from './gerber'\n\nconst grammar: SyntaxRule[] = [...gerberGrammar, ...drillGrammar]\n\nexport interface MatchResult {\n  filetype: Filetype | null\n  nodes: GerberNode[]\n  unmatched: string\n  lexerState: LexerState | null\n}\n\nexport function matchSyntax(\n  tokens: LexerIterable,\n  filetype: Filetype | null = null\n): MatchResult {\n  const nodes: GerberNode[] = []\n  let matchedCandidates = getGrammar()\n  let matchedTokens: Token[] = []\n  let nextLexerState: LexerState | null = null\n  let unmatched = ''\n\n  for (const [token, lexerState] of tokens) {\n    const result = findSyntaxMatch([...matchedTokens, token], matchedCandidates)\n\n    if (result.nodes) {\n      nodes.push(...result.nodes)\n      nextLexerState = lexerState\n      unmatched = ''\n    } else {\n      unmatched += token.text\n    }\n\n    filetype = filetype ?? result.filetype ?? null\n    matchedTokens = result.tokens ?? []\n    matchedCandidates = result.candidates ?? getGrammar()\n  }\n\n  return {\n    filetype,\n    unmatched,\n    nodes,\n    lexerState: nextLexerState,\n  }\n\n  function getGrammar() {\n    if (filetype === GERBER) return gerberGrammar\n    if (filetype === DRILL) return drillGrammar\n    return grammar\n  }\n}\n","import type {Lexer, LexerState} from './lexer'\nimport {createLexer} from './lexer'\nimport {matchSyntax} from './syntax'\nimport type {GerberTree, GerberNode} from './tree'\nimport {ROOT} from './tree'\nimport type {Filetype} from './types'\n\nexport * from './constants'\nexport * from './lexer'\nexport * from './tree'\nexport * from './types'\n\n/**\n * Gerber and NC drill file parser.\n *\n * @category Parser\n */\nexport interface Parser {\n  /** Parser's {@linkcode Lexer} instance */\n  lexer: Lexer\n  /** Feed the parser with all or part of the source file */\n  feed(chunk: string): this\n  /** Get the resulting AST when you are done feeding the parser */\n  result(): GerberTree\n}\n\n/**\n * {@linkcode Parser} factory and the primary export of the library.\n *\n * @example\n * ```ts\n * import {createParser} from '@tracespace/parser'\n *\n * // create a parser to parse a single file\n * const parser = createParser()\n *\n * // feed the parser the source file contents\n * parser.feed('G04 gerber file contents*\\nM02*\\n')\n *\n * // get the resulting AST\n * const tree = parser.results()\n * ```\n *\n * @category Parser\n */\nexport function createParser(): Parser {\n  const lexer = createLexer()\n  const children: GerberNode[] = []\n  let filetype: Filetype | null = null\n  let lexerState: LexerState | null = null\n  let unmatched = ''\n\n  const parser = {lexer, feed, result}\n  return parser\n\n  function feed(chunk: string): Parser {\n    const tokens = lexer.feed(`${unmatched}${chunk}`, lexerState)\n    const result = matchSyntax(tokens, filetype)\n\n    filetype = filetype ?? result.filetype\n    unmatched = result.unmatched\n    lexerState = result.lexerState ?? lexerState\n    children.push(...result.nodes)\n\n    return parser\n  }\n\n  function result(): GerberTree {\n    if (filetype === null) {\n      throw new Error('File type not recognized')\n    }\n\n    return {type: ROOT, filetype, children}\n  }\n}\n\nexport function parse(contents: string): GerberTree {\n  return createParser().feed(contents).result()\n}\n"],"names":["root","factory","module","this","hasOwnProperty","toString","hasSticky","isRegExp","o","isObject","reEscape","s","reGroups","re","reCapture","reUnion","regexps","source","regexpOrLiteral","obj","pad","length","lastNLines","string","numLines","position","lineBreaks","idx","startPosition","objectToRules","object","keys","result","i","key","thing","rules","j","match","rule","ruleOptions","arrayToRules","array","include","type","options","a","b","toRules","spec","defaultErrorRule","compileRules","hasStates","errorRule","fast","fastAllowed","unicodeFlag","groups","parts","word","pat","regexp","groupCount","fallbackRule","flags","suffix","combined","compile","Lexer","checkStateGroup","g","name","map","state","compileStates","states","start","all","ruleMap","included","splice","newRules","k","newRule","fastKeys","keywordTransform","isMap","reverseMap","types","tokenType","item","keywordList","keyword","data","info","eat","buffer","tokenToString","index","token","group","error","text","offset","matchNL","nl","size","err","LexerIterator","lexer","message","numLinesAround","firstDisplayedLine","lastDisplayedLine","lastLineDigits","displayedLines","errorLines","line","lineNo","T_CODE","G_CODE","M_CODE","D_CODE","ASTERISK","PERCENT","EQUALS","COMMA","OPERATOR","GERBER_FORMAT","GERBER_UNITS","GERBER_TOOL_MACRO","GERBER_TOOL_DEF","GERBER_LOAD_POLARITY","GERBER_STEP_REPEAT","GERBER_MACRO_VARIABLE","SEMICOLON","DRILL_UNITS","DRILL_ZERO_INCLUSION","COORD_CHAR","NUMBER","WORD","WHITESPACE","NEWLINE","CATCHALL","ERROR","RE_STRIP_LEADING_ZEROS","stripLeadingZeros","getCodeValue","Tokens.T_CODE","Tokens.G_CODE","Tokens.M_CODE","Tokens.D_CODE","Tokens.ASTERISK","Tokens.PERCENT","Tokens.EQUALS","Tokens.GERBER_FORMAT","Tokens.GERBER_UNITS","Tokens.GERBER_TOOL_MACRO","Tokens.GERBER_TOOL_DEF","Tokens.GERBER_LOAD_POLARITY","Tokens.GERBER_STEP_REPEAT","Tokens.GERBER_MACRO_VARIABLE","Tokens.SEMICOLON","Tokens.DRILL_UNITS","Tokens.DRILL_ZERO_INCLUSION","Tokens.COORD_CHAR","Tokens.NUMBER","Tokens.OPERATOR","Tokens.COMMA","Tokens.WORD","Tokens.WHITESPACE","Tokens.NEWLINE","Tokens.CATCHALL","Tokens.ERROR","Moo","createLexer","mooLexer","feed","chunk","tokenIterator","nextToken","nextState","GERBER","DRILL","MM","IN","LEADING","TRAILING","ABSOLUTE","INCREMENTAL","CIRCLE","RECTANGLE","OBROUND","POLYGON","MACRO_SHAPE","MACRO_CIRCLE","MACRO_VECTOR_LINE_DEPRECATED","MACRO_VECTOR_LINE","MACRO_CENTER_LINE","MACRO_LOWER_LEFT_LINE_DEPRECATED","MACRO_OUTLINE","MACRO_POLYGON","MACRO_MOIRE_DEPRECATED","MACRO_THERMAL","SHAPE","MOVE","SEGMENT","SLOT","LINE","CW_ARC","CCW_ARC","SINGLE","MULTI","DARK","CLEAR","SINGLE_TOKEN","MIN_TO_MAX","value","notToken","one","zeroOrOne","zeroOrMore","oneOrMore","minToMax","min","max","findSyntaxMatch","tokens","candidates","remainingCandidates","candidate","matchType","tokenListMatches","PARTIAL_MATCH","FULL_MATCH","NO_MATCH","multiMatchCount","tokenMatches","typeResult","valueResult","ROOT","COMMENT","DRILL_HEADER","DONE","UNITS","COORDINATE_FORMAT","TOOL_DEFINITION","TOOL_MACRO","TOOL_CHANGE","LOAD_POLARITY","STEP_REPEAT","GRAPHIC","INTERPOLATE_MODE","REGION_MODE","QUADRANT_MODE","UNIMPLEMENTED","MACRO_COMMENT","MACRO_VARIABLE","MACRO_PRIMITIVE","tokensToCoordinates","previousToken","tokensToMode","t","tokensToGraphic","tokensToString","tokensToPosition","head","tail","units","Lexer.DRILL_UNITS","Lexer.M_CODE","Lexer.COMMA","Lexer.DRILL_ZERO_INCLUSION","Lexer.NUMBER","Lexer.NEWLINE","Constants.IN","Constants.MM","zeroSuppression","Constants.TRAILING","Constants.LEADING","format","integer","decimal","nodes","Tree.UNITS","Tree.COORDINATE_FORMAT","tool","Lexer.T_CODE","Lexer.COORD_CHAR","code","c","shape","Constants.CIRCLE","Tree.TOOL_DEFINITION","Tree.TOOL_CHANGE","mode","Lexer.G_CODE","Tree.INTERPOLATE_MODE","operation","graphicTokens","modeToken","toolToken","coordinates","graphicPosition","modePosition","toolPosition","Tree.GRAPHIC","slot","gCode","splitIdx","axis","end","Constants.SLOT","done","Tree.DONE","header","Lexer.PERCENT","Tree.DRILL_HEADER","comment","Lexer.SEMICOLON","Tree.COMMENT","drillGrammar","r","Constants.DRILL","macroComment","Lexer.ASTERISK","createMacroComment","macroVariable","Lexer.GERBER_MACRO_VARIABLE","Lexer.EQUALS","Lexer.OPERATOR","createMacroVariable","macroPrimitive","createMacroPrimitive","Tree.MACRO_COMMENT","commaDelimitedTokens","currentGroup","parameters","parseMacroExpression","Tree.MACRO_PRIMITIVE","Tree.MACRO_VARIABLE","toParse","parseAddition","peekNextToken","parsePrimary","expression","parseMultiplication","operator","right","MACRO_GRAMMAR","parseMacroBlocks","matchedCandidates","matchedTokens","blocks","holeShape","diameter","xSize","ySize","Constants.RECTANGLE","Lexer.GERBER_FORMAT","Lexer.GERBER_UNITS","coords","formatEndIdx","unitsToken","Constants.INCREMENTAL","Constants.ABSOLUTE","_a","integers","decimals","toolMacro","Lexer.GERBER_TOOL_MACRO","blockTokens","Tree.TOOL_MACRO","toolDefinition","Lexer.GERBER_TOOL_DEF","hole","toolProps","holeParameters","Constants.OBROUND","vertices","rotation","Constants.POLYGON","Constants.MACRO_SHAPE","toolChange","Lexer.D_CODE","createOperationNodes","graphic","operationWithoutCoords","interpolationMode","regionMode","Tree.REGION_MODE","quadrantMode","Tree.QUADRANT_MODE","Constants.SINGLE","Constants.MULTI","loadPolarity","Lexer.GERBER_LOAD_POLARITY","Tree.LOAD_POLARITY","Constants.DARK","Constants.CLEAR","stepRepeat","Lexer.GERBER_STEP_REPEAT","coordinateString","Tree.STEP_REPEAT","unimplementedExtendedCommand","Tree.UNIMPLEMENTED","gerberGrammar","Constants.GERBER","grammar","matchSyntax","filetype","getGrammar","nextLexerState","unmatched","lexerState","createParser","children","parser","parse","contents"],"mappings":"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"}